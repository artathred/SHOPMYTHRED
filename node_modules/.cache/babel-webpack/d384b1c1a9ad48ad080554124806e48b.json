{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Http2CallStream = exports.InterceptingListenerImpl = exports.isInterceptingListener = void 0;\n\nconst http2 = require(\"http2\");\n\nconst os = require(\"os\");\n\nconst constants_1 = require(\"./constants\");\n\nconst filter_stack_1 = require(\"./filter-stack\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst stream_decoder_1 = require(\"./stream-decoder\");\n\nconst logging = require(\"./logging\");\n\nconst constants_2 = require(\"./constants\");\n\nconst TRACER_NAME = 'call_stream';\nconst {\n  HTTP2_HEADER_STATUS,\n  HTTP2_HEADER_CONTENT_TYPE,\n  NGHTTP2_CANCEL\n} = http2.constants;\n/**\n * Should do approximately the same thing as util.getSystemErrorName but the\n * TypeScript types don't have that function for some reason so I just made my\n * own.\n * @param errno\n */\n\nfunction getSystemErrorName(errno) {\n  for (const [name, num] of Object.entries(os.constants.errno)) {\n    if (num === errno) {\n      return name;\n    }\n  }\n\n  return 'Unknown system error ' + errno;\n}\n\nfunction isInterceptingListener(listener) {\n  return listener.onReceiveMetadata !== undefined && listener.onReceiveMetadata.length === 1;\n}\n\nexports.isInterceptingListener = isInterceptingListener;\n\nclass InterceptingListenerImpl {\n  constructor(listener, nextListener) {\n    this.listener = listener;\n    this.nextListener = nextListener;\n    this.processingMessage = false;\n    this.pendingStatus = null;\n  }\n\n  onReceiveMetadata(metadata) {\n    this.listener.onReceiveMetadata(metadata, metadata => {\n      this.nextListener.onReceiveMetadata(metadata);\n    });\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  onReceiveMessage(message) {\n    /* If this listener processes messages asynchronously, the last message may\n     * be reordered with respect to the status */\n    this.processingMessage = true;\n    this.listener.onReceiveMessage(message, msg => {\n      this.processingMessage = false;\n      this.nextListener.onReceiveMessage(msg);\n\n      if (this.pendingStatus) {\n        this.nextListener.onReceiveStatus(this.pendingStatus);\n      }\n    });\n  }\n\n  onReceiveStatus(status) {\n    this.listener.onReceiveStatus(status, processedStatus => {\n      if (this.processingMessage) {\n        this.pendingStatus = processedStatus;\n      } else {\n        this.nextListener.onReceiveStatus(processedStatus);\n      }\n    });\n  }\n\n}\n\nexports.InterceptingListenerImpl = InterceptingListenerImpl;\n\nclass Http2CallStream {\n  constructor(methodName, channel, options, filterStackFactory, channelCallCredentials, callNumber) {\n    this.methodName = methodName;\n    this.channel = channel;\n    this.options = options;\n    this.channelCallCredentials = channelCallCredentials;\n    this.callNumber = callNumber;\n    this.http2Stream = null;\n    this.pendingRead = false;\n    this.isWriteFilterPending = false;\n    this.pendingWrite = null;\n    this.pendingWriteCallback = null;\n    this.writesClosed = false;\n    this.decoder = new stream_decoder_1.StreamDecoder();\n    this.isReadFilterPending = false;\n    this.canPush = false;\n    /**\n     * Indicates that an 'end' event has come from the http2 stream, so there\n     * will be no more data events.\n     */\n\n    this.readsClosed = false;\n    this.statusOutput = false;\n    this.unpushedReadMessages = [];\n    this.unfilteredReadMessages = []; // Status code mapped from :status. To be used if grpc-status is not received\n\n    this.mappedStatusCode = constants_1.Status.UNKNOWN; // This is populated (non-null) if and only if the call has ended\n\n    this.finalStatus = null;\n    this.subchannel = null;\n    this.listener = null;\n    this.internalError = null;\n    this.filterStack = filterStackFactory.createFilter(this);\n    this.credentials = channelCallCredentials;\n\n    this.disconnectListener = () => {\n      this.endCall({\n        code: constants_1.Status.UNAVAILABLE,\n        details: 'Connection dropped',\n        metadata: new metadata_1.Metadata()\n      });\n    };\n\n    if (this.options.parentCall && this.options.flags & constants_1.Propagate.CANCELLATION) {\n      this.options.parentCall.on('cancelled', () => {\n        this.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled by parent call');\n      });\n    }\n  }\n\n  outputStatus() {\n    /* Precondition: this.finalStatus !== null */\n    if (!this.statusOutput) {\n      this.statusOutput = true;\n      const filteredStatus = this.filterStack.receiveTrailers(this.finalStatus);\n      /* We delay the actual action of bubbling up the status to insulate the\n       * cleanup code in this class from any errors that may be thrown in the\n       * upper layers as a result of bubbling up the status. In particular,\n       * if the status is not OK, the \"error\" event may be emitted\n       * synchronously at the top level, which will result in a thrown error if\n       * the user does not handle that event. */\n\n      process.nextTick(() => {\n        var _a;\n\n        (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(filteredStatus);\n      });\n\n      if (this.subchannel) {\n        this.subchannel.callUnref();\n        this.subchannel.removeDisconnectListener(this.disconnectListener);\n      }\n    }\n  }\n\n  trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\n  }\n  /**\n   * On first call, emits a 'status' event with the given StatusObject.\n   * Subsequent calls are no-ops.\n   * @param status The status of the call.\n   */\n\n\n  endCall(status) {\n    /* If the status is OK and a new status comes in (e.g. from a\n     * deserialization failure), that new status takes priority */\n    if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {\n      this.trace('ended with status: code=' + status.code + ' details=\"' + status.details + '\"');\n      this.finalStatus = status;\n      this.maybeOutputStatus();\n    }\n\n    this.destroyHttp2Stream();\n  }\n\n  maybeOutputStatus() {\n    if (this.finalStatus !== null) {\n      /* The combination check of readsClosed and that the two message buffer\n       * arrays are empty checks that there all incoming data has been fully\n       * processed */\n      if (this.finalStatus.code !== constants_1.Status.OK || this.readsClosed && this.unpushedReadMessages.length === 0 && this.unfilteredReadMessages.length === 0 && !this.isReadFilterPending) {\n        this.outputStatus();\n      }\n    }\n  }\n\n  push(message) {\n    this.trace('pushing to reader message of length ' + (message instanceof Buffer ? message.length : null));\n    this.canPush = false;\n    process.nextTick(() => {\n      var _a;\n      /* If we have already output the status any later messages should be\n       * ignored, and can cause out-of-order operation errors higher up in the\n       * stack. Checking as late as possible here to avoid any race conditions.\n       */\n\n\n      if (this.statusOutput) {\n        return;\n      }\n\n      (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveMessage(message);\n      this.maybeOutputStatus();\n    });\n  }\n\n  handleFilterError(error) {\n    this.cancelWithStatus(constants_1.Status.INTERNAL, error.message);\n  }\n\n  handleFilteredRead(message) {\n    /* If we the call has already ended with an error, we don't want to do\n     * anything with this message. Dropping it on the floor is correct\n     * behavior */\n    if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n      this.maybeOutputStatus();\n      return;\n    }\n\n    this.isReadFilterPending = false;\n\n    if (this.canPush) {\n      this.http2Stream.pause();\n      this.push(message);\n    } else {\n      this.trace('unpushedReadMessages.push message of length ' + message.length);\n      this.unpushedReadMessages.push(message);\n    }\n\n    if (this.unfilteredReadMessages.length > 0) {\n      /* nextMessage is guaranteed not to be undefined because\n         unfilteredReadMessages is non-empty */\n      const nextMessage = this.unfilteredReadMessages.shift();\n      this.filterReceivedMessage(nextMessage);\n    }\n  }\n\n  filterReceivedMessage(framedMessage) {\n    /* If we the call has already ended with an error, we don't want to do\n     * anything with this message. Dropping it on the floor is correct\n     * behavior */\n    if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n      this.maybeOutputStatus();\n      return;\n    }\n\n    this.trace('filterReceivedMessage of length ' + framedMessage.length);\n    this.isReadFilterPending = true;\n    this.filterStack.receiveMessage(Promise.resolve(framedMessage)).then(this.handleFilteredRead.bind(this), this.handleFilterError.bind(this));\n  }\n\n  tryPush(messageBytes) {\n    if (this.isReadFilterPending) {\n      this.trace('unfilteredReadMessages.push message of length ' + (messageBytes && messageBytes.length));\n      this.unfilteredReadMessages.push(messageBytes);\n    } else {\n      this.filterReceivedMessage(messageBytes);\n    }\n  }\n\n  handleTrailers(headers) {\n    let headersString = '';\n\n    for (const header of Object.keys(headers)) {\n      headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n    }\n\n    this.trace('Received server trailers:\\n' + headersString);\n    let metadata;\n\n    try {\n      metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n    } catch (e) {\n      metadata = new metadata_1.Metadata();\n    }\n\n    const metadataMap = metadata.getMap();\n    let code = this.mappedStatusCode;\n\n    if (code === constants_1.Status.UNKNOWN && typeof metadataMap['grpc-status'] === 'string') {\n      const receivedStatus = Number(metadataMap['grpc-status']);\n\n      if (receivedStatus in constants_1.Status) {\n        code = receivedStatus;\n        this.trace('received status code ' + receivedStatus + ' from server');\n      }\n\n      metadata.remove('grpc-status');\n    }\n\n    let details = '';\n\n    if (typeof metadataMap['grpc-message'] === 'string') {\n      details = decodeURI(metadataMap['grpc-message']);\n      metadata.remove('grpc-message');\n      this.trace('received status details string \"' + details + '\" from server');\n    }\n\n    const status = {\n      code,\n      details,\n      metadata\n    }; // This is a no-op if the call was already ended when handling headers.\n\n    this.endCall(status);\n  }\n\n  attachHttp2Stream(stream, subchannel, extraFilterFactory) {\n    if (extraFilterFactory !== undefined) {\n      this.filterStack = new filter_stack_1.FilterStack([this.filterStack, extraFilterFactory.createFilter(this)]);\n    }\n\n    if (this.finalStatus !== null) {\n      stream.close(NGHTTP2_CANCEL);\n    } else {\n      this.trace('attachHttp2Stream from subchannel ' + subchannel.getAddress());\n      this.http2Stream = stream;\n      this.subchannel = subchannel;\n      subchannel.addDisconnectListener(this.disconnectListener);\n      subchannel.callRef();\n      stream.on('response', (headers, flags) => {\n        var _a;\n\n        let headersString = '';\n\n        for (const header of Object.keys(headers)) {\n          headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n        }\n\n        this.trace('Received server headers:\\n' + headersString);\n\n        switch (headers[':status']) {\n          // TODO(murgatroid99): handle 100 and 101\n          case 400:\n            this.mappedStatusCode = constants_1.Status.INTERNAL;\n            break;\n\n          case 401:\n            this.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;\n            break;\n\n          case 403:\n            this.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;\n            break;\n\n          case 404:\n            this.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;\n            break;\n\n          case 429:\n          case 502:\n          case 503:\n          case 504:\n            this.mappedStatusCode = constants_1.Status.UNAVAILABLE;\n            break;\n\n          default:\n            this.mappedStatusCode = constants_1.Status.UNKNOWN;\n        }\n\n        if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n          this.handleTrailers(headers);\n        } else {\n          let metadata;\n\n          try {\n            metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n          } catch (error) {\n            this.endCall({\n              code: constants_1.Status.UNKNOWN,\n              details: error.message,\n              metadata: new metadata_1.Metadata()\n            });\n            return;\n          }\n\n          try {\n            const finalMetadata = this.filterStack.receiveMetadata(metadata);\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveMetadata(finalMetadata);\n          } catch (error) {\n            this.endCall({\n              code: constants_1.Status.UNKNOWN,\n              details: error.message,\n              metadata: new metadata_1.Metadata()\n            });\n          }\n        }\n      });\n      stream.on('trailers', this.handleTrailers.bind(this));\n      stream.on('data', data => {\n        this.trace('receive HTTP/2 data frame of length ' + data.length);\n        const messages = this.decoder.write(data);\n\n        for (const message of messages) {\n          this.trace('parsed message of length ' + message.length);\n          this.tryPush(message);\n        }\n      });\n      stream.on('end', () => {\n        this.readsClosed = true;\n        this.maybeOutputStatus();\n      });\n      stream.on('close', () => {\n        /* Use process.next tick to ensure that this code happens after any\n         * \"error\" event that may be emitted at about the same time, so that\n         * we can bubble up the error message from that event. */\n        process.nextTick(() => {\n          var _a;\n\n          this.trace('HTTP/2 stream closed with code ' + stream.rstCode);\n          /* If we have a final status with an OK status code, that means that\n           * we have received all of the messages and we have processed the\n           * trailers and the call completed successfully, so it doesn't matter\n           * how the stream ends after that */\n\n          if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n            return;\n          }\n\n          let code;\n          let details = '';\n\n          switch (stream.rstCode) {\n            case http2.constants.NGHTTP2_NO_ERROR:\n              /* If we get a NO_ERROR code and we already have a status, the\n               * stream completed properly and we just haven't fully processed\n               * it yet */\n              if (this.finalStatus !== null) {\n                return;\n              }\n\n              code = constants_1.Status.INTERNAL;\n              details = `Received RST_STREAM with code ${stream.rstCode}`;\n              break;\n\n            case http2.constants.NGHTTP2_REFUSED_STREAM:\n              code = constants_1.Status.UNAVAILABLE;\n              details = 'Stream refused by server';\n              break;\n\n            case http2.constants.NGHTTP2_CANCEL:\n              code = constants_1.Status.CANCELLED;\n              details = 'Call cancelled';\n              break;\n\n            case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n              code = constants_1.Status.RESOURCE_EXHAUSTED;\n              details = 'Bandwidth exhausted';\n              break;\n\n            case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n              code = constants_1.Status.PERMISSION_DENIED;\n              details = 'Protocol not secure enough';\n              break;\n\n            case http2.constants.NGHTTP2_INTERNAL_ERROR:\n              code = constants_1.Status.INTERNAL;\n\n              if (this.internalError === null) {\n                /* This error code was previously handled in the default case, and\n                 * there are several instances of it online, so I wanted to\n                 * preserve the original error message so that people find existing\n                 * information in searches, but also include the more recognizable\n                 * \"Internal server error\" message. */\n                details = `Received RST_STREAM with code ${stream.rstCode} (Internal server error)`;\n              } else {\n                if (this.internalError.code === 'ECONNRESET') {\n                  code = constants_1.Status.UNAVAILABLE;\n                  details = this.internalError.message;\n                } else {\n                  /* The \"Received RST_STREAM with code ...\" error is preserved\n                   * here for continuity with errors reported online, but the\n                   * error message at the end will probably be more relevant in\n                   * most cases. */\n                  details = `Received RST_STREAM with code ${stream.rstCode} triggered by internal client error: ${this.internalError.message}`;\n                }\n              }\n\n              break;\n\n            default:\n              code = constants_1.Status.INTERNAL;\n              details = `Received RST_STREAM with code ${stream.rstCode}`;\n          } // This is a no-op if trailers were received at all.\n          // This is OK, because status codes emitted here correspond to more\n          // catastrophic issues that prevent us from receiving trailers in the\n          // first place.\n\n\n          this.endCall({\n            code,\n            details,\n            metadata: new metadata_1.Metadata()\n          });\n        });\n      });\n      stream.on('error', err => {\n        /* We need an error handler here to stop \"Uncaught Error\" exceptions\n         * from bubbling up. However, errors here should all correspond to\n         * \"close\" events, where we will handle the error more granularly */\n\n        /* Specifically looking for stream errors that were *not* constructed\n         * from a RST_STREAM response here:\n         * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267\n         */\n        if (err.code !== 'ERR_HTTP2_STREAM_ERROR') {\n          this.trace('Node error event: message=' + err.message + ' code=' + err.code + ' errno=' + getSystemErrorName(err.errno) + ' syscall=' + err.syscall);\n          this.internalError = err;\n        }\n      });\n\n      if (!this.pendingRead) {\n        stream.pause();\n      }\n\n      if (this.pendingWrite) {\n        if (!this.pendingWriteCallback) {\n          throw new Error('Invalid state in write handling code');\n        }\n\n        this.trace('sending data chunk of length ' + this.pendingWrite.length + ' (deferred)');\n        stream.write(this.pendingWrite, this.pendingWriteCallback);\n      }\n\n      this.maybeCloseWrites();\n    }\n  }\n\n  start(metadata, listener) {\n    this.trace('Sending metadata');\n    this.listener = listener;\n\n    this.channel._startCallStream(this, metadata);\n  }\n\n  destroyHttp2Stream() {\n    var _a; // The http2 stream could already have been destroyed if cancelWithStatus\n    // is called in response to an internal http2 error.\n\n\n    if (this.http2Stream !== null && !this.http2Stream.destroyed) {\n      /* If the call has ended with an OK status, communicate that when closing\n       * the stream, partly to avoid a situation in which we detect an error\n       * RST_STREAM as a result after we have the status */\n      let code;\n\n      if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n        code = http2.constants.NGHTTP2_NO_ERROR;\n      } else {\n        code = http2.constants.NGHTTP2_CANCEL;\n      }\n\n      this.trace('close http2 stream with code ' + code);\n      this.http2Stream.close(code);\n    }\n  }\n\n  cancelWithStatus(status, details) {\n    this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n    this.endCall({\n      code: status,\n      details,\n      metadata: new metadata_1.Metadata()\n    });\n  }\n\n  getDeadline() {\n    if (this.options.parentCall && this.options.flags & constants_1.Propagate.DEADLINE) {\n      const parentDeadline = this.options.parentCall.getDeadline();\n      const selfDeadline = this.options.deadline;\n      const parentDeadlineMsecs = parentDeadline instanceof Date ? parentDeadline.getTime() : parentDeadline;\n      const selfDeadlineMsecs = selfDeadline instanceof Date ? selfDeadline.getTime() : selfDeadline;\n      return Math.min(parentDeadlineMsecs, selfDeadlineMsecs);\n    } else {\n      return this.options.deadline;\n    }\n  }\n\n  getCredentials() {\n    return this.credentials;\n  }\n\n  setCredentials(credentials) {\n    this.credentials = this.channelCallCredentials.compose(credentials);\n  }\n\n  getStatus() {\n    return this.finalStatus;\n  }\n\n  getPeer() {\n    var _a, _b;\n\n    return (_b = (_a = this.subchannel) === null || _a === void 0 ? void 0 : _a.getAddress()) !== null && _b !== void 0 ? _b : this.channel.getTarget();\n  }\n\n  getMethod() {\n    return this.methodName;\n  }\n\n  getHost() {\n    return this.options.host;\n  }\n\n  startRead() {\n    /* If the stream has ended with an error, we should not emit any more\n     * messages and we should communicate that the stream has ended */\n    if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n      this.readsClosed = true;\n      this.maybeOutputStatus();\n      return;\n    }\n\n    this.canPush = true;\n\n    if (this.http2Stream === null) {\n      this.pendingRead = true;\n    } else {\n      if (this.unpushedReadMessages.length > 0) {\n        const nextMessage = this.unpushedReadMessages.shift();\n        this.push(nextMessage);\n        return;\n      }\n      /* Only resume reading from the http2Stream if we don't have any pending\n       * messages to emit */\n\n\n      this.http2Stream.resume();\n    }\n  }\n\n  maybeCloseWrites() {\n    if (this.writesClosed && !this.isWriteFilterPending && this.http2Stream !== null) {\n      this.trace('calling end() on HTTP/2 stream');\n      this.http2Stream.end();\n    }\n  }\n\n  sendMessageWithContext(context, message) {\n    var _a;\n\n    this.trace('write() called with message of length ' + message.length);\n    const writeObj = {\n      message,\n      flags: context.flags\n    };\n    const cb = (_a = context.callback) !== null && _a !== void 0 ? _a : () => {};\n    this.isWriteFilterPending = true;\n    this.filterStack.sendMessage(Promise.resolve(writeObj)).then(message => {\n      this.isWriteFilterPending = false;\n\n      if (this.http2Stream === null) {\n        this.trace('deferring writing data chunk of length ' + message.message.length);\n        this.pendingWrite = message.message;\n        this.pendingWriteCallback = cb;\n      } else {\n        this.trace('sending data chunk of length ' + message.message.length);\n        this.http2Stream.write(message.message, cb);\n        this.maybeCloseWrites();\n      }\n    }, this.handleFilterError.bind(this));\n  }\n\n  halfClose() {\n    this.trace('end() called');\n    this.writesClosed = true;\n    this.maybeCloseWrites();\n  }\n\n}\n\nexports.Http2CallStream = Http2CallStream; //# sourceMappingURL=call-stream.js.map","map":{"version":3,"sources":["/Users/artakoroushnia/Desktop/thred-web/node_modules/@grpc/grpc-js/build/src/call-stream.js"],"names":["Object","defineProperty","exports","value","Http2CallStream","InterceptingListenerImpl","isInterceptingListener","http2","require","os","constants_1","filter_stack_1","metadata_1","stream_decoder_1","logging","constants_2","TRACER_NAME","HTTP2_HEADER_STATUS","HTTP2_HEADER_CONTENT_TYPE","NGHTTP2_CANCEL","constants","getSystemErrorName","errno","name","num","entries","listener","onReceiveMetadata","undefined","length","constructor","nextListener","processingMessage","pendingStatus","metadata","onReceiveMessage","message","msg","onReceiveStatus","status","processedStatus","methodName","channel","options","filterStackFactory","channelCallCredentials","callNumber","http2Stream","pendingRead","isWriteFilterPending","pendingWrite","pendingWriteCallback","writesClosed","decoder","StreamDecoder","isReadFilterPending","canPush","readsClosed","statusOutput","unpushedReadMessages","unfilteredReadMessages","mappedStatusCode","Status","UNKNOWN","finalStatus","subchannel","internalError","filterStack","createFilter","credentials","disconnectListener","endCall","code","UNAVAILABLE","details","Metadata","parentCall","flags","Propagate","CANCELLATION","on","cancelWithStatus","CANCELLED","outputStatus","filteredStatus","receiveTrailers","process","nextTick","_a","callUnref","removeDisconnectListener","trace","text","LogVerbosity","DEBUG","OK","maybeOutputStatus","destroyHttp2Stream","push","Buffer","handleFilterError","error","INTERNAL","handleFilteredRead","pause","nextMessage","shift","filterReceivedMessage","framedMessage","receiveMessage","Promise","resolve","then","bind","tryPush","messageBytes","handleTrailers","headers","headersString","header","keys","fromHttp2Headers","e","metadataMap","getMap","receivedStatus","Number","remove","decodeURI","attachHttp2Stream","stream","extraFilterFactory","FilterStack","close","getAddress","addDisconnectListener","callRef","UNAUTHENTICATED","PERMISSION_DENIED","UNIMPLEMENTED","NGHTTP2_FLAG_END_STREAM","finalMetadata","receiveMetadata","data","messages","write","rstCode","NGHTTP2_NO_ERROR","NGHTTP2_REFUSED_STREAM","NGHTTP2_ENHANCE_YOUR_CALM","RESOURCE_EXHAUSTED","NGHTTP2_INADEQUATE_SECURITY","NGHTTP2_INTERNAL_ERROR","err","syscall","Error","maybeCloseWrites","start","_startCallStream","destroyed","getDeadline","DEADLINE","parentDeadline","selfDeadline","deadline","parentDeadlineMsecs","Date","getTime","selfDeadlineMsecs","Math","min","getCredentials","setCredentials","compose","getStatus","getPeer","_b","getTarget","getMethod","getHost","host","startRead","resume","end","sendMessageWithContext","context","writeObj","cb","callback","sendMessage","halfClose"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,eAAR,GAA0BF,OAAO,CAACG,wBAAR,GAAmCH,OAAO,CAACI,sBAAR,GAAiC,KAAK,CAAnG;;AACA,MAAMC,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMC,EAAE,GAAGD,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAME,WAAW,GAAGF,OAAO,CAAC,aAAD,CAA3B;;AACA,MAAMG,cAAc,GAAGH,OAAO,CAAC,gBAAD,CAA9B;;AACA,MAAMI,UAAU,GAAGJ,OAAO,CAAC,YAAD,CAA1B;;AACA,MAAMK,gBAAgB,GAAGL,OAAO,CAAC,kBAAD,CAAhC;;AACA,MAAMM,OAAO,GAAGN,OAAO,CAAC,WAAD,CAAvB;;AACA,MAAMO,WAAW,GAAGP,OAAO,CAAC,aAAD,CAA3B;;AACA,MAAMQ,WAAW,GAAG,aAApB;AACA,MAAM;AAAEC,EAAAA,mBAAF;AAAuBC,EAAAA,yBAAvB;AAAkDC,EAAAA;AAAlD,IAAsEZ,KAAK,CAACa,SAAlF;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,kBAAT,CAA4BC,KAA5B,EAAmC;AAC/B,OAAK,MAAM,CAACC,IAAD,EAAOC,GAAP,CAAX,IAA0BxB,MAAM,CAACyB,OAAP,CAAehB,EAAE,CAACW,SAAH,CAAaE,KAA5B,CAA1B,EAA8D;AAC1D,QAAIE,GAAG,KAAKF,KAAZ,EAAmB;AACf,aAAOC,IAAP;AACH;AACJ;;AACD,SAAO,0BAA0BD,KAAjC;AACH;;AACD,SAAShB,sBAAT,CAAgCoB,QAAhC,EAA0C;AACtC,SAAQA,QAAQ,CAACC,iBAAT,KAA+BC,SAA/B,IACJF,QAAQ,CAACC,iBAAT,CAA2BE,MAA3B,KAAsC,CAD1C;AAEH;;AACD3B,OAAO,CAACI,sBAAR,GAAiCA,sBAAjC;;AACA,MAAMD,wBAAN,CAA+B;AAC3ByB,EAAAA,WAAW,CAACJ,QAAD,EAAWK,YAAX,EAAyB;AAChC,SAAKL,QAAL,GAAgBA,QAAhB;AACA,SAAKK,YAAL,GAAoBA,YAApB;AACA,SAAKC,iBAAL,GAAyB,KAAzB;AACA,SAAKC,aAAL,GAAqB,IAArB;AACH;;AACDN,EAAAA,iBAAiB,CAACO,QAAD,EAAW;AACxB,SAAKR,QAAL,CAAcC,iBAAd,CAAgCO,QAAhC,EAA2CA,QAAD,IAAc;AACpD,WAAKH,YAAL,CAAkBJ,iBAAlB,CAAoCO,QAApC;AACH,KAFD;AAGH,GAX0B,CAY3B;;;AACAC,EAAAA,gBAAgB,CAACC,OAAD,EAAU;AACtB;AACR;AACQ,SAAKJ,iBAAL,GAAyB,IAAzB;AACA,SAAKN,QAAL,CAAcS,gBAAd,CAA+BC,OAA/B,EAAyCC,GAAD,IAAS;AAC7C,WAAKL,iBAAL,GAAyB,KAAzB;AACA,WAAKD,YAAL,CAAkBI,gBAAlB,CAAmCE,GAAnC;;AACA,UAAI,KAAKJ,aAAT,EAAwB;AACpB,aAAKF,YAAL,CAAkBO,eAAlB,CAAkC,KAAKL,aAAvC;AACH;AACJ,KAND;AAOH;;AACDK,EAAAA,eAAe,CAACC,MAAD,EAAS;AACpB,SAAKb,QAAL,CAAcY,eAAd,CAA8BC,MAA9B,EAAuCC,eAAD,IAAqB;AACvD,UAAI,KAAKR,iBAAT,EAA4B;AACxB,aAAKC,aAAL,GAAqBO,eAArB;AACH,OAFD,MAGK;AACD,aAAKT,YAAL,CAAkBO,eAAlB,CAAkCE,eAAlC;AACH;AACJ,KAPD;AAQH;;AAlC0B;;AAoC/BtC,OAAO,CAACG,wBAAR,GAAmCA,wBAAnC;;AACA,MAAMD,eAAN,CAAsB;AAClB0B,EAAAA,WAAW,CAACW,UAAD,EAAaC,OAAb,EAAsBC,OAAtB,EAA+BC,kBAA/B,EAAmDC,sBAAnD,EAA2EC,UAA3E,EAAuF;AAC9F,SAAKL,UAAL,GAAkBA,UAAlB;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKE,sBAAL,GAA8BA,sBAA9B;AACA,SAAKC,UAAL,GAAkBA,UAAlB;AACA,SAAKC,WAAL,GAAmB,IAAnB;AACA,SAAKC,WAAL,GAAmB,KAAnB;AACA,SAAKC,oBAAL,GAA4B,KAA5B;AACA,SAAKC,YAAL,GAAoB,IAApB;AACA,SAAKC,oBAAL,GAA4B,IAA5B;AACA,SAAKC,YAAL,GAAoB,KAApB;AACA,SAAKC,OAAL,GAAe,IAAIxC,gBAAgB,CAACyC,aAArB,EAAf;AACA,SAAKC,mBAAL,GAA2B,KAA3B;AACA,SAAKC,OAAL,GAAe,KAAf;AACA;AACR;AACA;AACA;;AACQ,SAAKC,WAAL,GAAmB,KAAnB;AACA,SAAKC,YAAL,GAAoB,KAApB;AACA,SAAKC,oBAAL,GAA4B,EAA5B;AACA,SAAKC,sBAAL,GAA8B,EAA9B,CAtB8F,CAuB9F;;AACA,SAAKC,gBAAL,GAAwBnD,WAAW,CAACoD,MAAZ,CAAmBC,OAA3C,CAxB8F,CAyB9F;;AACA,SAAKC,WAAL,GAAmB,IAAnB;AACA,SAAKC,UAAL,GAAkB,IAAlB;AACA,SAAKvC,QAAL,GAAgB,IAAhB;AACA,SAAKwC,aAAL,GAAqB,IAArB;AACA,SAAKC,WAAL,GAAmBvB,kBAAkB,CAACwB,YAAnB,CAAgC,IAAhC,CAAnB;AACA,SAAKC,WAAL,GAAmBxB,sBAAnB;;AACA,SAAKyB,kBAAL,GAA0B,MAAM;AAC5B,WAAKC,OAAL,CAAa;AACTC,QAAAA,IAAI,EAAE9D,WAAW,CAACoD,MAAZ,CAAmBW,WADhB;AAETC,QAAAA,OAAO,EAAE,oBAFA;AAGTxC,QAAAA,QAAQ,EAAE,IAAItB,UAAU,CAAC+D,QAAf;AAHD,OAAb;AAKH,KAND;;AAOA,QAAI,KAAKhC,OAAL,CAAaiC,UAAb,IAA2B,KAAKjC,OAAL,CAAakC,KAAb,GAAqBnE,WAAW,CAACoE,SAAZ,CAAsBC,YAA1E,EAAwF;AACpF,WAAKpC,OAAL,CAAaiC,UAAb,CAAwBI,EAAxB,CAA2B,WAA3B,EAAwC,MAAM;AAC1C,aAAKC,gBAAL,CAAsBvE,WAAW,CAACoD,MAAZ,CAAmBoB,SAAzC,EAAoD,0BAApD;AACH,OAFD;AAGH;AACJ;;AACDC,EAAAA,YAAY,GAAG;AACX;AACA,QAAI,CAAC,KAAKzB,YAAV,EAAwB;AACpB,WAAKA,YAAL,GAAoB,IAApB;AACA,YAAM0B,cAAc,GAAG,KAAKjB,WAAL,CAAiBkB,eAAjB,CAAiC,KAAKrB,WAAtC,CAAvB;AACA;AACZ;AACA;AACA;AACA;AACA;;AACYsB,MAAAA,OAAO,CAACC,QAAR,CAAiB,MAAM;AACnB,YAAIC,EAAJ;;AACA,SAACA,EAAE,GAAG,KAAK9D,QAAX,MAAyB,IAAzB,IAAiC8D,EAAE,KAAK,KAAK,CAA7C,GAAiD,KAAK,CAAtD,GAA0DA,EAAE,CAAClD,eAAH,CAAmB8C,cAAnB,CAA1D;AACH,OAHD;;AAIA,UAAI,KAAKnB,UAAT,EAAqB;AACjB,aAAKA,UAAL,CAAgBwB,SAAhB;AACA,aAAKxB,UAAL,CAAgByB,wBAAhB,CAAyC,KAAKpB,kBAA9C;AACH;AACJ;AACJ;;AACDqB,EAAAA,KAAK,CAACC,IAAD,EAAO;AACR9E,IAAAA,OAAO,CAAC6E,KAAR,CAAc5E,WAAW,CAAC8E,YAAZ,CAAyBC,KAAvC,EAA8C9E,WAA9C,EAA2D,MAAM,KAAK8B,UAAX,GAAwB,IAAxB,GAA+B8C,IAA1F;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIrB,EAAAA,OAAO,CAAChC,MAAD,EAAS;AACZ;AACR;AACQ,QAAI,KAAKyB,WAAL,KAAqB,IAArB,IAA6B,KAAKA,WAAL,CAAiBQ,IAAjB,KAA0B9D,WAAW,CAACoD,MAAZ,CAAmBiC,EAA9E,EAAkF;AAC9E,WAAKJ,KAAL,CAAW,6BACPpD,MAAM,CAACiC,IADA,GAEP,YAFO,GAGPjC,MAAM,CAACmC,OAHA,GAIP,GAJJ;AAKA,WAAKV,WAAL,GAAmBzB,MAAnB;AACA,WAAKyD,iBAAL;AACH;;AACD,SAAKC,kBAAL;AACH;;AACDD,EAAAA,iBAAiB,GAAG;AAChB,QAAI,KAAKhC,WAAL,KAAqB,IAAzB,EAA+B;AAC3B;AACZ;AACA;AACY,UAAI,KAAKA,WAAL,CAAiBQ,IAAjB,KAA0B9D,WAAW,CAACoD,MAAZ,CAAmBiC,EAA7C,IACC,KAAKtC,WAAL,IACG,KAAKE,oBAAL,CAA0B9B,MAA1B,KAAqC,CADxC,IAEG,KAAK+B,sBAAL,CAA4B/B,MAA5B,KAAuC,CAF1C,IAGG,CAAC,KAAK0B,mBAJd,EAIoC;AAChC,aAAK4B,YAAL;AACH;AACJ;AACJ;;AACDe,EAAAA,IAAI,CAAC9D,OAAD,EAAU;AACV,SAAKuD,KAAL,CAAW,0CACNvD,OAAO,YAAY+D,MAAnB,GAA4B/D,OAAO,CAACP,MAApC,GAA6C,IADvC,CAAX;AAEA,SAAK2B,OAAL,GAAe,KAAf;AACA8B,IAAAA,OAAO,CAACC,QAAR,CAAiB,MAAM;AACnB,UAAIC,EAAJ;AACA;AACZ;AACA;AACA;;;AACY,UAAI,KAAK9B,YAAT,EAAuB;AACnB;AACH;;AACD,OAAC8B,EAAE,GAAG,KAAK9D,QAAX,MAAyB,IAAzB,IAAiC8D,EAAE,KAAK,KAAK,CAA7C,GAAiD,KAAK,CAAtD,GAA0DA,EAAE,CAACrD,gBAAH,CAAoBC,OAApB,CAA1D;AACA,WAAK4D,iBAAL;AACH,KAXD;AAYH;;AACDI,EAAAA,iBAAiB,CAACC,KAAD,EAAQ;AACrB,SAAKpB,gBAAL,CAAsBvE,WAAW,CAACoD,MAAZ,CAAmBwC,QAAzC,EAAmDD,KAAK,CAACjE,OAAzD;AACH;;AACDmE,EAAAA,kBAAkB,CAACnE,OAAD,EAAU;AACxB;AACR;AACA;AACQ,QAAI,KAAK4B,WAAL,KAAqB,IAArB,IAA6B,KAAKA,WAAL,CAAiBQ,IAAjB,KAA0B9D,WAAW,CAACoD,MAAZ,CAAmBiC,EAA9E,EAAkF;AAC9E,WAAKC,iBAAL;AACA;AACH;;AACD,SAAKzC,mBAAL,GAA2B,KAA3B;;AACA,QAAI,KAAKC,OAAT,EAAkB;AACd,WAAKT,WAAL,CAAiByD,KAAjB;AACA,WAAKN,IAAL,CAAU9D,OAAV;AACH,KAHD,MAIK;AACD,WAAKuD,KAAL,CAAW,iDAAiDvD,OAAO,CAACP,MAApE;AACA,WAAK8B,oBAAL,CAA0BuC,IAA1B,CAA+B9D,OAA/B;AACH;;AACD,QAAI,KAAKwB,sBAAL,CAA4B/B,MAA5B,GAAqC,CAAzC,EAA4C;AACxC;AACZ;AACY,YAAM4E,WAAW,GAAG,KAAK7C,sBAAL,CAA4B8C,KAA5B,EAApB;AACA,WAAKC,qBAAL,CAA2BF,WAA3B;AACH;AACJ;;AACDE,EAAAA,qBAAqB,CAACC,aAAD,EAAgB;AACjC;AACR;AACA;AACQ,QAAI,KAAK5C,WAAL,KAAqB,IAArB,IAA6B,KAAKA,WAAL,CAAiBQ,IAAjB,KAA0B9D,WAAW,CAACoD,MAAZ,CAAmBiC,EAA9E,EAAkF;AAC9E,WAAKC,iBAAL;AACA;AACH;;AACD,SAAKL,KAAL,CAAW,qCAAqCiB,aAAa,CAAC/E,MAA9D;AACA,SAAK0B,mBAAL,GAA2B,IAA3B;AACA,SAAKY,WAAL,CACK0C,cADL,CACoBC,OAAO,CAACC,OAAR,CAAgBH,aAAhB,CADpB,EAEKI,IAFL,CAEU,KAAKT,kBAAL,CAAwBU,IAAxB,CAA6B,IAA7B,CAFV,EAE8C,KAAKb,iBAAL,CAAuBa,IAAvB,CAA4B,IAA5B,CAF9C;AAGH;;AACDC,EAAAA,OAAO,CAACC,YAAD,EAAe;AAClB,QAAI,KAAK5D,mBAAT,EAA8B;AAC1B,WAAKoC,KAAL,CAAW,oDACNwB,YAAY,IAAIA,YAAY,CAACtF,MADvB,CAAX;AAEA,WAAK+B,sBAAL,CAA4BsC,IAA5B,CAAiCiB,YAAjC;AACH,KAJD,MAKK;AACD,WAAKR,qBAAL,CAA2BQ,YAA3B;AACH;AACJ;;AACDC,EAAAA,cAAc,CAACC,OAAD,EAAU;AACpB,QAAIC,aAAa,GAAG,EAApB;;AACA,SAAK,MAAMC,MAAX,IAAqBvH,MAAM,CAACwH,IAAP,CAAYH,OAAZ,CAArB,EAA2C;AACvCC,MAAAA,aAAa,IAAI,SAASC,MAAT,GAAkB,IAAlB,GAAyBF,OAAO,CAACE,MAAD,CAAhC,GAA2C,IAA5D;AACH;;AACD,SAAK5B,KAAL,CAAW,gCAAgC2B,aAA3C;AACA,QAAIpF,QAAJ;;AACA,QAAI;AACAA,MAAAA,QAAQ,GAAGtB,UAAU,CAAC+D,QAAX,CAAoB8C,gBAApB,CAAqCJ,OAArC,CAAX;AACH,KAFD,CAGA,OAAOK,CAAP,EAAU;AACNxF,MAAAA,QAAQ,GAAG,IAAItB,UAAU,CAAC+D,QAAf,EAAX;AACH;;AACD,UAAMgD,WAAW,GAAGzF,QAAQ,CAAC0F,MAAT,EAApB;AACA,QAAIpD,IAAI,GAAG,KAAKX,gBAAhB;;AACA,QAAIW,IAAI,KAAK9D,WAAW,CAACoD,MAAZ,CAAmBC,OAA5B,IACA,OAAO4D,WAAW,CAAC,aAAD,CAAlB,KAAsC,QAD1C,EACoD;AAChD,YAAME,cAAc,GAAGC,MAAM,CAACH,WAAW,CAAC,aAAD,CAAZ,CAA7B;;AACA,UAAIE,cAAc,IAAInH,WAAW,CAACoD,MAAlC,EAA0C;AACtCU,QAAAA,IAAI,GAAGqD,cAAP;AACA,aAAKlC,KAAL,CAAW,0BAA0BkC,cAA1B,GAA2C,cAAtD;AACH;;AACD3F,MAAAA,QAAQ,CAAC6F,MAAT,CAAgB,aAAhB;AACH;;AACD,QAAIrD,OAAO,GAAG,EAAd;;AACA,QAAI,OAAOiD,WAAW,CAAC,cAAD,CAAlB,KAAuC,QAA3C,EAAqD;AACjDjD,MAAAA,OAAO,GAAGsD,SAAS,CAACL,WAAW,CAAC,cAAD,CAAZ,CAAnB;AACAzF,MAAAA,QAAQ,CAAC6F,MAAT,CAAgB,cAAhB;AACA,WAAKpC,KAAL,CAAW,qCAAqCjB,OAArC,GAA+C,eAA1D;AACH;;AACD,UAAMnC,MAAM,GAAG;AAAEiC,MAAAA,IAAF;AAAQE,MAAAA,OAAR;AAAiBxC,MAAAA;AAAjB,KAAf,CA9BoB,CA+BpB;;AACA,SAAKqC,OAAL,CAAahC,MAAb;AACH;;AACD0F,EAAAA,iBAAiB,CAACC,MAAD,EAASjE,UAAT,EAAqBkE,kBAArB,EAAyC;AACtD,QAAIA,kBAAkB,KAAKvG,SAA3B,EAAsC;AAClC,WAAKuC,WAAL,GAAmB,IAAIxD,cAAc,CAACyH,WAAnB,CAA+B,CAC9C,KAAKjE,WADyC,EAE9CgE,kBAAkB,CAAC/D,YAAnB,CAAgC,IAAhC,CAF8C,CAA/B,CAAnB;AAIH;;AACD,QAAI,KAAKJ,WAAL,KAAqB,IAAzB,EAA+B;AAC3BkE,MAAAA,MAAM,CAACG,KAAP,CAAalH,cAAb;AACH,KAFD,MAGK;AACD,WAAKwE,KAAL,CAAW,uCAAuC1B,UAAU,CAACqE,UAAX,EAAlD;AACA,WAAKvF,WAAL,GAAmBmF,MAAnB;AACA,WAAKjE,UAAL,GAAkBA,UAAlB;AACAA,MAAAA,UAAU,CAACsE,qBAAX,CAAiC,KAAKjE,kBAAtC;AACAL,MAAAA,UAAU,CAACuE,OAAX;AACAN,MAAAA,MAAM,CAAClD,EAAP,CAAU,UAAV,EAAsB,CAACqC,OAAD,EAAUxC,KAAV,KAAoB;AACtC,YAAIW,EAAJ;;AACA,YAAI8B,aAAa,GAAG,EAApB;;AACA,aAAK,MAAMC,MAAX,IAAqBvH,MAAM,CAACwH,IAAP,CAAYH,OAAZ,CAArB,EAA2C;AACvCC,UAAAA,aAAa,IAAI,SAASC,MAAT,GAAkB,IAAlB,GAAyBF,OAAO,CAACE,MAAD,CAAhC,GAA2C,IAA5D;AACH;;AACD,aAAK5B,KAAL,CAAW,+BAA+B2B,aAA1C;;AACA,gBAAQD,OAAO,CAAC,SAAD,CAAf;AACI;AACA,eAAK,GAAL;AACI,iBAAKxD,gBAAL,GAAwBnD,WAAW,CAACoD,MAAZ,CAAmBwC,QAA3C;AACA;;AACJ,eAAK,GAAL;AACI,iBAAKzC,gBAAL,GAAwBnD,WAAW,CAACoD,MAAZ,CAAmB2E,eAA3C;AACA;;AACJ,eAAK,GAAL;AACI,iBAAK5E,gBAAL,GAAwBnD,WAAW,CAACoD,MAAZ,CAAmB4E,iBAA3C;AACA;;AACJ,eAAK,GAAL;AACI,iBAAK7E,gBAAL,GAAwBnD,WAAW,CAACoD,MAAZ,CAAmB6E,aAA3C;AACA;;AACJ,eAAK,GAAL;AACA,eAAK,GAAL;AACA,eAAK,GAAL;AACA,eAAK,GAAL;AACI,iBAAK9E,gBAAL,GAAwBnD,WAAW,CAACoD,MAAZ,CAAmBW,WAA3C;AACA;;AACJ;AACI,iBAAKZ,gBAAL,GAAwBnD,WAAW,CAACoD,MAAZ,CAAmBC,OAA3C;AArBR;;AAuBA,YAAIc,KAAK,GAAGtE,KAAK,CAACa,SAAN,CAAgBwH,uBAA5B,EAAqD;AACjD,eAAKxB,cAAL,CAAoBC,OAApB;AACH,SAFD,MAGK;AACD,cAAInF,QAAJ;;AACA,cAAI;AACAA,YAAAA,QAAQ,GAAGtB,UAAU,CAAC+D,QAAX,CAAoB8C,gBAApB,CAAqCJ,OAArC,CAAX;AACH,WAFD,CAGA,OAAOhB,KAAP,EAAc;AACV,iBAAK9B,OAAL,CAAa;AACTC,cAAAA,IAAI,EAAE9D,WAAW,CAACoD,MAAZ,CAAmBC,OADhB;AAETW,cAAAA,OAAO,EAAE2B,KAAK,CAACjE,OAFN;AAGTF,cAAAA,QAAQ,EAAE,IAAItB,UAAU,CAAC+D,QAAf;AAHD,aAAb;AAKA;AACH;;AACD,cAAI;AACA,kBAAMkE,aAAa,GAAG,KAAK1E,WAAL,CAAiB2E,eAAjB,CAAiC5G,QAAjC,CAAtB;AACA,aAACsD,EAAE,GAAG,KAAK9D,QAAX,MAAyB,IAAzB,IAAiC8D,EAAE,KAAK,KAAK,CAA7C,GAAiD,KAAK,CAAtD,GAA0DA,EAAE,CAAC7D,iBAAH,CAAqBkH,aAArB,CAA1D;AACH,WAHD,CAIA,OAAOxC,KAAP,EAAc;AACV,iBAAK9B,OAAL,CAAa;AACTC,cAAAA,IAAI,EAAE9D,WAAW,CAACoD,MAAZ,CAAmBC,OADhB;AAETW,cAAAA,OAAO,EAAE2B,KAAK,CAACjE,OAFN;AAGTF,cAAAA,QAAQ,EAAE,IAAItB,UAAU,CAAC+D,QAAf;AAHD,aAAb;AAKH;AACJ;AACJ,OA1DD;AA2DAuD,MAAAA,MAAM,CAAClD,EAAP,CAAU,UAAV,EAAsB,KAAKoC,cAAL,CAAoBH,IAApB,CAAyB,IAAzB,CAAtB;AACAiB,MAAAA,MAAM,CAAClD,EAAP,CAAU,MAAV,EAAmB+D,IAAD,IAAU;AACxB,aAAKpD,KAAL,CAAW,yCAAyCoD,IAAI,CAAClH,MAAzD;AACA,cAAMmH,QAAQ,GAAG,KAAK3F,OAAL,CAAa4F,KAAb,CAAmBF,IAAnB,CAAjB;;AACA,aAAK,MAAM3G,OAAX,IAAsB4G,QAAtB,EAAgC;AAC5B,eAAKrD,KAAL,CAAW,8BAA8BvD,OAAO,CAACP,MAAjD;AACA,eAAKqF,OAAL,CAAa9E,OAAb;AACH;AACJ,OAPD;AAQA8F,MAAAA,MAAM,CAAClD,EAAP,CAAU,KAAV,EAAiB,MAAM;AACnB,aAAKvB,WAAL,GAAmB,IAAnB;AACA,aAAKuC,iBAAL;AACH,OAHD;AAIAkC,MAAAA,MAAM,CAAClD,EAAP,CAAU,OAAV,EAAmB,MAAM;AACrB;AAChB;AACA;AACgBM,QAAAA,OAAO,CAACC,QAAR,CAAiB,MAAM;AACnB,cAAIC,EAAJ;;AACA,eAAKG,KAAL,CAAW,oCAAoCuC,MAAM,CAACgB,OAAtD;AACA;AACpB;AACA;AACA;;AACoB,cAAI,CAAC,CAAC1D,EAAE,GAAG,KAAKxB,WAAX,MAA4B,IAA5B,IAAoCwB,EAAE,KAAK,KAAK,CAAhD,GAAoD,KAAK,CAAzD,GAA6DA,EAAE,CAAChB,IAAjE,MAA2E9D,WAAW,CAACoD,MAAZ,CAAmBiC,EAAlG,EAAsG;AAClG;AACH;;AACD,cAAIvB,IAAJ;AACA,cAAIE,OAAO,GAAG,EAAd;;AACA,kBAAQwD,MAAM,CAACgB,OAAf;AACI,iBAAK3I,KAAK,CAACa,SAAN,CAAgB+H,gBAArB;AACI;AAC5B;AACA;AAC4B,kBAAI,KAAKnF,WAAL,KAAqB,IAAzB,EAA+B;AAC3B;AACH;;AACDQ,cAAAA,IAAI,GAAG9D,WAAW,CAACoD,MAAZ,CAAmBwC,QAA1B;AACA5B,cAAAA,OAAO,GAAI,iCAAgCwD,MAAM,CAACgB,OAAQ,EAA1D;AACA;;AACJ,iBAAK3I,KAAK,CAACa,SAAN,CAAgBgI,sBAArB;AACI5E,cAAAA,IAAI,GAAG9D,WAAW,CAACoD,MAAZ,CAAmBW,WAA1B;AACAC,cAAAA,OAAO,GAAG,0BAAV;AACA;;AACJ,iBAAKnE,KAAK,CAACa,SAAN,CAAgBD,cAArB;AACIqD,cAAAA,IAAI,GAAG9D,WAAW,CAACoD,MAAZ,CAAmBoB,SAA1B;AACAR,cAAAA,OAAO,GAAG,gBAAV;AACA;;AACJ,iBAAKnE,KAAK,CAACa,SAAN,CAAgBiI,yBAArB;AACI7E,cAAAA,IAAI,GAAG9D,WAAW,CAACoD,MAAZ,CAAmBwF,kBAA1B;AACA5E,cAAAA,OAAO,GAAG,qBAAV;AACA;;AACJ,iBAAKnE,KAAK,CAACa,SAAN,CAAgBmI,2BAArB;AACI/E,cAAAA,IAAI,GAAG9D,WAAW,CAACoD,MAAZ,CAAmB4E,iBAA1B;AACAhE,cAAAA,OAAO,GAAG,4BAAV;AACA;;AACJ,iBAAKnE,KAAK,CAACa,SAAN,CAAgBoI,sBAArB;AACIhF,cAAAA,IAAI,GAAG9D,WAAW,CAACoD,MAAZ,CAAmBwC,QAA1B;;AACA,kBAAI,KAAKpC,aAAL,KAAuB,IAA3B,EAAiC;AAC7B;AAChC;AACA;AACA;AACA;AACgCQ,gBAAAA,OAAO,GAAI,iCAAgCwD,MAAM,CAACgB,OAAQ,0BAA1D;AACH,eAPD,MAQK;AACD,oBAAI,KAAKhF,aAAL,CAAmBM,IAAnB,KAA4B,YAAhC,EAA8C;AAC1CA,kBAAAA,IAAI,GAAG9D,WAAW,CAACoD,MAAZ,CAAmBW,WAA1B;AACAC,kBAAAA,OAAO,GAAG,KAAKR,aAAL,CAAmB9B,OAA7B;AACH,iBAHD,MAIK;AACD;AACpC;AACA;AACA;AACoCsC,kBAAAA,OAAO,GAAI,iCAAgCwD,MAAM,CAACgB,OAAQ,wCAAuC,KAAKhF,aAAL,CAAmB9B,OAAQ,EAA5H;AACH;AACJ;;AACD;;AACJ;AACIoC,cAAAA,IAAI,GAAG9D,WAAW,CAACoD,MAAZ,CAAmBwC,QAA1B;AACA5B,cAAAA,OAAO,GAAI,iCAAgCwD,MAAM,CAACgB,OAAQ,EAA1D;AArDR,WAZmB,CAmEnB;AACA;AACA;AACA;;;AACA,eAAK3E,OAAL,CAAa;AAAEC,YAAAA,IAAF;AAAQE,YAAAA,OAAR;AAAiBxC,YAAAA,QAAQ,EAAE,IAAItB,UAAU,CAAC+D,QAAf;AAA3B,WAAb;AACH,SAxED;AAyEH,OA7ED;AA8EAuD,MAAAA,MAAM,CAAClD,EAAP,CAAU,OAAV,EAAoByE,GAAD,IAAS;AACxB;AAChB;AACA;;AACgB;AAChB;AACA;AACA;AACgB,YAAIA,GAAG,CAACjF,IAAJ,KAAa,wBAAjB,EAA2C;AACvC,eAAKmB,KAAL,CAAW,+BAA+B8D,GAAG,CAACrH,OAAnC,GAA6C,QAA7C,GAAwDqH,GAAG,CAACjF,IAA5D,GAAmE,SAAnE,GAA+EnD,kBAAkB,CAACoI,GAAG,CAACnI,KAAL,CAAjG,GAA+G,WAA/G,GAA6HmI,GAAG,CAACC,OAA5I;AACA,eAAKxF,aAAL,GAAqBuF,GAArB;AACH;AACJ,OAZD;;AAaA,UAAI,CAAC,KAAKzG,WAAV,EAAuB;AACnBkF,QAAAA,MAAM,CAAC1B,KAAP;AACH;;AACD,UAAI,KAAKtD,YAAT,EAAuB;AACnB,YAAI,CAAC,KAAKC,oBAAV,EAAgC;AAC5B,gBAAM,IAAIwG,KAAJ,CAAU,sCAAV,CAAN;AACH;;AACD,aAAKhE,KAAL,CAAW,kCACP,KAAKzC,YAAL,CAAkBrB,MADX,GAEP,aAFJ;AAGAqG,QAAAA,MAAM,CAACe,KAAP,CAAa,KAAK/F,YAAlB,EAAgC,KAAKC,oBAArC;AACH;;AACD,WAAKyG,gBAAL;AACH;AACJ;;AACDC,EAAAA,KAAK,CAAC3H,QAAD,EAAWR,QAAX,EAAqB;AACtB,SAAKiE,KAAL,CAAW,kBAAX;AACA,SAAKjE,QAAL,GAAgBA,QAAhB;;AACA,SAAKgB,OAAL,CAAaoH,gBAAb,CAA8B,IAA9B,EAAoC5H,QAApC;AACH;;AACD+D,EAAAA,kBAAkB,GAAG;AACjB,QAAIT,EAAJ,CADiB,CAEjB;AACA;;;AACA,QAAI,KAAKzC,WAAL,KAAqB,IAArB,IAA6B,CAAC,KAAKA,WAAL,CAAiBgH,SAAnD,EAA8D;AAC1D;AACZ;AACA;AACY,UAAIvF,IAAJ;;AACA,UAAI,CAAC,CAACgB,EAAE,GAAG,KAAKxB,WAAX,MAA4B,IAA5B,IAAoCwB,EAAE,KAAK,KAAK,CAAhD,GAAoD,KAAK,CAAzD,GAA6DA,EAAE,CAAChB,IAAjE,MAA2E9D,WAAW,CAACoD,MAAZ,CAAmBiC,EAAlG,EAAsG;AAClGvB,QAAAA,IAAI,GAAGjE,KAAK,CAACa,SAAN,CAAgB+H,gBAAvB;AACH,OAFD,MAGK;AACD3E,QAAAA,IAAI,GAAGjE,KAAK,CAACa,SAAN,CAAgBD,cAAvB;AACH;;AACD,WAAKwE,KAAL,CAAW,kCAAkCnB,IAA7C;AACA,WAAKzB,WAAL,CAAiBsF,KAAjB,CAAuB7D,IAAvB;AACH;AACJ;;AACDS,EAAAA,gBAAgB,CAAC1C,MAAD,EAASmC,OAAT,EAAkB;AAC9B,SAAKiB,KAAL,CAAW,4BAA4BpD,MAA5B,GAAqC,aAArC,GAAqDmC,OAArD,GAA+D,GAA1E;AACA,SAAKH,OAAL,CAAa;AAAEC,MAAAA,IAAI,EAAEjC,MAAR;AAAgBmC,MAAAA,OAAhB;AAAyBxC,MAAAA,QAAQ,EAAE,IAAItB,UAAU,CAAC+D,QAAf;AAAnC,KAAb;AACH;;AACDqF,EAAAA,WAAW,GAAG;AACV,QAAI,KAAKrH,OAAL,CAAaiC,UAAb,IAA2B,KAAKjC,OAAL,CAAakC,KAAb,GAAqBnE,WAAW,CAACoE,SAAZ,CAAsBmF,QAA1E,EAAoF;AAChF,YAAMC,cAAc,GAAG,KAAKvH,OAAL,CAAaiC,UAAb,CAAwBoF,WAAxB,EAAvB;AACA,YAAMG,YAAY,GAAG,KAAKxH,OAAL,CAAayH,QAAlC;AACA,YAAMC,mBAAmB,GAAGH,cAAc,YAAYI,IAA1B,GAAiCJ,cAAc,CAACK,OAAf,EAAjC,GAA4DL,cAAxF;AACA,YAAMM,iBAAiB,GAAGL,YAAY,YAAYG,IAAxB,GAA+BH,YAAY,CAACI,OAAb,EAA/B,GAAwDJ,YAAlF;AACA,aAAOM,IAAI,CAACC,GAAL,CAASL,mBAAT,EAA8BG,iBAA9B,CAAP;AACH,KAND,MAOK;AACD,aAAO,KAAK7H,OAAL,CAAayH,QAApB;AACH;AACJ;;AACDO,EAAAA,cAAc,GAAG;AACb,WAAO,KAAKtG,WAAZ;AACH;;AACDuG,EAAAA,cAAc,CAACvG,WAAD,EAAc;AACxB,SAAKA,WAAL,GAAmB,KAAKxB,sBAAL,CAA4BgI,OAA5B,CAAoCxG,WAApC,CAAnB;AACH;;AACDyG,EAAAA,SAAS,GAAG;AACR,WAAO,KAAK9G,WAAZ;AACH;;AACD+G,EAAAA,OAAO,GAAG;AACN,QAAIvF,EAAJ,EAAQwF,EAAR;;AACA,WAAO,CAACA,EAAE,GAAG,CAACxF,EAAE,GAAG,KAAKvB,UAAX,MAA2B,IAA3B,IAAmCuB,EAAE,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,EAAE,CAAC8C,UAAH,EAAlE,MAAuF,IAAvF,IAA+F0C,EAAE,KAAK,KAAK,CAA3G,GAA+GA,EAA/G,GAAoH,KAAKtI,OAAL,CAAauI,SAAb,EAA3H;AACH;;AACDC,EAAAA,SAAS,GAAG;AACR,WAAO,KAAKzI,UAAZ;AACH;;AACD0I,EAAAA,OAAO,GAAG;AACN,WAAO,KAAKxI,OAAL,CAAayI,IAApB;AACH;;AACDC,EAAAA,SAAS,GAAG;AACR;AACR;AACQ,QAAI,KAAKrH,WAAL,KAAqB,IAArB,IAA6B,KAAKA,WAAL,CAAiBQ,IAAjB,KAA0B9D,WAAW,CAACoD,MAAZ,CAAmBiC,EAA9E,EAAkF;AAC9E,WAAKtC,WAAL,GAAmB,IAAnB;AACA,WAAKuC,iBAAL;AACA;AACH;;AACD,SAAKxC,OAAL,GAAe,IAAf;;AACA,QAAI,KAAKT,WAAL,KAAqB,IAAzB,EAA+B;AAC3B,WAAKC,WAAL,GAAmB,IAAnB;AACH,KAFD,MAGK;AACD,UAAI,KAAKW,oBAAL,CAA0B9B,MAA1B,GAAmC,CAAvC,EAA0C;AACtC,cAAM4E,WAAW,GAAG,KAAK9C,oBAAL,CAA0B+C,KAA1B,EAApB;AACA,aAAKR,IAAL,CAAUO,WAAV;AACA;AACH;AACD;AACZ;;;AACY,WAAK1D,WAAL,CAAiBuI,MAAjB;AACH;AACJ;;AACD1B,EAAAA,gBAAgB,GAAG;AACf,QAAI,KAAKxG,YAAL,IACA,CAAC,KAAKH,oBADN,IAEA,KAAKF,WAAL,KAAqB,IAFzB,EAE+B;AAC3B,WAAK4C,KAAL,CAAW,gCAAX;AACA,WAAK5C,WAAL,CAAiBwI,GAAjB;AACH;AACJ;;AACDC,EAAAA,sBAAsB,CAACC,OAAD,EAAUrJ,OAAV,EAAmB;AACrC,QAAIoD,EAAJ;;AACA,SAAKG,KAAL,CAAW,2CAA2CvD,OAAO,CAACP,MAA9D;AACA,UAAM6J,QAAQ,GAAG;AACbtJ,MAAAA,OADa;AAEbyC,MAAAA,KAAK,EAAE4G,OAAO,CAAC5G;AAFF,KAAjB;AAIA,UAAM8G,EAAE,GAAG,CAACnG,EAAE,GAAGiG,OAAO,CAACG,QAAd,MAA4B,IAA5B,IAAoCpG,EAAE,KAAK,KAAK,CAAhD,GAAoDA,EAApD,GAA0D,MAAM,CAAG,CAA9E;AACA,SAAKvC,oBAAL,GAA4B,IAA5B;AACA,SAAKkB,WAAL,CAAiB0H,WAAjB,CAA6B/E,OAAO,CAACC,OAAR,CAAgB2E,QAAhB,CAA7B,EAAwD1E,IAAxD,CAA8D5E,OAAD,IAAa;AACtE,WAAKa,oBAAL,GAA4B,KAA5B;;AACA,UAAI,KAAKF,WAAL,KAAqB,IAAzB,EAA+B;AAC3B,aAAK4C,KAAL,CAAW,4CAA4CvD,OAAO,CAACA,OAAR,CAAgBP,MAAvE;AACA,aAAKqB,YAAL,GAAoBd,OAAO,CAACA,OAA5B;AACA,aAAKe,oBAAL,GAA4BwI,EAA5B;AACH,OAJD,MAKK;AACD,aAAKhG,KAAL,CAAW,kCAAkCvD,OAAO,CAACA,OAAR,CAAgBP,MAA7D;AACA,aAAKkB,WAAL,CAAiBkG,KAAjB,CAAuB7G,OAAO,CAACA,OAA/B,EAAwCuJ,EAAxC;AACA,aAAK/B,gBAAL;AACH;AACJ,KAZD,EAYG,KAAKxD,iBAAL,CAAuBa,IAAvB,CAA4B,IAA5B,CAZH;AAaH;;AACD6E,EAAAA,SAAS,GAAG;AACR,SAAKnG,KAAL,CAAW,cAAX;AACA,SAAKvC,YAAL,GAAoB,IAApB;AACA,SAAKwG,gBAAL;AACH;;AApgBiB;;AAsgBtB1J,OAAO,CAACE,eAAR,GAA0BA,eAA1B,C,CACA","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Http2CallStream = exports.InterceptingListenerImpl = exports.isInterceptingListener = void 0;\nconst http2 = require(\"http2\");\nconst os = require(\"os\");\nconst constants_1 = require(\"./constants\");\nconst filter_stack_1 = require(\"./filter-stack\");\nconst metadata_1 = require(\"./metadata\");\nconst stream_decoder_1 = require(\"./stream-decoder\");\nconst logging = require(\"./logging\");\nconst constants_2 = require(\"./constants\");\nconst TRACER_NAME = 'call_stream';\nconst { HTTP2_HEADER_STATUS, HTTP2_HEADER_CONTENT_TYPE, NGHTTP2_CANCEL, } = http2.constants;\n/**\n * Should do approximately the same thing as util.getSystemErrorName but the\n * TypeScript types don't have that function for some reason so I just made my\n * own.\n * @param errno\n */\nfunction getSystemErrorName(errno) {\n    for (const [name, num] of Object.entries(os.constants.errno)) {\n        if (num === errno) {\n            return name;\n        }\n    }\n    return 'Unknown system error ' + errno;\n}\nfunction isInterceptingListener(listener) {\n    return (listener.onReceiveMetadata !== undefined &&\n        listener.onReceiveMetadata.length === 1);\n}\nexports.isInterceptingListener = isInterceptingListener;\nclass InterceptingListenerImpl {\n    constructor(listener, nextListener) {\n        this.listener = listener;\n        this.nextListener = nextListener;\n        this.processingMessage = false;\n        this.pendingStatus = null;\n    }\n    onReceiveMetadata(metadata) {\n        this.listener.onReceiveMetadata(metadata, (metadata) => {\n            this.nextListener.onReceiveMetadata(metadata);\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onReceiveMessage(message) {\n        /* If this listener processes messages asynchronously, the last message may\n         * be reordered with respect to the status */\n        this.processingMessage = true;\n        this.listener.onReceiveMessage(message, (msg) => {\n            this.processingMessage = false;\n            this.nextListener.onReceiveMessage(msg);\n            if (this.pendingStatus) {\n                this.nextListener.onReceiveStatus(this.pendingStatus);\n            }\n        });\n    }\n    onReceiveStatus(status) {\n        this.listener.onReceiveStatus(status, (processedStatus) => {\n            if (this.processingMessage) {\n                this.pendingStatus = processedStatus;\n            }\n            else {\n                this.nextListener.onReceiveStatus(processedStatus);\n            }\n        });\n    }\n}\nexports.InterceptingListenerImpl = InterceptingListenerImpl;\nclass Http2CallStream {\n    constructor(methodName, channel, options, filterStackFactory, channelCallCredentials, callNumber) {\n        this.methodName = methodName;\n        this.channel = channel;\n        this.options = options;\n        this.channelCallCredentials = channelCallCredentials;\n        this.callNumber = callNumber;\n        this.http2Stream = null;\n        this.pendingRead = false;\n        this.isWriteFilterPending = false;\n        this.pendingWrite = null;\n        this.pendingWriteCallback = null;\n        this.writesClosed = false;\n        this.decoder = new stream_decoder_1.StreamDecoder();\n        this.isReadFilterPending = false;\n        this.canPush = false;\n        /**\n         * Indicates that an 'end' event has come from the http2 stream, so there\n         * will be no more data events.\n         */\n        this.readsClosed = false;\n        this.statusOutput = false;\n        this.unpushedReadMessages = [];\n        this.unfilteredReadMessages = [];\n        // Status code mapped from :status. To be used if grpc-status is not received\n        this.mappedStatusCode = constants_1.Status.UNKNOWN;\n        // This is populated (non-null) if and only if the call has ended\n        this.finalStatus = null;\n        this.subchannel = null;\n        this.listener = null;\n        this.internalError = null;\n        this.filterStack = filterStackFactory.createFilter(this);\n        this.credentials = channelCallCredentials;\n        this.disconnectListener = () => {\n            this.endCall({\n                code: constants_1.Status.UNAVAILABLE,\n                details: 'Connection dropped',\n                metadata: new metadata_1.Metadata(),\n            });\n        };\n        if (this.options.parentCall && this.options.flags & constants_1.Propagate.CANCELLATION) {\n            this.options.parentCall.on('cancelled', () => {\n                this.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled by parent call');\n            });\n        }\n    }\n    outputStatus() {\n        /* Precondition: this.finalStatus !== null */\n        if (!this.statusOutput) {\n            this.statusOutput = true;\n            const filteredStatus = this.filterStack.receiveTrailers(this.finalStatus);\n            /* We delay the actual action of bubbling up the status to insulate the\n             * cleanup code in this class from any errors that may be thrown in the\n             * upper layers as a result of bubbling up the status. In particular,\n             * if the status is not OK, the \"error\" event may be emitted\n             * synchronously at the top level, which will result in a thrown error if\n             * the user does not handle that event. */\n            process.nextTick(() => {\n                var _a;\n                (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(filteredStatus);\n            });\n            if (this.subchannel) {\n                this.subchannel.callUnref();\n                this.subchannel.removeDisconnectListener(this.disconnectListener);\n            }\n        }\n    }\n    trace(text) {\n        logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\n    }\n    /**\n     * On first call, emits a 'status' event with the given StatusObject.\n     * Subsequent calls are no-ops.\n     * @param status The status of the call.\n     */\n    endCall(status) {\n        /* If the status is OK and a new status comes in (e.g. from a\n         * deserialization failure), that new status takes priority */\n        if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {\n            this.trace('ended with status: code=' +\n                status.code +\n                ' details=\"' +\n                status.details +\n                '\"');\n            this.finalStatus = status;\n            this.maybeOutputStatus();\n        }\n        this.destroyHttp2Stream();\n    }\n    maybeOutputStatus() {\n        if (this.finalStatus !== null) {\n            /* The combination check of readsClosed and that the two message buffer\n             * arrays are empty checks that there all incoming data has been fully\n             * processed */\n            if (this.finalStatus.code !== constants_1.Status.OK ||\n                (this.readsClosed &&\n                    this.unpushedReadMessages.length === 0 &&\n                    this.unfilteredReadMessages.length === 0 &&\n                    !this.isReadFilterPending)) {\n                this.outputStatus();\n            }\n        }\n    }\n    push(message) {\n        this.trace('pushing to reader message of length ' +\n            (message instanceof Buffer ? message.length : null));\n        this.canPush = false;\n        process.nextTick(() => {\n            var _a;\n            /* If we have already output the status any later messages should be\n             * ignored, and can cause out-of-order operation errors higher up in the\n             * stack. Checking as late as possible here to avoid any race conditions.\n             */\n            if (this.statusOutput) {\n                return;\n            }\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveMessage(message);\n            this.maybeOutputStatus();\n        });\n    }\n    handleFilterError(error) {\n        this.cancelWithStatus(constants_1.Status.INTERNAL, error.message);\n    }\n    handleFilteredRead(message) {\n        /* If we the call has already ended with an error, we don't want to do\n         * anything with this message. Dropping it on the floor is correct\n         * behavior */\n        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n            this.maybeOutputStatus();\n            return;\n        }\n        this.isReadFilterPending = false;\n        if (this.canPush) {\n            this.http2Stream.pause();\n            this.push(message);\n        }\n        else {\n            this.trace('unpushedReadMessages.push message of length ' + message.length);\n            this.unpushedReadMessages.push(message);\n        }\n        if (this.unfilteredReadMessages.length > 0) {\n            /* nextMessage is guaranteed not to be undefined because\n               unfilteredReadMessages is non-empty */\n            const nextMessage = this.unfilteredReadMessages.shift();\n            this.filterReceivedMessage(nextMessage);\n        }\n    }\n    filterReceivedMessage(framedMessage) {\n        /* If we the call has already ended with an error, we don't want to do\n         * anything with this message. Dropping it on the floor is correct\n         * behavior */\n        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n            this.maybeOutputStatus();\n            return;\n        }\n        this.trace('filterReceivedMessage of length ' + framedMessage.length);\n        this.isReadFilterPending = true;\n        this.filterStack\n            .receiveMessage(Promise.resolve(framedMessage))\n            .then(this.handleFilteredRead.bind(this), this.handleFilterError.bind(this));\n    }\n    tryPush(messageBytes) {\n        if (this.isReadFilterPending) {\n            this.trace('unfilteredReadMessages.push message of length ' +\n                (messageBytes && messageBytes.length));\n            this.unfilteredReadMessages.push(messageBytes);\n        }\n        else {\n            this.filterReceivedMessage(messageBytes);\n        }\n    }\n    handleTrailers(headers) {\n        let headersString = '';\n        for (const header of Object.keys(headers)) {\n            headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n        }\n        this.trace('Received server trailers:\\n' + headersString);\n        let metadata;\n        try {\n            metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        }\n        catch (e) {\n            metadata = new metadata_1.Metadata();\n        }\n        const metadataMap = metadata.getMap();\n        let code = this.mappedStatusCode;\n        if (code === constants_1.Status.UNKNOWN &&\n            typeof metadataMap['grpc-status'] === 'string') {\n            const receivedStatus = Number(metadataMap['grpc-status']);\n            if (receivedStatus in constants_1.Status) {\n                code = receivedStatus;\n                this.trace('received status code ' + receivedStatus + ' from server');\n            }\n            metadata.remove('grpc-status');\n        }\n        let details = '';\n        if (typeof metadataMap['grpc-message'] === 'string') {\n            details = decodeURI(metadataMap['grpc-message']);\n            metadata.remove('grpc-message');\n            this.trace('received status details string \"' + details + '\" from server');\n        }\n        const status = { code, details, metadata };\n        // This is a no-op if the call was already ended when handling headers.\n        this.endCall(status);\n    }\n    attachHttp2Stream(stream, subchannel, extraFilterFactory) {\n        if (extraFilterFactory !== undefined) {\n            this.filterStack = new filter_stack_1.FilterStack([\n                this.filterStack,\n                extraFilterFactory.createFilter(this),\n            ]);\n        }\n        if (this.finalStatus !== null) {\n            stream.close(NGHTTP2_CANCEL);\n        }\n        else {\n            this.trace('attachHttp2Stream from subchannel ' + subchannel.getAddress());\n            this.http2Stream = stream;\n            this.subchannel = subchannel;\n            subchannel.addDisconnectListener(this.disconnectListener);\n            subchannel.callRef();\n            stream.on('response', (headers, flags) => {\n                var _a;\n                let headersString = '';\n                for (const header of Object.keys(headers)) {\n                    headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n                }\n                this.trace('Received server headers:\\n' + headersString);\n                switch (headers[':status']) {\n                    // TODO(murgatroid99): handle 100 and 101\n                    case 400:\n                        this.mappedStatusCode = constants_1.Status.INTERNAL;\n                        break;\n                    case 401:\n                        this.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;\n                        break;\n                    case 403:\n                        this.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;\n                        break;\n                    case 404:\n                        this.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;\n                        break;\n                    case 429:\n                    case 502:\n                    case 503:\n                    case 504:\n                        this.mappedStatusCode = constants_1.Status.UNAVAILABLE;\n                        break;\n                    default:\n                        this.mappedStatusCode = constants_1.Status.UNKNOWN;\n                }\n                if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n                    this.handleTrailers(headers);\n                }\n                else {\n                    let metadata;\n                    try {\n                        metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n                    }\n                    catch (error) {\n                        this.endCall({\n                            code: constants_1.Status.UNKNOWN,\n                            details: error.message,\n                            metadata: new metadata_1.Metadata(),\n                        });\n                        return;\n                    }\n                    try {\n                        const finalMetadata = this.filterStack.receiveMetadata(metadata);\n                        (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveMetadata(finalMetadata);\n                    }\n                    catch (error) {\n                        this.endCall({\n                            code: constants_1.Status.UNKNOWN,\n                            details: error.message,\n                            metadata: new metadata_1.Metadata(),\n                        });\n                    }\n                }\n            });\n            stream.on('trailers', this.handleTrailers.bind(this));\n            stream.on('data', (data) => {\n                this.trace('receive HTTP/2 data frame of length ' + data.length);\n                const messages = this.decoder.write(data);\n                for (const message of messages) {\n                    this.trace('parsed message of length ' + message.length);\n                    this.tryPush(message);\n                }\n            });\n            stream.on('end', () => {\n                this.readsClosed = true;\n                this.maybeOutputStatus();\n            });\n            stream.on('close', () => {\n                /* Use process.next tick to ensure that this code happens after any\n                 * \"error\" event that may be emitted at about the same time, so that\n                 * we can bubble up the error message from that event. */\n                process.nextTick(() => {\n                    var _a;\n                    this.trace('HTTP/2 stream closed with code ' + stream.rstCode);\n                    /* If we have a final status with an OK status code, that means that\n                     * we have received all of the messages and we have processed the\n                     * trailers and the call completed successfully, so it doesn't matter\n                     * how the stream ends after that */\n                    if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n                        return;\n                    }\n                    let code;\n                    let details = '';\n                    switch (stream.rstCode) {\n                        case http2.constants.NGHTTP2_NO_ERROR:\n                            /* If we get a NO_ERROR code and we already have a status, the\n                             * stream completed properly and we just haven't fully processed\n                             * it yet */\n                            if (this.finalStatus !== null) {\n                                return;\n                            }\n                            code = constants_1.Status.INTERNAL;\n                            details = `Received RST_STREAM with code ${stream.rstCode}`;\n                            break;\n                        case http2.constants.NGHTTP2_REFUSED_STREAM:\n                            code = constants_1.Status.UNAVAILABLE;\n                            details = 'Stream refused by server';\n                            break;\n                        case http2.constants.NGHTTP2_CANCEL:\n                            code = constants_1.Status.CANCELLED;\n                            details = 'Call cancelled';\n                            break;\n                        case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n                            code = constants_1.Status.RESOURCE_EXHAUSTED;\n                            details = 'Bandwidth exhausted';\n                            break;\n                        case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n                            code = constants_1.Status.PERMISSION_DENIED;\n                            details = 'Protocol not secure enough';\n                            break;\n                        case http2.constants.NGHTTP2_INTERNAL_ERROR:\n                            code = constants_1.Status.INTERNAL;\n                            if (this.internalError === null) {\n                                /* This error code was previously handled in the default case, and\n                                 * there are several instances of it online, so I wanted to\n                                 * preserve the original error message so that people find existing\n                                 * information in searches, but also include the more recognizable\n                                 * \"Internal server error\" message. */\n                                details = `Received RST_STREAM with code ${stream.rstCode} (Internal server error)`;\n                            }\n                            else {\n                                if (this.internalError.code === 'ECONNRESET') {\n                                    code = constants_1.Status.UNAVAILABLE;\n                                    details = this.internalError.message;\n                                }\n                                else {\n                                    /* The \"Received RST_STREAM with code ...\" error is preserved\n                                     * here for continuity with errors reported online, but the\n                                     * error message at the end will probably be more relevant in\n                                     * most cases. */\n                                    details = `Received RST_STREAM with code ${stream.rstCode} triggered by internal client error: ${this.internalError.message}`;\n                                }\n                            }\n                            break;\n                        default:\n                            code = constants_1.Status.INTERNAL;\n                            details = `Received RST_STREAM with code ${stream.rstCode}`;\n                    }\n                    // This is a no-op if trailers were received at all.\n                    // This is OK, because status codes emitted here correspond to more\n                    // catastrophic issues that prevent us from receiving trailers in the\n                    // first place.\n                    this.endCall({ code, details, metadata: new metadata_1.Metadata() });\n                });\n            });\n            stream.on('error', (err) => {\n                /* We need an error handler here to stop \"Uncaught Error\" exceptions\n                 * from bubbling up. However, errors here should all correspond to\n                 * \"close\" events, where we will handle the error more granularly */\n                /* Specifically looking for stream errors that were *not* constructed\n                 * from a RST_STREAM response here:\n                 * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267\n                 */\n                if (err.code !== 'ERR_HTTP2_STREAM_ERROR') {\n                    this.trace('Node error event: message=' + err.message + ' code=' + err.code + ' errno=' + getSystemErrorName(err.errno) + ' syscall=' + err.syscall);\n                    this.internalError = err;\n                }\n            });\n            if (!this.pendingRead) {\n                stream.pause();\n            }\n            if (this.pendingWrite) {\n                if (!this.pendingWriteCallback) {\n                    throw new Error('Invalid state in write handling code');\n                }\n                this.trace('sending data chunk of length ' +\n                    this.pendingWrite.length +\n                    ' (deferred)');\n                stream.write(this.pendingWrite, this.pendingWriteCallback);\n            }\n            this.maybeCloseWrites();\n        }\n    }\n    start(metadata, listener) {\n        this.trace('Sending metadata');\n        this.listener = listener;\n        this.channel._startCallStream(this, metadata);\n    }\n    destroyHttp2Stream() {\n        var _a;\n        // The http2 stream could already have been destroyed if cancelWithStatus\n        // is called in response to an internal http2 error.\n        if (this.http2Stream !== null && !this.http2Stream.destroyed) {\n            /* If the call has ended with an OK status, communicate that when closing\n             * the stream, partly to avoid a situation in which we detect an error\n             * RST_STREAM as a result after we have the status */\n            let code;\n            if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n                code = http2.constants.NGHTTP2_NO_ERROR;\n            }\n            else {\n                code = http2.constants.NGHTTP2_CANCEL;\n            }\n            this.trace('close http2 stream with code ' + code);\n            this.http2Stream.close(code);\n        }\n    }\n    cancelWithStatus(status, details) {\n        this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n        this.endCall({ code: status, details, metadata: new metadata_1.Metadata() });\n    }\n    getDeadline() {\n        if (this.options.parentCall && this.options.flags & constants_1.Propagate.DEADLINE) {\n            const parentDeadline = this.options.parentCall.getDeadline();\n            const selfDeadline = this.options.deadline;\n            const parentDeadlineMsecs = parentDeadline instanceof Date ? parentDeadline.getTime() : parentDeadline;\n            const selfDeadlineMsecs = selfDeadline instanceof Date ? selfDeadline.getTime() : selfDeadline;\n            return Math.min(parentDeadlineMsecs, selfDeadlineMsecs);\n        }\n        else {\n            return this.options.deadline;\n        }\n    }\n    getCredentials() {\n        return this.credentials;\n    }\n    setCredentials(credentials) {\n        this.credentials = this.channelCallCredentials.compose(credentials);\n    }\n    getStatus() {\n        return this.finalStatus;\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.subchannel) === null || _a === void 0 ? void 0 : _a.getAddress()) !== null && _b !== void 0 ? _b : this.channel.getTarget();\n    }\n    getMethod() {\n        return this.methodName;\n    }\n    getHost() {\n        return this.options.host;\n    }\n    startRead() {\n        /* If the stream has ended with an error, we should not emit any more\n         * messages and we should communicate that the stream has ended */\n        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n            this.readsClosed = true;\n            this.maybeOutputStatus();\n            return;\n        }\n        this.canPush = true;\n        if (this.http2Stream === null) {\n            this.pendingRead = true;\n        }\n        else {\n            if (this.unpushedReadMessages.length > 0) {\n                const nextMessage = this.unpushedReadMessages.shift();\n                this.push(nextMessage);\n                return;\n            }\n            /* Only resume reading from the http2Stream if we don't have any pending\n             * messages to emit */\n            this.http2Stream.resume();\n        }\n    }\n    maybeCloseWrites() {\n        if (this.writesClosed &&\n            !this.isWriteFilterPending &&\n            this.http2Stream !== null) {\n            this.trace('calling end() on HTTP/2 stream');\n            this.http2Stream.end();\n        }\n    }\n    sendMessageWithContext(context, message) {\n        var _a;\n        this.trace('write() called with message of length ' + message.length);\n        const writeObj = {\n            message,\n            flags: context.flags,\n        };\n        const cb = (_a = context.callback) !== null && _a !== void 0 ? _a : (() => { });\n        this.isWriteFilterPending = true;\n        this.filterStack.sendMessage(Promise.resolve(writeObj)).then((message) => {\n            this.isWriteFilterPending = false;\n            if (this.http2Stream === null) {\n                this.trace('deferring writing data chunk of length ' + message.message.length);\n                this.pendingWrite = message.message;\n                this.pendingWriteCallback = cb;\n            }\n            else {\n                this.trace('sending data chunk of length ' + message.message.length);\n                this.http2Stream.write(message.message, cb);\n                this.maybeCloseWrites();\n            }\n        }, this.handleFilterError.bind(this));\n    }\n    halfClose() {\n        this.trace('end() called');\n        this.writesClosed = true;\n        this.maybeCloseWrites();\n    }\n}\nexports.Http2CallStream = Http2CallStream;\n//# sourceMappingURL=call-stream.js.map"]},"metadata":{},"sourceType":"script"}