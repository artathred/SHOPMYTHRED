{"ast":null,"code":"/*\n * Copyright 2016 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\nmodule.exports = function proxyPolyfill() {\n  let lastRevokeFn = null;\n  let ProxyPolyfill;\n  /**\n   * @param {*} o\n   * @return {boolean} whether this is probably a (non-null) Object\n   */\n\n  function isObject(o) {\n    return o ? typeof o === 'object' || typeof o === 'function' : false;\n  }\n\n  function validateProto(proto) {\n    if (proto !== null && !isObject(proto)) {\n      throw new TypeError('Object prototype may only be an Object or null: ' + proto);\n    }\n  }\n\n  const $Object = Object; // Closure assumes that `{__proto__: null} instanceof Object` is always true, hence why we check against a different name.\n\n  const canCreateNullProtoObjects = Boolean($Object.create) || !({\n    __proto__: null\n  } instanceof $Object);\n  const objectCreate = $Object.create || (canCreateNullProtoObjects ? function create(proto) {\n    validateProto(proto);\n    return {\n      __proto__: proto\n    };\n  } : function create(proto) {\n    validateProto(proto);\n\n    if (proto === null) {\n      throw new SyntaxError('Native Object.create is required to create objects with null prototype');\n    } // nb. cast to convince Closure compiler that this is a constructor\n\n\n    var T =\n    /** @type {!Function} */\n    function T() {};\n\n    T.prototype = proto;\n    return new T();\n  });\n\n  const noop = function () {\n    return null;\n  };\n\n  const getProto = $Object.getPrototypeOf || ([].__proto__ === Array.prototype ? function getPrototypeOf(O) {\n    // If O.[[Prototype]] === null, then the __proto__ accessor won't exist,\n    // as it's inherited from `Object.prototype`\n    const proto = O.__proto__;\n    return isObject(proto) ? proto : null;\n  } : noop);\n  /**\n   * @constructor\n   * @param {!Object} target\n   * @param {{apply, construct, get, set}} handler\n   */\n\n  ProxyPolyfill = function (target, handler) {\n    const newTarget = this && this instanceof ProxyPolyfill ? this.constructor : undefined;\n\n    if (newTarget === undefined) {\n      throw new TypeError(\"Constructor Proxy requires 'new'\");\n    }\n\n    if (!isObject(target) || !isObject(handler)) {\n      throw new TypeError('Cannot create proxy with a non-object as target or handler');\n    } // Construct revoke function, and set lastRevokeFn so that Proxy.revocable can steal it.\n    // The caller might get the wrong revoke function if a user replaces or wraps scope.Proxy\n    // to call itself, but that seems unlikely especially when using the polyfill.\n\n\n    let throwRevoked = function () {};\n\n    lastRevokeFn = function () {\n      /** @suppress {checkTypes} */\n      target = null; // clear ref\n\n      throwRevoked = function (trap) {\n        throw new TypeError(`Cannot perform '${trap}' on a proxy that has been revoked`);\n      };\n    };\n\n    setTimeout(function () {\n      lastRevokeFn = null;\n    }, 0); // Fail on unsupported traps: Chrome doesn't do this, but ensure that users of the polyfill\n    // are a bit more careful. Copy the internal parts of handler to prevent user changes.\n\n    const unsafeHandler = handler;\n    handler = {\n      'get': null,\n      'set': null,\n      'apply': null,\n      'construct': null\n    };\n\n    for (let k in unsafeHandler) {\n      if (!(k in handler)) {\n        throw new TypeError(`Proxy polyfill does not support trap '${k}'`);\n      }\n\n      handler[k] = unsafeHandler[k];\n    }\n\n    if (typeof unsafeHandler === 'function') {\n      // Allow handler to be a function (which has an 'apply' method). This matches what is\n      // probably a bug in native versions. It treats the apply call as a trap to be configured.\n      handler.apply = unsafeHandler.apply.bind(unsafeHandler);\n    } // Define proxy as an object that extends target.[[Prototype]],\n    // or a Function (if either it's callable, or apply is set).\n\n\n    const proto = getProto(target); // can return null in old browsers\n\n    let proxy;\n    let isMethod = false;\n    let isArray = false;\n\n    if (typeof target === 'function') {\n      proxy = function ProxyPolyfill() {\n        const usingNew = this && this.constructor === proxy;\n        const args = Array.prototype.slice.call(arguments);\n        throwRevoked(usingNew ? 'construct' : 'apply'); // TODO(samthor): Closure compiler doesn't know about 'construct', attempts to rename it.\n\n        if (usingNew && handler['construct']) {\n          return handler['construct'].call(this, target, args);\n        } else if (!usingNew && handler.apply) {\n          return handler['apply'](target, this, args);\n        } // since the target was a function, fallback to calling it directly.\n\n\n        if (usingNew) {\n          // inspired by answers to https://stackoverflow.com/q/1606797\n          args.unshift(target); // pass class as first arg to constructor, although irrelevant\n          // nb. cast to convince Closure compiler that this is a constructor\n\n          const f =\n          /** @type {!Function} */\n          target.bind.apply(target, args);\n          return new f();\n        }\n\n        return target.apply(this, args);\n      };\n\n      isMethod = true;\n    } else if (target instanceof Array) {\n      proxy = [];\n      isArray = true;\n    } else {\n      proxy = canCreateNullProtoObjects || proto !== null ? objectCreate(proto) : {};\n    } // Create default getters/setters. Create different code paths as handler.get/handler.set can't\n    // change after creation.\n\n\n    const getter = handler.get ? function (prop) {\n      throwRevoked('get');\n      return handler.get(this, prop, proxy);\n    } : function (prop) {\n      throwRevoked('get');\n      return this[prop];\n    };\n    const setter = handler.set ? function (prop, value) {\n      throwRevoked('set');\n      const status = handler.set(this, prop, value, proxy); // TODO(samthor): If the calling code is in strict mode, throw TypeError.\n      // if (!status) {\n      // It's (sometimes) possible to work this out, if this code isn't strict- try to load the\n      // callee, and if it's available, that code is non-strict. However, this isn't exhaustive.\n      // }\n    } : function (prop, value) {\n      throwRevoked('set');\n      this[prop] = value;\n    }; // Clone direct properties (i.e., not part of a prototype).\n\n    const propertyNames = $Object.getOwnPropertyNames(target);\n    const propertyMap = {};\n    propertyNames.forEach(function (prop) {\n      if ((isMethod || isArray) && prop in proxy) {\n        return; // ignore properties already here, e.g. 'bind', 'prototype' etc\n      }\n\n      const real = $Object.getOwnPropertyDescriptor(target, prop);\n      const desc = {\n        enumerable: Boolean(real.enumerable),\n        get: getter.bind(target, prop),\n        set: setter.bind(target, prop)\n      };\n      $Object.defineProperty(proxy, prop, desc);\n      propertyMap[prop] = true;\n    }); // Set the prototype, or clone all prototype methods (always required if a getter is provided).\n    // TODO(samthor): We don't allow prototype methods to be set. It's (even more) awkward.\n    // An alternative here would be to _just_ clone methods to keep behavior consistent.\n\n    let prototypeOk = true;\n\n    if (isMethod || isArray) {\n      // Arrays and methods are special: above, we instantiate boring versions of these then swap\n      // our their prototype later. So we only need to use setPrototypeOf in these cases. Some old\n      // engines support `Object.getPrototypeOf` but not `Object.setPrototypeOf`.\n      const setProto = $Object.setPrototypeOf || ([].__proto__ === Array.prototype ? function setPrototypeOf(O, proto) {\n        validateProto(proto);\n        O.__proto__ = proto;\n        return O;\n      } : noop);\n\n      if (!(proto && setProto(proxy, proto))) {\n        prototypeOk = false;\n      }\n    }\n\n    if (handler.get || !prototypeOk) {\n      for (let k in target) {\n        if (propertyMap[k]) {\n          continue;\n        }\n\n        $Object.defineProperty(proxy, k, {\n          get: getter.bind(target, k)\n        });\n      }\n    } // The Proxy polyfill cannot handle adding new properties. Seal the target and proxy.\n\n\n    $Object.seal(target);\n    $Object.seal(proxy);\n    return proxy; // nb. if isMethod is true, proxy != this\n  };\n\n  ProxyPolyfill.revocable = function (target, handler) {\n    const p = new ProxyPolyfill(target, handler);\n    return {\n      'proxy': p,\n      'revoke': lastRevokeFn\n    };\n  };\n\n  return ProxyPolyfill;\n};","map":null,"metadata":{},"sourceType":"script"}