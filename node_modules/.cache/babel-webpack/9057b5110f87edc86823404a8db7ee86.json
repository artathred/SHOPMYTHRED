{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChannelImplementation = exports.ConnectivityState = void 0;\n\nconst call_stream_1 = require(\"./call-stream\");\n\nconst channel_credentials_1 = require(\"./channel-credentials\");\n\nconst resolving_load_balancer_1 = require(\"./resolving-load-balancer\");\n\nconst subchannel_pool_1 = require(\"./subchannel-pool\");\n\nconst picker_1 = require(\"./picker\");\n\nconst constants_1 = require(\"./constants\");\n\nconst filter_stack_1 = require(\"./filter-stack\");\n\nconst call_credentials_filter_1 = require(\"./call-credentials-filter\");\n\nconst deadline_filter_1 = require(\"./deadline-filter\");\n\nconst compression_filter_1 = require(\"./compression-filter\");\n\nconst resolver_1 = require(\"./resolver\");\n\nconst logging_1 = require(\"./logging\");\n\nconst max_message_size_filter_1 = require(\"./max-message-size-filter\");\n\nconst http_proxy_1 = require(\"./http_proxy\");\n\nconst uri_parser_1 = require(\"./uri-parser\");\n\nvar ConnectivityState;\n\n(function (ConnectivityState) {\n  ConnectivityState[ConnectivityState[\"IDLE\"] = 0] = \"IDLE\";\n  ConnectivityState[ConnectivityState[\"CONNECTING\"] = 1] = \"CONNECTING\";\n  ConnectivityState[ConnectivityState[\"READY\"] = 2] = \"READY\";\n  ConnectivityState[ConnectivityState[\"TRANSIENT_FAILURE\"] = 3] = \"TRANSIENT_FAILURE\";\n  ConnectivityState[ConnectivityState[\"SHUTDOWN\"] = 4] = \"SHUTDOWN\";\n})(ConnectivityState = exports.ConnectivityState || (exports.ConnectivityState = {}));\n/**\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\n */\n\n\nconst MAX_TIMEOUT_TIME = 2147483647;\nlet nextCallNumber = 0;\n\nfunction getNewCallNumber() {\n  const callNumber = nextCallNumber;\n  nextCallNumber += 1;\n\n  if (nextCallNumber >= Number.MAX_SAFE_INTEGER) {\n    nextCallNumber = 0;\n  }\n\n  return callNumber;\n}\n\nclass ChannelImplementation {\n  constructor(target, credentials, options) {\n    var _a, _b, _c;\n\n    this.credentials = credentials;\n    this.options = options;\n    this.connectivityState = ConnectivityState.IDLE;\n    this.currentPicker = new picker_1.UnavailablePicker();\n    /**\n     * Calls queued up to get a call config. Should only be populated before the\n     * first time the resolver returns a result, which includes the ConfigSelector.\n     */\n\n    this.configSelectionQueue = [];\n    this.pickQueue = [];\n    this.connectivityStateWatchers = [];\n    this.configSelector = null;\n\n    if (typeof target !== 'string') {\n      throw new TypeError('Channel target must be a string');\n    }\n\n    if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n      throw new TypeError('Channel credentials must be a ChannelCredentials object');\n    }\n\n    if (options) {\n      if (typeof options !== 'object' || !Object.values(options).every(value => typeof value === 'string' || typeof value === 'number' || typeof value === 'undefined')) {\n        throw new TypeError('Channel options must be an object with string or number values');\n      }\n    }\n\n    const originalTargetUri = uri_parser_1.parseUri(target);\n\n    if (originalTargetUri === null) {\n      throw new Error(`Could not parse target name \"${target}\"`);\n    }\n    /* This ensures that the target has a scheme that is registered with the\n     * resolver */\n\n\n    const defaultSchemeMapResult = resolver_1.mapUriDefaultScheme(originalTargetUri);\n\n    if (defaultSchemeMapResult === null) {\n      throw new Error(`Could not find a default scheme for target name \"${target}\"`);\n    }\n\n    this.callRefTimer = setInterval(() => {}, MAX_TIMEOUT_TIME);\n    (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n\n    if (this.options['grpc.default_authority']) {\n      this.defaultAuthority = this.options['grpc.default_authority'];\n    } else {\n      this.defaultAuthority = resolver_1.getDefaultAuthority(defaultSchemeMapResult);\n    }\n\n    const proxyMapResult = http_proxy_1.mapProxyName(defaultSchemeMapResult, options);\n    this.target = proxyMapResult.target;\n    this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n    /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n     * the grpc.use_local_subchannel_pool channel option means. */\n\n    this.subchannelPool = subchannel_pool_1.getSubchannelPool(((_c = options['grpc.use_local_subchannel_pool']) !== null && _c !== void 0 ? _c : 0) === 0);\n    const channelControlHelper = {\n      createSubchannel: (subchannelAddress, subchannelArgs) => {\n        return this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);\n      },\n      updateState: (connectivityState, picker) => {\n        this.currentPicker = picker;\n        const queueCopy = this.pickQueue.slice();\n        this.pickQueue = [];\n        this.callRefTimerUnref();\n\n        for (const {\n          callStream,\n          callMetadata,\n          callConfig\n        } of queueCopy) {\n          this.tryPick(callStream, callMetadata, callConfig);\n        }\n\n        this.updateState(connectivityState);\n      },\n      requestReresolution: () => {\n        // This should never be called.\n        throw new Error('Resolving load balancer should never call requestReresolution');\n      }\n    };\n    this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options, configSelector => {\n      this.configSelector = configSelector;\n      /* We process the queue asynchronously to ensure that the corresponding\n       * load balancer update has completed. */\n\n      process.nextTick(() => {\n        const localQueue = this.configSelectionQueue;\n        this.configSelectionQueue = [];\n        this.callRefTimerUnref();\n\n        for (const {\n          callStream,\n          callMetadata\n        } of localQueue) {\n          this.tryGetConfig(callStream, callMetadata);\n        }\n\n        this.configSelectionQueue = [];\n      });\n    }, status => {\n      if (this.configSelectionQueue.length > 0) {\n        logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', 'Name resolution failed for target ' + uri_parser_1.uriToString(this.target) + ' with calls queued for config selection');\n      }\n\n      const localQueue = this.configSelectionQueue;\n      this.configSelectionQueue = [];\n      this.callRefTimerUnref();\n\n      for (const {\n        callStream,\n        callMetadata\n      } of localQueue) {\n        if (callMetadata.getOptions().waitForReady) {\n          this.callRefTimerRef();\n          this.configSelectionQueue.push({\n            callStream,\n            callMetadata\n          });\n        } else {\n          callStream.cancelWithStatus(status.code, status.details);\n        }\n      }\n    });\n    this.filterStackFactory = new filter_stack_1.FilterStackFactory([new call_credentials_filter_1.CallCredentialsFilterFactory(this), new deadline_filter_1.DeadlineFilterFactory(this), new max_message_size_filter_1.MaxMessageSizeFilterFactory(this.options), new compression_filter_1.CompressionFilterFactory(this)]);\n  }\n\n  callRefTimerRef() {\n    var _a, _b, _c, _d; // If the hasRef function does not exist, always run the code\n\n\n    if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n      logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', 'callRefTimer.ref | configSelectionQueue.length=' + this.configSelectionQueue.length + ' pickQueue.length=' + this.pickQueue.length);\n      (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);\n    }\n  }\n\n  callRefTimerUnref() {\n    var _a, _b; // If the hasRef function does not exist, always run the code\n\n\n    if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {\n      logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', 'callRefTimer.unref | configSelectionQueue.length=' + this.configSelectionQueue.length + ' pickQueue.length=' + this.pickQueue.length);\n      (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n  }\n\n  pushPick(callStream, callMetadata, callConfig) {\n    this.pickQueue.push({\n      callStream,\n      callMetadata,\n      callConfig\n    });\n    this.callRefTimerRef();\n  }\n  /**\n   * Check the picker output for the given call and corresponding metadata,\n   * and take any relevant actions. Should not be called while iterating\n   * over pickQueue.\n   * @param callStream\n   * @param callMetadata\n   */\n\n\n  tryPick(callStream, callMetadata, callConfig) {\n    var _a, _b, _c;\n\n    const pickResult = this.currentPicker.pick({\n      metadata: callMetadata,\n      extraPickInfo: callConfig.pickInformation\n    });\n    logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', 'Pick result: ' + picker_1.PickResultType[pickResult.pickResultType] + ' subchannel: ' + ((_a = pickResult.subchannel) === null || _a === void 0 ? void 0 : _a.getAddress()) + ' status: ' + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.code) + ' ' + ((_c = pickResult.status) === null || _c === void 0 ? void 0 : _c.details));\n\n    switch (pickResult.pickResultType) {\n      case picker_1.PickResultType.COMPLETE:\n        if (pickResult.subchannel === null) {\n          callStream.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Request dropped by load balancing policy'); // End the call with an error\n        } else {\n          /* If the subchannel is not in the READY state, that indicates a bug\n           * somewhere in the load balancer or picker. So, we log an error and\n           * queue the pick to be tried again later. */\n          if (pickResult.subchannel.getConnectivityState() !== ConnectivityState.READY) {\n            logging_1.log(constants_1.LogVerbosity.ERROR, 'Error: COMPLETE pick result subchannel ' + pickResult.subchannel.getAddress() + ' has state ' + ConnectivityState[pickResult.subchannel.getConnectivityState()]);\n            this.pushPick(callStream, callMetadata, callConfig);\n            break;\n          }\n          /* We need to clone the callMetadata here because the transparent\n           * retry code in the promise resolution handler use the same\n           * callMetadata object, so it needs to stay unmodified */\n\n\n          callStream.filterStack.sendMetadata(Promise.resolve(callMetadata.clone())).then(finalMetadata => {\n            var _a, _b, _c;\n\n            const subchannelState = pickResult.subchannel.getConnectivityState();\n\n            if (subchannelState === ConnectivityState.READY) {\n              try {\n                pickResult.subchannel.startCallStream(finalMetadata, callStream, (_a = pickResult.extraFilterFactory) !== null && _a !== void 0 ? _a : undefined);\n                /* If we reach this point, the call stream has started\n                 * successfully */\n\n                (_b = callConfig.onCommitted) === null || _b === void 0 ? void 0 : _b.call(callConfig);\n                (_c = pickResult.onCallStarted) === null || _c === void 0 ? void 0 : _c.call(pickResult);\n              } catch (error) {\n                if (error.code === 'ERR_HTTP2_GOAWAY_SESSION') {\n                  /* An error here indicates that something went wrong with\n                   * the picked subchannel's http2 stream right before we\n                   * tried to start the stream. We are handling a promise\n                   * result here, so this is asynchronous with respect to the\n                   * original tryPick call, so calling it again is not\n                   * recursive. We call tryPick immediately instead of\n                   * queueing this pick again because handling the queue is\n                   * triggered by state changes, and we want to immediately\n                   * check if the state has already changed since the\n                   * previous tryPick call. We do this instead of cancelling\n                   * the stream because the correct behavior may be\n                   * re-queueing instead, based on the logic in the rest of\n                   * tryPick */\n                  logging_1.trace(constants_1.LogVerbosity.INFO, 'channel', 'Failed to start call on picked subchannel ' + pickResult.subchannel.getAddress() + ' with error ' + error.message + '. Retrying pick');\n                  this.tryPick(callStream, callMetadata, callConfig);\n                } else {\n                  logging_1.trace(constants_1.LogVerbosity.INFO, 'channel', 'Failed to start call on picked subchanel ' + pickResult.subchannel.getAddress() + ' with error ' + error.message + '. Ending call');\n                  callStream.cancelWithStatus(constants_1.Status.INTERNAL, `Failed to start HTTP/2 stream with error: ${error.message}`);\n                }\n              }\n            } else {\n              /* The logic for doing this here is the same as in the catch\n               * block above */\n              logging_1.trace(constants_1.LogVerbosity.INFO, 'channel', 'Picked subchannel ' + pickResult.subchannel.getAddress() + ' has state ' + ConnectivityState[subchannelState] + ' after metadata filters. Retrying pick');\n              this.tryPick(callStream, callMetadata, callConfig);\n            }\n          }, error => {\n            // We assume the error code isn't 0 (Status.OK)\n            callStream.cancelWithStatus(typeof error.code === 'number' ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\n          });\n        }\n\n        break;\n\n      case picker_1.PickResultType.QUEUE:\n        this.pushPick(callStream, callMetadata, callConfig);\n        break;\n\n      case picker_1.PickResultType.TRANSIENT_FAILURE:\n        if (callMetadata.getOptions().waitForReady) {\n          this.pushPick(callStream, callMetadata, callConfig);\n        } else {\n          callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);\n        }\n\n        break;\n\n      case picker_1.PickResultType.DROP:\n        callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);\n        break;\n\n      default:\n        throw new Error(`Invalid state: unknown pickResultType ${pickResult.pickResultType}`);\n    }\n  }\n\n  removeConnectivityStateWatcher(watcherObject) {\n    const watcherIndex = this.connectivityStateWatchers.findIndex(value => value === watcherObject);\n\n    if (watcherIndex >= 0) {\n      this.connectivityStateWatchers.splice(watcherIndex, 1);\n    }\n  }\n\n  updateState(newState) {\n    logging_1.trace(constants_1.LogVerbosity.DEBUG, 'connectivity_state', uri_parser_1.uriToString(this.target) + ' ' + ConnectivityState[this.connectivityState] + ' -> ' + ConnectivityState[newState]);\n    this.connectivityState = newState;\n    const watchersCopy = this.connectivityStateWatchers.slice();\n\n    for (const watcherObject of watchersCopy) {\n      if (newState !== watcherObject.currentState) {\n        if (watcherObject.timer) {\n          clearTimeout(watcherObject.timer);\n        }\n\n        this.removeConnectivityStateWatcher(watcherObject);\n        watcherObject.callback();\n      }\n    }\n  }\n\n  tryGetConfig(stream, metadata) {\n    if (this.configSelector === null) {\n      /* This branch will only be taken at the beginning of the channel's life,\n       * before the resolver ever returns a result. So, the\n       * ResolvingLoadBalancer may be idle and if so it needs to be kicked\n       * because it now has a pending request. */\n      this.resolvingLoadBalancer.exitIdle();\n      this.configSelectionQueue.push({\n        callStream: stream,\n        callMetadata: metadata\n      });\n      this.callRefTimerRef();\n    } else {\n      const callConfig = this.configSelector(stream.getMethod(), metadata);\n\n      if (callConfig.status === constants_1.Status.OK) {\n        this.tryPick(stream, metadata, callConfig);\n      } else {\n        stream.cancelWithStatus(callConfig.status, \"Failed to route call to method \" + stream.getMethod());\n      }\n    }\n  }\n\n  _startCallStream(stream, metadata) {\n    this.tryGetConfig(stream, metadata.clone());\n  }\n\n  close() {\n    this.resolvingLoadBalancer.destroy();\n    this.updateState(ConnectivityState.SHUTDOWN);\n    clearInterval(this.callRefTimer);\n    this.subchannelPool.unrefUnusedSubchannels();\n  }\n\n  getTarget() {\n    return uri_parser_1.uriToString(this.target);\n  }\n\n  getConnectivityState(tryToConnect) {\n    const connectivityState = this.connectivityState;\n\n    if (tryToConnect) {\n      this.resolvingLoadBalancer.exitIdle();\n    }\n\n    return connectivityState;\n  }\n\n  watchConnectivityState(currentState, deadline, callback) {\n    if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n\n    let timer = null;\n\n    if (deadline !== Infinity) {\n      const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);\n      const now = new Date();\n\n      if (deadline === -Infinity || deadlineDate <= now) {\n        process.nextTick(callback, new Error('Deadline passed without connectivity state change'));\n        return;\n      }\n\n      timer = setTimeout(() => {\n        this.removeConnectivityStateWatcher(watcherObject);\n        callback(new Error('Deadline passed without connectivity state change'));\n      }, deadlineDate.getTime() - now.getTime());\n    }\n\n    const watcherObject = {\n      currentState,\n      callback,\n      timer\n    };\n    this.connectivityStateWatchers.push(watcherObject);\n  }\n\n  createCall(method, deadline, host, parentCall, propagateFlags) {\n    if (typeof method !== 'string') {\n      throw new TypeError('Channel#createCall: method must be a string');\n    }\n\n    if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n      throw new TypeError('Channel#createCall: deadline must be a number or Date');\n    }\n\n    if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n\n    const callNumber = getNewCallNumber();\n    logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', uri_parser_1.uriToString(this.target) + ' createCall [' + callNumber + '] method=\"' + method + '\", deadline=' + deadline);\n    const finalOptions = {\n      deadline: deadline,\n      flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,\n      host: host !== null && host !== void 0 ? host : this.defaultAuthority,\n      parentCall: parentCall\n    };\n    const stream = new call_stream_1.Http2CallStream(method, this, finalOptions, this.filterStackFactory, this.credentials._getCallCredentials(), callNumber);\n    return stream;\n  }\n\n}\n\nexports.ChannelImplementation = ChannelImplementation; //# sourceMappingURL=channel.js.map","map":{"version":3,"sources":["/Users/artakoroushnia/Desktop/thred-web/node_modules/@grpc/grpc-js/build/src/channel.js"],"names":["Object","defineProperty","exports","value","ChannelImplementation","ConnectivityState","call_stream_1","require","channel_credentials_1","resolving_load_balancer_1","subchannel_pool_1","picker_1","constants_1","filter_stack_1","call_credentials_filter_1","deadline_filter_1","compression_filter_1","resolver_1","logging_1","max_message_size_filter_1","http_proxy_1","uri_parser_1","MAX_TIMEOUT_TIME","nextCallNumber","getNewCallNumber","callNumber","Number","MAX_SAFE_INTEGER","constructor","target","credentials","options","_a","_b","_c","connectivityState","IDLE","currentPicker","UnavailablePicker","configSelectionQueue","pickQueue","connectivityStateWatchers","configSelector","TypeError","ChannelCredentials","values","every","originalTargetUri","parseUri","Error","defaultSchemeMapResult","mapUriDefaultScheme","callRefTimer","setInterval","unref","call","defaultAuthority","getDefaultAuthority","proxyMapResult","mapProxyName","assign","extraOptions","subchannelPool","getSubchannelPool","channelControlHelper","createSubchannel","subchannelAddress","subchannelArgs","getOrCreateSubchannel","updateState","picker","queueCopy","slice","callRefTimerUnref","callStream","callMetadata","callConfig","tryPick","requestReresolution","resolvingLoadBalancer","ResolvingLoadBalancer","process","nextTick","localQueue","tryGetConfig","status","length","trace","LogVerbosity","DEBUG","uriToString","getOptions","waitForReady","callRefTimerRef","push","cancelWithStatus","code","details","filterStackFactory","FilterStackFactory","CallCredentialsFilterFactory","DeadlineFilterFactory","MaxMessageSizeFilterFactory","CompressionFilterFactory","_d","hasRef","ref","pushPick","pickResult","pick","metadata","extraPickInfo","pickInformation","PickResultType","pickResultType","subchannel","getAddress","COMPLETE","Status","UNAVAILABLE","getConnectivityState","READY","log","ERROR","filterStack","sendMetadata","Promise","resolve","clone","then","finalMetadata","subchannelState","startCallStream","extraFilterFactory","undefined","onCommitted","onCallStarted","error","INFO","message","INTERNAL","UNKNOWN","QUEUE","TRANSIENT_FAILURE","DROP","removeConnectivityStateWatcher","watcherObject","watcherIndex","findIndex","splice","newState","watchersCopy","currentState","timer","clearTimeout","callback","stream","exitIdle","getMethod","OK","_startCallStream","close","destroy","SHUTDOWN","clearInterval","unrefUnusedSubchannels","getTarget","tryToConnect","watchConnectivityState","deadline","Infinity","deadlineDate","Date","now","setTimeout","getTime","createCall","method","host","parentCall","propagateFlags","finalOptions","flags","Propagate","DEFAULTS","Http2CallStream","_getCallCredentials"],"mappings":"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","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ChannelImplementation = exports.ConnectivityState = void 0;\nconst call_stream_1 = require(\"./call-stream\");\nconst channel_credentials_1 = require(\"./channel-credentials\");\nconst resolving_load_balancer_1 = require(\"./resolving-load-balancer\");\nconst subchannel_pool_1 = require(\"./subchannel-pool\");\nconst picker_1 = require(\"./picker\");\nconst constants_1 = require(\"./constants\");\nconst filter_stack_1 = require(\"./filter-stack\");\nconst call_credentials_filter_1 = require(\"./call-credentials-filter\");\nconst deadline_filter_1 = require(\"./deadline-filter\");\nconst compression_filter_1 = require(\"./compression-filter\");\nconst resolver_1 = require(\"./resolver\");\nconst logging_1 = require(\"./logging\");\nconst max_message_size_filter_1 = require(\"./max-message-size-filter\");\nconst http_proxy_1 = require(\"./http_proxy\");\nconst uri_parser_1 = require(\"./uri-parser\");\nvar ConnectivityState;\n(function (ConnectivityState) {\n    ConnectivityState[ConnectivityState[\"IDLE\"] = 0] = \"IDLE\";\n    ConnectivityState[ConnectivityState[\"CONNECTING\"] = 1] = \"CONNECTING\";\n    ConnectivityState[ConnectivityState[\"READY\"] = 2] = \"READY\";\n    ConnectivityState[ConnectivityState[\"TRANSIENT_FAILURE\"] = 3] = \"TRANSIENT_FAILURE\";\n    ConnectivityState[ConnectivityState[\"SHUTDOWN\"] = 4] = \"SHUTDOWN\";\n})(ConnectivityState = exports.ConnectivityState || (exports.ConnectivityState = {}));\n/**\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\n */\nconst MAX_TIMEOUT_TIME = 2147483647;\nlet nextCallNumber = 0;\nfunction getNewCallNumber() {\n    const callNumber = nextCallNumber;\n    nextCallNumber += 1;\n    if (nextCallNumber >= Number.MAX_SAFE_INTEGER) {\n        nextCallNumber = 0;\n    }\n    return callNumber;\n}\nclass ChannelImplementation {\n    constructor(target, credentials, options) {\n        var _a, _b, _c;\n        this.credentials = credentials;\n        this.options = options;\n        this.connectivityState = ConnectivityState.IDLE;\n        this.currentPicker = new picker_1.UnavailablePicker();\n        /**\n         * Calls queued up to get a call config. Should only be populated before the\n         * first time the resolver returns a result, which includes the ConfigSelector.\n         */\n        this.configSelectionQueue = [];\n        this.pickQueue = [];\n        this.connectivityStateWatchers = [];\n        this.configSelector = null;\n        if (typeof target !== 'string') {\n            throw new TypeError('Channel target must be a string');\n        }\n        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n            throw new TypeError('Channel credentials must be a ChannelCredentials object');\n        }\n        if (options) {\n            if (typeof options !== 'object' ||\n                !Object.values(options).every((value) => typeof value === 'string' ||\n                    typeof value === 'number' ||\n                    typeof value === 'undefined')) {\n                throw new TypeError('Channel options must be an object with string or number values');\n            }\n        }\n        const originalTargetUri = uri_parser_1.parseUri(target);\n        if (originalTargetUri === null) {\n            throw new Error(`Could not parse target name \"${target}\"`);\n        }\n        /* This ensures that the target has a scheme that is registered with the\n         * resolver */\n        const defaultSchemeMapResult = resolver_1.mapUriDefaultScheme(originalTargetUri);\n        if (defaultSchemeMapResult === null) {\n            throw new Error(`Could not find a default scheme for target name \"${target}\"`);\n        }\n        this.callRefTimer = setInterval(() => { }, MAX_TIMEOUT_TIME);\n        (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        if (this.options['grpc.default_authority']) {\n            this.defaultAuthority = this.options['grpc.default_authority'];\n        }\n        else {\n            this.defaultAuthority = resolver_1.getDefaultAuthority(defaultSchemeMapResult);\n        }\n        const proxyMapResult = http_proxy_1.mapProxyName(defaultSchemeMapResult, options);\n        this.target = proxyMapResult.target;\n        this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n        /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n         * the grpc.use_local_subchannel_pool channel option means. */\n        this.subchannelPool = subchannel_pool_1.getSubchannelPool(((_c = options['grpc.use_local_subchannel_pool']) !== null && _c !== void 0 ? _c : 0) === 0);\n        const channelControlHelper = {\n            createSubchannel: (subchannelAddress, subchannelArgs) => {\n                return this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);\n            },\n            updateState: (connectivityState, picker) => {\n                this.currentPicker = picker;\n                const queueCopy = this.pickQueue.slice();\n                this.pickQueue = [];\n                this.callRefTimerUnref();\n                for (const { callStream, callMetadata, callConfig } of queueCopy) {\n                    this.tryPick(callStream, callMetadata, callConfig);\n                }\n                this.updateState(connectivityState);\n            },\n            requestReresolution: () => {\n                // This should never be called.\n                throw new Error('Resolving load balancer should never call requestReresolution');\n            },\n        };\n        this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options, (configSelector) => {\n            this.configSelector = configSelector;\n            /* We process the queue asynchronously to ensure that the corresponding\n             * load balancer update has completed. */\n            process.nextTick(() => {\n                const localQueue = this.configSelectionQueue;\n                this.configSelectionQueue = [];\n                this.callRefTimerUnref();\n                for (const { callStream, callMetadata } of localQueue) {\n                    this.tryGetConfig(callStream, callMetadata);\n                }\n                this.configSelectionQueue = [];\n            });\n        }, (status) => {\n            if (this.configSelectionQueue.length > 0) {\n                logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', 'Name resolution failed for target ' + uri_parser_1.uriToString(this.target) + ' with calls queued for config selection');\n            }\n            const localQueue = this.configSelectionQueue;\n            this.configSelectionQueue = [];\n            this.callRefTimerUnref();\n            for (const { callStream, callMetadata } of localQueue) {\n                if (callMetadata.getOptions().waitForReady) {\n                    this.callRefTimerRef();\n                    this.configSelectionQueue.push({ callStream, callMetadata });\n                }\n                else {\n                    callStream.cancelWithStatus(status.code, status.details);\n                }\n            }\n        });\n        this.filterStackFactory = new filter_stack_1.FilterStackFactory([\n            new call_credentials_filter_1.CallCredentialsFilterFactory(this),\n            new deadline_filter_1.DeadlineFilterFactory(this),\n            new max_message_size_filter_1.MaxMessageSizeFilterFactory(this.options),\n            new compression_filter_1.CompressionFilterFactory(this),\n        ]);\n    }\n    callRefTimerRef() {\n        var _a, _b, _c, _d;\n        // If the hasRef function does not exist, always run the code\n        if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n            logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', 'callRefTimer.ref | configSelectionQueue.length=' + this.configSelectionQueue.length + ' pickQueue.length=' + this.pickQueue.length);\n            (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);\n        }\n    }\n    callRefTimerUnref() {\n        var _a, _b;\n        // If the hasRef function does not exist, always run the code\n        if ((!this.callRefTimer.hasRef) || (this.callRefTimer.hasRef())) {\n            logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', 'callRefTimer.unref | configSelectionQueue.length=' + this.configSelectionQueue.length + ' pickQueue.length=' + this.pickQueue.length);\n            (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    pushPick(callStream, callMetadata, callConfig) {\n        this.pickQueue.push({ callStream, callMetadata, callConfig });\n        this.callRefTimerRef();\n    }\n    /**\n     * Check the picker output for the given call and corresponding metadata,\n     * and take any relevant actions. Should not be called while iterating\n     * over pickQueue.\n     * @param callStream\n     * @param callMetadata\n     */\n    tryPick(callStream, callMetadata, callConfig) {\n        var _a, _b, _c;\n        const pickResult = this.currentPicker.pick({ metadata: callMetadata, extraPickInfo: callConfig.pickInformation });\n        logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', 'Pick result: ' +\n            picker_1.PickResultType[pickResult.pickResultType] +\n            ' subchannel: ' + ((_a = pickResult.subchannel) === null || _a === void 0 ? void 0 : _a.getAddress()) +\n            ' status: ' + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.code) +\n            ' ' + ((_c = pickResult.status) === null || _c === void 0 ? void 0 : _c.details));\n        switch (pickResult.pickResultType) {\n            case picker_1.PickResultType.COMPLETE:\n                if (pickResult.subchannel === null) {\n                    callStream.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Request dropped by load balancing policy');\n                    // End the call with an error\n                }\n                else {\n                    /* If the subchannel is not in the READY state, that indicates a bug\n                     * somewhere in the load balancer or picker. So, we log an error and\n                     * queue the pick to be tried again later. */\n                    if (pickResult.subchannel.getConnectivityState() !==\n                        ConnectivityState.READY) {\n                        logging_1.log(constants_1.LogVerbosity.ERROR, 'Error: COMPLETE pick result subchannel ' +\n                            pickResult.subchannel.getAddress() +\n                            ' has state ' +\n                            ConnectivityState[pickResult.subchannel.getConnectivityState()]);\n                        this.pushPick(callStream, callMetadata, callConfig);\n                        break;\n                    }\n                    /* We need to clone the callMetadata here because the transparent\n                     * retry code in the promise resolution handler use the same\n                     * callMetadata object, so it needs to stay unmodified */\n                    callStream.filterStack\n                        .sendMetadata(Promise.resolve(callMetadata.clone()))\n                        .then((finalMetadata) => {\n                        var _a, _b, _c;\n                        const subchannelState = pickResult.subchannel.getConnectivityState();\n                        if (subchannelState === ConnectivityState.READY) {\n                            try {\n                                pickResult.subchannel.startCallStream(finalMetadata, callStream, (_a = pickResult.extraFilterFactory) !== null && _a !== void 0 ? _a : undefined);\n                                /* If we reach this point, the call stream has started\n                                 * successfully */\n                                (_b = callConfig.onCommitted) === null || _b === void 0 ? void 0 : _b.call(callConfig);\n                                (_c = pickResult.onCallStarted) === null || _c === void 0 ? void 0 : _c.call(pickResult);\n                            }\n                            catch (error) {\n                                if (error.code ===\n                                    'ERR_HTTP2_GOAWAY_SESSION') {\n                                    /* An error here indicates that something went wrong with\n                                     * the picked subchannel's http2 stream right before we\n                                     * tried to start the stream. We are handling a promise\n                                     * result here, so this is asynchronous with respect to the\n                                     * original tryPick call, so calling it again is not\n                                     * recursive. We call tryPick immediately instead of\n                                     * queueing this pick again because handling the queue is\n                                     * triggered by state changes, and we want to immediately\n                                     * check if the state has already changed since the\n                                     * previous tryPick call. We do this instead of cancelling\n                                     * the stream because the correct behavior may be\n                                     * re-queueing instead, based on the logic in the rest of\n                                     * tryPick */\n                                    logging_1.trace(constants_1.LogVerbosity.INFO, 'channel', 'Failed to start call on picked subchannel ' +\n                                        pickResult.subchannel.getAddress() +\n                                        ' with error ' +\n                                        error.message +\n                                        '. Retrying pick');\n                                    this.tryPick(callStream, callMetadata, callConfig);\n                                }\n                                else {\n                                    logging_1.trace(constants_1.LogVerbosity.INFO, 'channel', 'Failed to start call on picked subchanel ' +\n                                        pickResult.subchannel.getAddress() +\n                                        ' with error ' +\n                                        error.message +\n                                        '. Ending call');\n                                    callStream.cancelWithStatus(constants_1.Status.INTERNAL, `Failed to start HTTP/2 stream with error: ${error.message}`);\n                                }\n                            }\n                        }\n                        else {\n                            /* The logic for doing this here is the same as in the catch\n                             * block above */\n                            logging_1.trace(constants_1.LogVerbosity.INFO, 'channel', 'Picked subchannel ' +\n                                pickResult.subchannel.getAddress() +\n                                ' has state ' +\n                                ConnectivityState[subchannelState] +\n                                ' after metadata filters. Retrying pick');\n                            this.tryPick(callStream, callMetadata, callConfig);\n                        }\n                    }, (error) => {\n                        // We assume the error code isn't 0 (Status.OK)\n                        callStream.cancelWithStatus((typeof error.code === 'number') ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\n                    });\n                }\n                break;\n            case picker_1.PickResultType.QUEUE:\n                this.pushPick(callStream, callMetadata, callConfig);\n                break;\n            case picker_1.PickResultType.TRANSIENT_FAILURE:\n                if (callMetadata.getOptions().waitForReady) {\n                    this.pushPick(callStream, callMetadata, callConfig);\n                }\n                else {\n                    callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);\n                }\n                break;\n            case picker_1.PickResultType.DROP:\n                callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);\n                break;\n            default:\n                throw new Error(`Invalid state: unknown pickResultType ${pickResult.pickResultType}`);\n        }\n    }\n    removeConnectivityStateWatcher(watcherObject) {\n        const watcherIndex = this.connectivityStateWatchers.findIndex((value) => value === watcherObject);\n        if (watcherIndex >= 0) {\n            this.connectivityStateWatchers.splice(watcherIndex, 1);\n        }\n    }\n    updateState(newState) {\n        logging_1.trace(constants_1.LogVerbosity.DEBUG, 'connectivity_state', uri_parser_1.uriToString(this.target) +\n            ' ' +\n            ConnectivityState[this.connectivityState] +\n            ' -> ' +\n            ConnectivityState[newState]);\n        this.connectivityState = newState;\n        const watchersCopy = this.connectivityStateWatchers.slice();\n        for (const watcherObject of watchersCopy) {\n            if (newState !== watcherObject.currentState) {\n                if (watcherObject.timer) {\n                    clearTimeout(watcherObject.timer);\n                }\n                this.removeConnectivityStateWatcher(watcherObject);\n                watcherObject.callback();\n            }\n        }\n    }\n    tryGetConfig(stream, metadata) {\n        if (this.configSelector === null) {\n            /* This branch will only be taken at the beginning of the channel's life,\n             * before the resolver ever returns a result. So, the\n             * ResolvingLoadBalancer may be idle and if so it needs to be kicked\n             * because it now has a pending request. */\n            this.resolvingLoadBalancer.exitIdle();\n            this.configSelectionQueue.push({\n                callStream: stream,\n                callMetadata: metadata\n            });\n            this.callRefTimerRef();\n        }\n        else {\n            const callConfig = this.configSelector(stream.getMethod(), metadata);\n            if (callConfig.status === constants_1.Status.OK) {\n                this.tryPick(stream, metadata, callConfig);\n            }\n            else {\n                stream.cancelWithStatus(callConfig.status, \"Failed to route call to method \" + stream.getMethod());\n            }\n        }\n    }\n    _startCallStream(stream, metadata) {\n        this.tryGetConfig(stream, metadata.clone());\n    }\n    close() {\n        this.resolvingLoadBalancer.destroy();\n        this.updateState(ConnectivityState.SHUTDOWN);\n        clearInterval(this.callRefTimer);\n        this.subchannelPool.unrefUnusedSubchannels();\n    }\n    getTarget() {\n        return uri_parser_1.uriToString(this.target);\n    }\n    getConnectivityState(tryToConnect) {\n        const connectivityState = this.connectivityState;\n        if (tryToConnect) {\n            this.resolvingLoadBalancer.exitIdle();\n        }\n        return connectivityState;\n    }\n    watchConnectivityState(currentState, deadline, callback) {\n        if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n            throw new Error('Channel has been shut down');\n        }\n        let timer = null;\n        if (deadline !== Infinity) {\n            const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);\n            const now = new Date();\n            if (deadline === -Infinity || deadlineDate <= now) {\n                process.nextTick(callback, new Error('Deadline passed without connectivity state change'));\n                return;\n            }\n            timer = setTimeout(() => {\n                this.removeConnectivityStateWatcher(watcherObject);\n                callback(new Error('Deadline passed without connectivity state change'));\n            }, deadlineDate.getTime() - now.getTime());\n        }\n        const watcherObject = {\n            currentState,\n            callback,\n            timer\n        };\n        this.connectivityStateWatchers.push(watcherObject);\n    }\n    createCall(method, deadline, host, parentCall, propagateFlags) {\n        if (typeof method !== 'string') {\n            throw new TypeError('Channel#createCall: method must be a string');\n        }\n        if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n            throw new TypeError('Channel#createCall: deadline must be a number or Date');\n        }\n        if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n            throw new Error('Channel has been shut down');\n        }\n        const callNumber = getNewCallNumber();\n        logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', uri_parser_1.uriToString(this.target) +\n            ' createCall [' +\n            callNumber +\n            '] method=\"' +\n            method +\n            '\", deadline=' +\n            deadline);\n        const finalOptions = {\n            deadline: deadline,\n            flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,\n            host: host !== null && host !== void 0 ? host : this.defaultAuthority,\n            parentCall: parentCall,\n        };\n        const stream = new call_stream_1.Http2CallStream(method, this, finalOptions, this.filterStackFactory, this.credentials._getCallCredentials(), callNumber);\n        return stream;\n    }\n}\nexports.ChannelImplementation = ChannelImplementation;\n//# sourceMappingURL=channel.js.map"]},"metadata":{},"sourceType":"script"}