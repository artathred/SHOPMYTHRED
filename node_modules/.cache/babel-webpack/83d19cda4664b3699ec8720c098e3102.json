{"ast":null,"code":"import { __awaiter } from 'tslib';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Optional, Inject, PLATFORM_ID, NgZone, ComponentFactoryResolver, NgModule } from '@angular/core';\nimport { of, EMPTY } from 'rxjs';\nimport { isPlatformBrowser, isPlatformServer } from '@angular/common';\nimport { observeOn, switchMap, map, shareReplay, filter, groupBy, mergeMap, distinctUntilChanged, startWith, pairwise } from 'rxjs/operators';\nimport * as i1 from '@angular/fire';\nimport { ɵAngularFireSchedulers, ɵfetchInstance, ɵlazySDKProxy, FirebaseApp, ɵapplyMixins } from '@angular/fire';\nimport { ActivationEnd, ɵEmptyOutletComponent, Router } from '@angular/router';\nimport { Title } from '@angular/platform-browser';\nimport { AngularFireAuth } from '@angular/fire/auth';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/fire';\nimport * as ɵngcc2 from '@angular/fire/auth';\nimport * as ɵngcc3 from '@angular/router';\nimport * as ɵngcc4 from '@angular/platform-browser';\nconst proxyPolyfillCompat = {\n  app: null,\n  logEvent: null,\n  setCurrentScreen: null,\n  setUserId: null,\n  setUserProperties: null,\n  setAnalyticsCollectionEnabled: null\n};\nconst COLLECTION_ENABLED = /*#__PURE__*/new InjectionToken('angularfire2.analytics.analyticsCollectionEnabled');\nconst APP_VERSION = /*#__PURE__*/new InjectionToken('angularfire2.analytics.appVersion');\nconst APP_NAME = /*#__PURE__*/new InjectionToken('angularfire2.analytics.appName');\nconst DEBUG_MODE = /*#__PURE__*/new InjectionToken('angularfire2.analytics.debugMode');\nconst CONFIG = /*#__PURE__*/new InjectionToken('angularfire2.analytics.config');\nconst APP_NAME_KEY = 'app_name';\nconst APP_VERSION_KEY = 'app_version';\nconst DEBUG_MODE_KEY = 'debug_mode';\nconst GTAG_CONFIG_COMMAND = 'config';\nconst GTAG_FUNCTION_NAME = 'gtag'; // TODO rename these\n\nconst DATA_LAYER_NAME = 'dataLayer';\nconst SEND_TO_KEY = 'send_to';\nlet AngularFireAnalytics = /*#__PURE__*/(() => {\n  class AngularFireAnalytics {\n    constructor(app, analyticsCollectionEnabled, providedAppVersion, providedAppName, debugModeEnabled, providedConfig, // tslint:disable-next-line:ban-types\n    platformId, zone) {\n      this.analyticsInitialized = new Promise(() => {});\n\n      if (isPlatformBrowser(platformId)) {\n        window[DATA_LAYER_NAME] = window[DATA_LAYER_NAME] || []; // It turns out we can't rely on the measurementId in the Firebase config JSON\n        // this identifier is not stable. firebase/analytics does a call to get a fresh value\n        // falling back on the one in the config. Rather than do that ourselves we should listen\n        // on our gtag function for a analytics config command\n        // e.g, ['config', measurementId, { origin: 'firebase', firebase_id }]\n\n        const parseMeasurementId = (...args) => {\n          if (args[0] === 'config' && args[2].origin === 'firebase') {\n            this.measurementId = args[1];\n            return true;\n          } else {\n            return false;\n          }\n        };\n\n        const patchGtag = fn => {\n          window[GTAG_FUNCTION_NAME] = (...args) => {\n            if (fn) {\n              fn(...args);\n            } // Inject app_name and app_version into events\n            // TODO(jamesdaniels): I'm doing this as documented but it's still not\n            //   showing up in the console. Investigate. Guessing it's just part of the\n            //   whole GA4 transition mess.\n\n\n            if (args[0] === 'event' && args[2][SEND_TO_KEY] === this.measurementId) {\n              if (providedAppName) {\n                args[2][APP_NAME_KEY] = providedAppName;\n              }\n\n              if (providedAppVersion) {\n                args[2][APP_VERSION_KEY] = providedAppVersion;\n              }\n            }\n\n            if (debugModeEnabled && typeof console !== 'undefined') {\n              // tslint:disable-next-line:no-console\n              console.info(...args);\n            }\n            /**\n             * According to the gtag documentation, this function that defines a custom data layer cannot be\n             * an arrow function because 'arguments' is not an array. It is actually an object that behaves\n             * like an array and contains more information then just indexes. Transforming this into arrow function\n             * caused issue #2505 where analytics no longer sent any data.\n             */\n            // tslint:disable-next-line: only-arrow-functions\n\n\n            (function (..._args) {\n              window[DATA_LAYER_NAME].push(arguments);\n            })(...args);\n          };\n        }; // Unclear if we still need to but I was running into config/events I passed\n        // to gtag before ['js' timestamp] weren't getting parsed, so let's make a promise\n        // that resolves when firebase/analytics has configured gtag.js that we wait on\n        // before sending anything\n\n\n        const firebaseAnalyticsAlreadyInitialized = window[DATA_LAYER_NAME].some(parseMeasurementId);\n\n        if (firebaseAnalyticsAlreadyInitialized) {\n          this.analyticsInitialized = Promise.resolve();\n          patchGtag();\n        } else {\n          this.analyticsInitialized = new Promise(resolve => {\n            patchGtag((...args) => {\n              if (parseMeasurementId(...args)) {\n                resolve();\n              }\n            });\n          });\n        }\n\n        if (providedConfig) {\n          this.updateConfig(providedConfig);\n        }\n\n        if (debugModeEnabled) {\n          this.updateConfig({\n            [DEBUG_MODE_KEY]: 1\n          });\n        }\n      } else {\n        this.analyticsInitialized = Promise.resolve();\n      }\n\n      const analytics = of(undefined).pipe(observeOn(new ɵAngularFireSchedulers(zone).outsideAngular), switchMap(() => isPlatformBrowser(platformId) ? zone.runOutsideAngular(() => import('firebase/analytics')) : EMPTY), // SEMVER can switch to isSupported() when we only target v8\n      // switchMap(() => firebase.analytics.isSupported().then(it => it, () => false)),\n      // TODO server-side investigate use of the Universal Analytics API\n      // switchMap(supported => supported ? of(undefined) : EMPTY),\n      map(() => {\n        return ɵfetchInstance(`analytics`, 'AngularFireAnalytics', app, () => {\n          const analytics = app.analytics();\n\n          if (analyticsCollectionEnabled === false) {\n            analytics.setAnalyticsCollectionEnabled(false);\n          }\n\n          return analytics;\n        }, [app, analyticsCollectionEnabled, providedConfig, debugModeEnabled]);\n      }), shareReplay({\n        bufferSize: 1,\n        refCount: false\n      }));\n      return ɵlazySDKProxy(this, analytics, zone);\n    }\n\n    updateConfig(config) {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield this.analyticsInitialized;\n        window[GTAG_FUNCTION_NAME](GTAG_CONFIG_COMMAND, this.measurementId, Object.assign(Object.assign({}, config), {\n          update: true\n        }));\n      });\n    }\n\n  }\n\n  AngularFireAnalytics.ɵfac = function AngularFireAnalytics_Factory(t) {\n    return new (t || AngularFireAnalytics)(ɵngcc0.ɵɵinject(ɵngcc1.FirebaseApp), ɵngcc0.ɵɵinject(COLLECTION_ENABLED, 8), ɵngcc0.ɵɵinject(APP_VERSION, 8), ɵngcc0.ɵɵinject(APP_NAME, 8), ɵngcc0.ɵɵinject(DEBUG_MODE, 8), ɵngcc0.ɵɵinject(CONFIG, 8), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  AngularFireAnalytics.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function AngularFireAnalytics_Factory() {\n      return new AngularFireAnalytics(i0.ɵɵinject(i1.FirebaseApp), i0.ɵɵinject(COLLECTION_ENABLED, 8), i0.ɵɵinject(APP_VERSION, 8), i0.ɵɵinject(APP_NAME, 8), i0.ɵɵinject(DEBUG_MODE, 8), i0.ɵɵinject(CONFIG, 8), i0.ɵɵinject(i0.PLATFORM_ID), i0.ɵɵinject(i0.NgZone));\n    },\n    token: AngularFireAnalytics,\n    providedIn: \"any\"\n  });\n  /** @nocollapse */\n\n  return AngularFireAnalytics;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*#__PURE__*/\nɵapplyMixins(AngularFireAnalytics, [proxyPolyfillCompat]);\nlet UserTrackingService = /*#__PURE__*/(() => {\n  class UserTrackingService {\n    // TODO a user properties injector\n    constructor(analytics, // tslint:disable-next-line:ban-types\n    platformId, auth, zone) {\n      this.disposables = [];\n\n      if (!isPlatformServer(platformId)) {\n        let resolveInitialized;\n        this.initialized = zone.runOutsideAngular(() => new Promise(resolve => resolveInitialized = resolve));\n        this.disposables = [auth.authState.subscribe(user => {\n          analytics.setUserId(user === null || user === void 0 ? void 0 : user.uid);\n          resolveInitialized();\n        }), auth.credential.subscribe(credential => {\n          if (credential) {\n            const method = credential.user.isAnonymous ? 'anonymous' : credential.additionalUserInfo.providerId;\n\n            if (credential.additionalUserInfo.isNewUser) {\n              analytics.logEvent('sign_up', {\n                method\n              });\n            }\n\n            analytics.logEvent('login', {\n              method\n            });\n          }\n        })];\n      } else {\n        this.initialized = Promise.resolve();\n      }\n    }\n\n    ngOnDestroy() {\n      this.disposables.forEach(it => it.unsubscribe());\n    }\n\n  }\n\n  UserTrackingService.ɵfac = function UserTrackingService_Factory(t) {\n    return new (t || UserTrackingService)(ɵngcc0.ɵɵinject(AngularFireAnalytics), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(ɵngcc2.AngularFireAuth), ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n  };\n\n  UserTrackingService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: UserTrackingService,\n    factory: UserTrackingService.ɵfac\n  });\n  /** @nocollapse */\n\n  return UserTrackingService;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst FIREBASE_EVENT_ORIGIN_KEY = 'firebase_event_origin';\nconst FIREBASE_PREVIOUS_SCREEN_CLASS_KEY = 'firebase_previous_class';\nconst FIREBASE_PREVIOUS_SCREEN_INSTANCE_ID_KEY = 'firebase_previous_id';\nconst FIREBASE_PREVIOUS_SCREEN_NAME_KEY = 'firebase_previous_screen';\nconst FIREBASE_SCREEN_CLASS_KEY = 'firebase_screen_class';\nconst FIREBASE_SCREEN_INSTANCE_ID_KEY = 'firebase_screen_id';\nconst FIREBASE_SCREEN_NAME_KEY = 'firebase_screen';\nconst OUTLET_KEY = 'outlet';\nconst PAGE_PATH_KEY = 'page_path';\nconst PAGE_TITLE_KEY = 'page_title';\nconst SCREEN_CLASS_KEY = 'screen_class';\nconst SCREEN_NAME_KEY = 'screen_name';\nconst SCREEN_VIEW_EVENT = 'screen_view';\nconst EVENT_ORIGIN_AUTO = 'auto';\nconst SCREEN_INSTANCE_DELIMITER = '#'; // this is an INT64 in iOS/Android but use INT32 cause javascript\n\nlet nextScreenInstanceID = /*#__PURE__*/Math.floor( /*#__PURE__*/Math.random() * ( /*#__PURE__*/Math.pow(2, 32) - 1)) - /*#__PURE__*/Math.pow(2, 31);\nconst knownScreenInstanceIDs = {};\n\nconst getScreenInstanceID = params => {\n  // unique the screen class against the outlet name\n  const screenInstanceKey = [params[SCREEN_CLASS_KEY], params[OUTLET_KEY]].join(SCREEN_INSTANCE_DELIMITER);\n\n  if (knownScreenInstanceIDs.hasOwnProperty(screenInstanceKey)) {\n    return knownScreenInstanceIDs[screenInstanceKey];\n  } else {\n    const ret = nextScreenInstanceID++;\n    knownScreenInstanceIDs[screenInstanceKey] = ret;\n    return ret;\n  }\n};\n\nconst ɵ0 = getScreenInstanceID;\nlet ScreenTrackingService = /*#__PURE__*/(() => {\n  class ScreenTrackingService {\n    constructor(analytics, router, title, componentFactoryResolver, // tslint:disable-next-line:ban-types\n    platformId, zone, userTrackingService) {\n      if (!router || !isPlatformBrowser(platformId)) {\n        return this;\n      }\n\n      zone.runOutsideAngular(() => {\n        const activationEndEvents = router.events.pipe(filter(e => e instanceof ActivationEnd));\n        this.disposable = activationEndEvents.pipe(switchMap(activationEnd => {\n          var _a; // router parseUrl is having trouble with outlets when they're empty\n          // e.g, /asdf/1(bob://sally:asdf), so put another slash in when empty\n\n\n          const urlTree = router.parseUrl(router.url.replace(/(?:\\().+(?:\\))/g, a => a.replace('://', ':///')));\n          const pagePath = ((_a = urlTree.root.children[activationEnd.snapshot.outlet]) === null || _a === void 0 ? void 0 : _a.toString()) || '';\n          const actualSnapshot = router.routerState.root.children.map(it => it).find(it => it.outlet === activationEnd.snapshot.outlet);\n\n          if (!actualSnapshot) {\n            return of(null);\n          }\n\n          let actualDeep = actualSnapshot;\n\n          while (actualDeep.firstChild) {\n            actualDeep = actualDeep.firstChild;\n          }\n\n          const screenName = actualDeep.pathFromRoot.map(s => {\n            var _a;\n\n            return (_a = s.routeConfig) === null || _a === void 0 ? void 0 : _a.path;\n          }).filter(it => it).join('/') || '/';\n          const params = {\n            [SCREEN_NAME_KEY]: screenName,\n            [PAGE_PATH_KEY]: `/${pagePath}`,\n            [FIREBASE_EVENT_ORIGIN_KEY]: EVENT_ORIGIN_AUTO,\n            [FIREBASE_SCREEN_NAME_KEY]: screenName,\n            [OUTLET_KEY]: activationEnd.snapshot.outlet\n          };\n\n          if (title) {\n            params[PAGE_TITLE_KEY] = title.getTitle();\n          }\n\n          let component = actualSnapshot.component;\n\n          if (component) {\n            if (component === ɵEmptyOutletComponent) {\n              let deepSnapshot = activationEnd.snapshot; // TODO when might there be mutple children, different outlets? explore\n\n              while (deepSnapshot.firstChild) {\n                deepSnapshot = deepSnapshot.firstChild;\n              }\n\n              component = deepSnapshot.component;\n            }\n          } else {\n            component = activationEnd.snapshot.component;\n          }\n\n          if (typeof component === 'string') {\n            return of(Object.assign(Object.assign({}, params), {\n              [SCREEN_CLASS_KEY]: component\n            }));\n          } else if (component) {\n            const componentFactory = componentFactoryResolver.resolveComponentFactory(component);\n            return of(Object.assign(Object.assign({}, params), {\n              [SCREEN_CLASS_KEY]: componentFactory.selector\n            }));\n          } else {\n            // lazy loads cause extra activations, ignore\n            return of(null);\n          }\n        }), filter(it => it), map(params => Object.assign({\n          [FIREBASE_SCREEN_CLASS_KEY]: params[SCREEN_CLASS_KEY],\n          [FIREBASE_SCREEN_INSTANCE_ID_KEY]: getScreenInstanceID(params)\n        }, params)), groupBy(it => it[OUTLET_KEY]), mergeMap(it => it.pipe(distinctUntilChanged((a, b) => JSON.stringify(a) === JSON.stringify(b)), startWith(undefined), pairwise(), map(([prior, current]) => prior ? Object.assign({\n          [FIREBASE_PREVIOUS_SCREEN_CLASS_KEY]: prior[SCREEN_CLASS_KEY],\n          [FIREBASE_PREVIOUS_SCREEN_NAME_KEY]: prior[SCREEN_NAME_KEY],\n          [FIREBASE_PREVIOUS_SCREEN_INSTANCE_ID_KEY]: prior[FIREBASE_SCREEN_INSTANCE_ID_KEY]\n        }, current) : current), switchMap(params => __awaiter(this, void 0, void 0, function* () {\n          if (userTrackingService) {\n            yield userTrackingService.initialized;\n          }\n\n          return yield analytics.logEvent(SCREEN_VIEW_EVENT, params);\n        }))))).subscribe();\n      });\n    }\n\n    ngOnDestroy() {\n      if (this.disposable) {\n        this.disposable.unsubscribe();\n      }\n    }\n\n  }\n\n  ScreenTrackingService.ɵfac = function ScreenTrackingService_Factory(t) {\n    return new (t || ScreenTrackingService)(ɵngcc0.ɵɵinject(AngularFireAnalytics), ɵngcc0.ɵɵinject(ɵngcc3.Router, 8), ɵngcc0.ɵɵinject(ɵngcc4.Title, 8), ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(UserTrackingService, 8));\n  };\n\n  ScreenTrackingService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: ScreenTrackingService,\n    factory: ScreenTrackingService.ɵfac\n  });\n  /** @nocollapse */\n\n  return ScreenTrackingService;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet AngularFireAnalyticsModule = /*#__PURE__*/(() => {\n  class AngularFireAnalyticsModule {\n    constructor(analytics, screenTracking, userTracking) {\n      // calling anything on analytics will eagerly load the SDK\n      // tslint:disable-next-line:no-unused-expression\n      analytics.app.then(() => {});\n    }\n\n  }\n\n  AngularFireAnalyticsModule.ɵfac = function AngularFireAnalyticsModule_Factory(t) {\n    return new (t || AngularFireAnalyticsModule)(ɵngcc0.ɵɵinject(AngularFireAnalytics), ɵngcc0.ɵɵinject(ScreenTrackingService, 8), ɵngcc0.ɵɵinject(UserTrackingService, 8));\n  };\n\n  AngularFireAnalyticsModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: AngularFireAnalyticsModule\n  });\n  AngularFireAnalyticsModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [AngularFireAnalytics]\n  });\n  /** @nocollapse */\n\n  return AngularFireAnalyticsModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { APP_NAME, APP_VERSION, AngularFireAnalytics, AngularFireAnalyticsModule, COLLECTION_ENABLED, CONFIG, DEBUG_MODE, ScreenTrackingService, UserTrackingService, ɵ0 }; //# sourceMappingURL=angular-fire-analytics.js.map","map":null,"metadata":{},"sourceType":"module"}