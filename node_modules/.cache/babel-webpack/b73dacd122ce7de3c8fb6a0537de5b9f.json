{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChannelImplementation = exports.ConnectivityState = void 0;\n\nconst call_stream_1 = require(\"./call-stream\");\n\nconst channel_credentials_1 = require(\"./channel-credentials\");\n\nconst resolving_load_balancer_1 = require(\"./resolving-load-balancer\");\n\nconst subchannel_pool_1 = require(\"./subchannel-pool\");\n\nconst picker_1 = require(\"./picker\");\n\nconst constants_1 = require(\"./constants\");\n\nconst filter_stack_1 = require(\"./filter-stack\");\n\nconst call_credentials_filter_1 = require(\"./call-credentials-filter\");\n\nconst deadline_filter_1 = require(\"./deadline-filter\");\n\nconst compression_filter_1 = require(\"./compression-filter\");\n\nconst resolver_1 = require(\"./resolver\");\n\nconst logging_1 = require(\"./logging\");\n\nconst max_message_size_filter_1 = require(\"./max-message-size-filter\");\n\nconst http_proxy_1 = require(\"./http_proxy\");\n\nconst uri_parser_1 = require(\"./uri-parser\");\n\nvar ConnectivityState;\n\n(function (ConnectivityState) {\n  ConnectivityState[ConnectivityState[\"IDLE\"] = 0] = \"IDLE\";\n  ConnectivityState[ConnectivityState[\"CONNECTING\"] = 1] = \"CONNECTING\";\n  ConnectivityState[ConnectivityState[\"READY\"] = 2] = \"READY\";\n  ConnectivityState[ConnectivityState[\"TRANSIENT_FAILURE\"] = 3] = \"TRANSIENT_FAILURE\";\n  ConnectivityState[ConnectivityState[\"SHUTDOWN\"] = 4] = \"SHUTDOWN\";\n})(ConnectivityState = exports.ConnectivityState || (exports.ConnectivityState = {}));\n/**\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\n */\n\n\nconst MAX_TIMEOUT_TIME = 2147483647;\nlet nextCallNumber = 0;\n\nfunction getNewCallNumber() {\n  const callNumber = nextCallNumber;\n  nextCallNumber += 1;\n\n  if (nextCallNumber >= Number.MAX_SAFE_INTEGER) {\n    nextCallNumber = 0;\n  }\n\n  return callNumber;\n}\n\nclass ChannelImplementation {\n  constructor(target, credentials, options) {\n    var _a, _b, _c;\n\n    this.credentials = credentials;\n    this.options = options;\n    this.connectivityState = ConnectivityState.IDLE;\n    this.currentPicker = new picker_1.UnavailablePicker();\n    /**\n     * Calls queued up to get a call config. Should only be populated before the\n     * first time the resolver returns a result, which includes the ConfigSelector.\n     */\n\n    this.configSelectionQueue = [];\n    this.pickQueue = [];\n    this.connectivityStateWatchers = [];\n    this.configSelector = null;\n\n    if (typeof target !== 'string') {\n      throw new TypeError('Channel target must be a string');\n    }\n\n    if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n      throw new TypeError('Channel credentials must be a ChannelCredentials object');\n    }\n\n    if (options) {\n      if (typeof options !== 'object' || !Object.values(options).every(value => typeof value === 'string' || typeof value === 'number' || typeof value === 'undefined')) {\n        throw new TypeError('Channel options must be an object with string or number values');\n      }\n    }\n\n    const originalTargetUri = uri_parser_1.parseUri(target);\n\n    if (originalTargetUri === null) {\n      throw new Error(`Could not parse target name \"${target}\"`);\n    }\n    /* This ensures that the target has a scheme that is registered with the\n     * resolver */\n\n\n    const defaultSchemeMapResult = resolver_1.mapUriDefaultScheme(originalTargetUri);\n\n    if (defaultSchemeMapResult === null) {\n      throw new Error(`Could not find a default scheme for target name \"${target}\"`);\n    }\n\n    this.callRefTimer = setInterval(() => {}, MAX_TIMEOUT_TIME);\n    (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n\n    if (this.options['grpc.default_authority']) {\n      this.defaultAuthority = this.options['grpc.default_authority'];\n    } else {\n      this.defaultAuthority = resolver_1.getDefaultAuthority(defaultSchemeMapResult);\n    }\n\n    const proxyMapResult = http_proxy_1.mapProxyName(defaultSchemeMapResult, options);\n    this.target = proxyMapResult.target;\n    this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n    /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n     * the grpc.use_local_subchannel_pool channel option means. */\n\n    this.subchannelPool = subchannel_pool_1.getSubchannelPool(((_c = options['grpc.use_local_subchannel_pool']) !== null && _c !== void 0 ? _c : 0) === 0);\n    const channelControlHelper = {\n      createSubchannel: (subchannelAddress, subchannelArgs) => {\n        return this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);\n      },\n      updateState: (connectivityState, picker) => {\n        this.currentPicker = picker;\n        const queueCopy = this.pickQueue.slice();\n        this.pickQueue = [];\n        this.callRefTimerUnref();\n\n        for (const {\n          callStream,\n          callMetadata,\n          callConfig\n        } of queueCopy) {\n          this.tryPick(callStream, callMetadata, callConfig);\n        }\n\n        this.updateState(connectivityState);\n      },\n      requestReresolution: () => {\n        // This should never be called.\n        throw new Error('Resolving load balancer should never call requestReresolution');\n      }\n    };\n    this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options, configSelector => {\n      this.configSelector = configSelector;\n      /* We process the queue asynchronously to ensure that the corresponding\n       * load balancer update has completed. */\n\n      process.nextTick(() => {\n        const localQueue = this.configSelectionQueue;\n        this.configSelectionQueue = [];\n        this.callRefTimerUnref();\n\n        for (const {\n          callStream,\n          callMetadata\n        } of localQueue) {\n          this.tryGetConfig(callStream, callMetadata);\n        }\n\n        this.configSelectionQueue = [];\n      });\n    }, status => {\n      if (this.configSelectionQueue.length > 0) {\n        logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', 'Name resolution failed for target ' + uri_parser_1.uriToString(this.target) + ' with calls queued for config selection');\n      }\n\n      const localQueue = this.configSelectionQueue;\n      this.configSelectionQueue = [];\n      this.callRefTimerUnref();\n\n      for (const {\n        callStream,\n        callMetadata\n      } of localQueue) {\n        if (callMetadata.getOptions().waitForReady) {\n          this.callRefTimerRef();\n          this.configSelectionQueue.push({\n            callStream,\n            callMetadata\n          });\n        } else {\n          callStream.cancelWithStatus(status.code, status.details);\n        }\n      }\n    });\n    this.filterStackFactory = new filter_stack_1.FilterStackFactory([new call_credentials_filter_1.CallCredentialsFilterFactory(this), new deadline_filter_1.DeadlineFilterFactory(this), new max_message_size_filter_1.MaxMessageSizeFilterFactory(this.options), new compression_filter_1.CompressionFilterFactory(this)]);\n  }\n\n  callRefTimerRef() {\n    var _a, _b, _c, _d; // If the hasRef function does not exist, always run the code\n\n\n    if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n      logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', 'callRefTimer.ref | configSelectionQueue.length=' + this.configSelectionQueue.length + ' pickQueue.length=' + this.pickQueue.length);\n      (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);\n    }\n  }\n\n  callRefTimerUnref() {\n    var _a, _b; // If the hasRef function does not exist, always run the code\n\n\n    if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {\n      logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', 'callRefTimer.unref | configSelectionQueue.length=' + this.configSelectionQueue.length + ' pickQueue.length=' + this.pickQueue.length);\n      (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n  }\n\n  pushPick(callStream, callMetadata, callConfig) {\n    this.pickQueue.push({\n      callStream,\n      callMetadata,\n      callConfig\n    });\n    this.callRefTimerRef();\n  }\n  /**\n   * Check the picker output for the given call and corresponding metadata,\n   * and take any relevant actions. Should not be called while iterating\n   * over pickQueue.\n   * @param callStream\n   * @param callMetadata\n   */\n\n\n  tryPick(callStream, callMetadata, callConfig) {\n    var _a, _b, _c;\n\n    const pickResult = this.currentPicker.pick({\n      metadata: callMetadata,\n      extraPickInfo: callConfig.pickInformation\n    });\n    logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', 'Pick result: ' + picker_1.PickResultType[pickResult.pickResultType] + ' subchannel: ' + ((_a = pickResult.subchannel) === null || _a === void 0 ? void 0 : _a.getAddress()) + ' status: ' + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.code) + ' ' + ((_c = pickResult.status) === null || _c === void 0 ? void 0 : _c.details));\n\n    switch (pickResult.pickResultType) {\n      case picker_1.PickResultType.COMPLETE:\n        if (pickResult.subchannel === null) {\n          callStream.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Request dropped by load balancing policy'); // End the call with an error\n        } else {\n          /* If the subchannel is not in the READY state, that indicates a bug\n           * somewhere in the load balancer or picker. So, we log an error and\n           * queue the pick to be tried again later. */\n          if (pickResult.subchannel.getConnectivityState() !== ConnectivityState.READY) {\n            logging_1.log(constants_1.LogVerbosity.ERROR, 'Error: COMPLETE pick result subchannel ' + pickResult.subchannel.getAddress() + ' has state ' + ConnectivityState[pickResult.subchannel.getConnectivityState()]);\n            this.pushPick(callStream, callMetadata, callConfig);\n            break;\n          }\n          /* We need to clone the callMetadata here because the transparent\n           * retry code in the promise resolution handler use the same\n           * callMetadata object, so it needs to stay unmodified */\n\n\n          callStream.filterStack.sendMetadata(Promise.resolve(callMetadata.clone())).then(finalMetadata => {\n            var _a, _b, _c;\n\n            const subchannelState = pickResult.subchannel.getConnectivityState();\n\n            if (subchannelState === ConnectivityState.READY) {\n              try {\n                pickResult.subchannel.startCallStream(finalMetadata, callStream, (_a = pickResult.extraFilterFactory) !== null && _a !== void 0 ? _a : undefined);\n                /* If we reach this point, the call stream has started\n                 * successfully */\n\n                (_b = callConfig.onCommitted) === null || _b === void 0 ? void 0 : _b.call(callConfig);\n                (_c = pickResult.onCallStarted) === null || _c === void 0 ? void 0 : _c.call(pickResult);\n              } catch (error) {\n                if (error.code === 'ERR_HTTP2_GOAWAY_SESSION') {\n                  /* An error here indicates that something went wrong with\n                   * the picked subchannel's http2 stream right before we\n                   * tried to start the stream. We are handling a promise\n                   * result here, so this is asynchronous with respect to the\n                   * original tryPick call, so calling it again is not\n                   * recursive. We call tryPick immediately instead of\n                   * queueing this pick again because handling the queue is\n                   * triggered by state changes, and we want to immediately\n                   * check if the state has already changed since the\n                   * previous tryPick call. We do this instead of cancelling\n                   * the stream because the correct behavior may be\n                   * re-queueing instead, based on the logic in the rest of\n                   * tryPick */\n                  logging_1.trace(constants_1.LogVerbosity.INFO, 'channel', 'Failed to start call on picked subchannel ' + pickResult.subchannel.getAddress() + ' with error ' + error.message + '. Retrying pick');\n                  this.tryPick(callStream, callMetadata, callConfig);\n                } else {\n                  logging_1.trace(constants_1.LogVerbosity.INFO, 'channel', 'Failed to start call on picked subchanel ' + pickResult.subchannel.getAddress() + ' with error ' + error.message + '. Ending call');\n                  callStream.cancelWithStatus(constants_1.Status.INTERNAL, `Failed to start HTTP/2 stream with error: ${error.message}`);\n                }\n              }\n            } else {\n              /* The logic for doing this here is the same as in the catch\n               * block above */\n              logging_1.trace(constants_1.LogVerbosity.INFO, 'channel', 'Picked subchannel ' + pickResult.subchannel.getAddress() + ' has state ' + ConnectivityState[subchannelState] + ' after metadata filters. Retrying pick');\n              this.tryPick(callStream, callMetadata, callConfig);\n            }\n          }, error => {\n            // We assume the error code isn't 0 (Status.OK)\n            callStream.cancelWithStatus(typeof error.code === 'number' ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\n          });\n        }\n\n        break;\n\n      case picker_1.PickResultType.QUEUE:\n        this.pushPick(callStream, callMetadata, callConfig);\n        break;\n\n      case picker_1.PickResultType.TRANSIENT_FAILURE:\n        if (callMetadata.getOptions().waitForReady) {\n          this.pushPick(callStream, callMetadata, callConfig);\n        } else {\n          callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);\n        }\n\n        break;\n\n      case picker_1.PickResultType.DROP:\n        callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);\n        break;\n\n      default:\n        throw new Error(`Invalid state: unknown pickResultType ${pickResult.pickResultType}`);\n    }\n  }\n\n  removeConnectivityStateWatcher(watcherObject) {\n    const watcherIndex = this.connectivityStateWatchers.findIndex(value => value === watcherObject);\n\n    if (watcherIndex >= 0) {\n      this.connectivityStateWatchers.splice(watcherIndex, 1);\n    }\n  }\n\n  updateState(newState) {\n    logging_1.trace(constants_1.LogVerbosity.DEBUG, 'connectivity_state', uri_parser_1.uriToString(this.target) + ' ' + ConnectivityState[this.connectivityState] + ' -> ' + ConnectivityState[newState]);\n    this.connectivityState = newState;\n    const watchersCopy = this.connectivityStateWatchers.slice();\n\n    for (const watcherObject of watchersCopy) {\n      if (newState !== watcherObject.currentState) {\n        if (watcherObject.timer) {\n          clearTimeout(watcherObject.timer);\n        }\n\n        this.removeConnectivityStateWatcher(watcherObject);\n        watcherObject.callback();\n      }\n    }\n  }\n\n  tryGetConfig(stream, metadata) {\n    if (this.configSelector === null) {\n      /* This branch will only be taken at the beginning of the channel's life,\n       * before the resolver ever returns a result. So, the\n       * ResolvingLoadBalancer may be idle and if so it needs to be kicked\n       * because it now has a pending request. */\n      this.resolvingLoadBalancer.exitIdle();\n      this.configSelectionQueue.push({\n        callStream: stream,\n        callMetadata: metadata\n      });\n      this.callRefTimerRef();\n    } else {\n      const callConfig = this.configSelector(stream.getMethod(), metadata);\n\n      if (callConfig.status === constants_1.Status.OK) {\n        this.tryPick(stream, metadata, callConfig);\n      } else {\n        stream.cancelWithStatus(callConfig.status, \"Failed to route call to method \" + stream.getMethod());\n      }\n    }\n  }\n\n  _startCallStream(stream, metadata) {\n    this.tryGetConfig(stream, metadata.clone());\n  }\n\n  close() {\n    this.resolvingLoadBalancer.destroy();\n    this.updateState(ConnectivityState.SHUTDOWN);\n    clearInterval(this.callRefTimer);\n    this.subchannelPool.unrefUnusedSubchannels();\n  }\n\n  getTarget() {\n    return uri_parser_1.uriToString(this.target);\n  }\n\n  getConnectivityState(tryToConnect) {\n    const connectivityState = this.connectivityState;\n\n    if (tryToConnect) {\n      this.resolvingLoadBalancer.exitIdle();\n    }\n\n    return connectivityState;\n  }\n\n  watchConnectivityState(currentState, deadline, callback) {\n    if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n\n    let timer = null;\n\n    if (deadline !== Infinity) {\n      const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);\n      const now = new Date();\n\n      if (deadline === -Infinity || deadlineDate <= now) {\n        process.nextTick(callback, new Error('Deadline passed without connectivity state change'));\n        return;\n      }\n\n      timer = setTimeout(() => {\n        this.removeConnectivityStateWatcher(watcherObject);\n        callback(new Error('Deadline passed without connectivity state change'));\n      }, deadlineDate.getTime() - now.getTime());\n    }\n\n    const watcherObject = {\n      currentState,\n      callback,\n      timer\n    };\n    this.connectivityStateWatchers.push(watcherObject);\n  }\n\n  createCall(method, deadline, host, parentCall, propagateFlags) {\n    if (typeof method !== 'string') {\n      throw new TypeError('Channel#createCall: method must be a string');\n    }\n\n    if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n      throw new TypeError('Channel#createCall: deadline must be a number or Date');\n    }\n\n    if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n\n    const callNumber = getNewCallNumber();\n    logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', uri_parser_1.uriToString(this.target) + ' createCall [' + callNumber + '] method=\"' + method + '\", deadline=' + deadline);\n    const finalOptions = {\n      deadline: deadline,\n      flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,\n      host: host !== null && host !== void 0 ? host : this.defaultAuthority,\n      parentCall: parentCall\n    };\n    const stream = new call_stream_1.Http2CallStream(method, this, finalOptions, this.filterStackFactory, this.credentials._getCallCredentials(), callNumber);\n    return stream;\n  }\n\n}\n\nexports.ChannelImplementation = ChannelImplementation; //# sourceMappingURL=channel.js.map","map":null,"metadata":{},"sourceType":"script"}