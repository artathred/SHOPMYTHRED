{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar _asyncToGenerator = require(\"/Users/artakoroushnia/Desktop/thred-web/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CompressionFilterFactory = exports.CompressionFilter = void 0;\n\nconst zlib = require(\"zlib\");\n\nconst filter_1 = require(\"./filter\");\n\nclass CompressionHandler {\n  /**\n   * @param message Raw uncompressed message bytes\n   * @param compress Indicates whether the message should be compressed\n   * @return Framed message, compressed if applicable\n   */\n  writeMessage(message, compress) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      let messageBuffer = message;\n\n      if (compress) {\n        messageBuffer = yield _this.compressMessage(messageBuffer);\n      }\n\n      const output = Buffer.allocUnsafe(messageBuffer.length + 5);\n      output.writeUInt8(compress ? 1 : 0, 0);\n      output.writeUInt32BE(messageBuffer.length, 1);\n      messageBuffer.copy(output, 5);\n      return output;\n    })();\n  }\n  /**\n   * @param data Framed message, possibly compressed\n   * @return Uncompressed message\n   */\n\n\n  readMessage(data) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const compressed = data.readUInt8(0) === 1;\n      let messageBuffer = data.slice(5);\n\n      if (compressed) {\n        messageBuffer = yield _this2.decompressMessage(messageBuffer);\n      }\n\n      return messageBuffer;\n    })();\n  }\n\n}\n\nclass IdentityHandler extends CompressionHandler {\n  compressMessage(message) {\n    return _asyncToGenerator(function* () {\n      return message;\n    })();\n  }\n\n  writeMessage(message, compress) {\n    return _asyncToGenerator(function* () {\n      const output = Buffer.allocUnsafe(message.length + 5);\n      /* With \"identity\" compression, messages should always be marked as\n       * uncompressed */\n\n      output.writeUInt8(0, 0);\n      output.writeUInt32BE(message.length, 1);\n      message.copy(output, 5);\n      return output;\n    })();\n  }\n\n  decompressMessage(message) {\n    return Promise.reject(new Error('Received compressed message but \"grpc-encoding\" header was identity'));\n  }\n\n}\n\nclass DeflateHandler extends CompressionHandler {\n  compressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.deflate(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n\n  decompressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.inflate(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n\n}\n\nclass GzipHandler extends CompressionHandler {\n  compressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.gzip(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n\n  decompressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.unzip(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n\n}\n\nclass UnknownHandler extends CompressionHandler {\n  constructor(compressionName) {\n    super();\n    this.compressionName = compressionName;\n  }\n\n  compressMessage(message) {\n    return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));\n  }\n\n  decompressMessage(message) {\n    // This should be unreachable\n    return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));\n  }\n\n}\n\nfunction getCompressionHandler(compressionName) {\n  switch (compressionName) {\n    case 'identity':\n      return new IdentityHandler();\n\n    case 'deflate':\n      return new DeflateHandler();\n\n    case 'gzip':\n      return new GzipHandler();\n\n    default:\n      return new UnknownHandler(compressionName);\n  }\n}\n\nclass CompressionFilter extends filter_1.BaseFilter {\n  constructor() {\n    super(...arguments);\n    this.sendCompression = new IdentityHandler();\n    this.receiveCompression = new IdentityHandler();\n  }\n\n  sendMetadata(metadata) {\n    return _asyncToGenerator(function* () {\n      const headers = yield metadata;\n      headers.set('grpc-accept-encoding', 'identity,deflate,gzip');\n      headers.set('accept-encoding', 'identity');\n      return headers;\n    })();\n  }\n\n  receiveMetadata(metadata) {\n    const receiveEncoding = metadata.get('grpc-encoding');\n\n    if (receiveEncoding.length > 0) {\n      const encoding = receiveEncoding[0];\n\n      if (typeof encoding === 'string') {\n        this.receiveCompression = getCompressionHandler(encoding);\n      }\n    }\n\n    metadata.remove('grpc-encoding');\n    metadata.remove('grpc-accept-encoding');\n    return metadata;\n  }\n\n  sendMessage(message) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      /* This filter is special. The input message is the bare message bytes,\n       * and the output is a framed and possibly compressed message. For this\n       * reason, this filter should be at the bottom of the filter stack */\n      const resolvedMessage = yield message;\n      const compress = resolvedMessage.flags === undefined ? false : (resolvedMessage.flags & 2\n      /* NoCompress */\n      ) === 0;\n      return {\n        message: yield _this3.sendCompression.writeMessage(resolvedMessage.message, compress),\n        flags: resolvedMessage.flags\n      };\n    })();\n  }\n\n  receiveMessage(message) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      /* This filter is also special. The input message is framed and possibly\n       * compressed, and the output message is deframed and uncompressed. So\n       * this is another reason that this filter should be at the bottom of the\n       * filter stack. */\n      return _this4.receiveCompression.readMessage(yield message);\n    })();\n  }\n\n}\n\nexports.CompressionFilter = CompressionFilter;\n\nclass CompressionFilterFactory {\n  constructor(channel) {\n    this.channel = channel;\n  }\n\n  createFilter(callStream) {\n    return new CompressionFilter();\n  }\n\n}\n\nexports.CompressionFilterFactory = CompressionFilterFactory; //# sourceMappingURL=compression-filter.js.map","map":{"version":3,"sources":["/Users/artakoroushnia/Desktop/thred-web/node_modules/@grpc/grpc-js/build/src/compression-filter.js"],"names":["Object","defineProperty","exports","value","CompressionFilterFactory","CompressionFilter","zlib","require","filter_1","CompressionHandler","writeMessage","message","compress","messageBuffer","compressMessage","output","Buffer","allocUnsafe","length","writeUInt8","writeUInt32BE","copy","readMessage","data","compressed","readUInt8","slice","decompressMessage","IdentityHandler","Promise","reject","Error","DeflateHandler","resolve","deflate","err","inflate","GzipHandler","gzip","unzip","UnknownHandler","constructor","compressionName","getCompressionHandler","BaseFilter","arguments","sendCompression","receiveCompression","sendMetadata","metadata","headers","set","receiveMetadata","receiveEncoding","get","encoding","remove","sendMessage","resolvedMessage","flags","undefined","receiveMessage","channel","createFilter","callStream"],"mappings":"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","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CompressionFilterFactory = exports.CompressionFilter = void 0;\nconst zlib = require(\"zlib\");\nconst filter_1 = require(\"./filter\");\nclass CompressionHandler {\n    /**\n     * @param message Raw uncompressed message bytes\n     * @param compress Indicates whether the message should be compressed\n     * @return Framed message, compressed if applicable\n     */\n    async writeMessage(message, compress) {\n        let messageBuffer = message;\n        if (compress) {\n            messageBuffer = await this.compressMessage(messageBuffer);\n        }\n        const output = Buffer.allocUnsafe(messageBuffer.length + 5);\n        output.writeUInt8(compress ? 1 : 0, 0);\n        output.writeUInt32BE(messageBuffer.length, 1);\n        messageBuffer.copy(output, 5);\n        return output;\n    }\n    /**\n     * @param data Framed message, possibly compressed\n     * @return Uncompressed message\n     */\n    async readMessage(data) {\n        const compressed = data.readUInt8(0) === 1;\n        let messageBuffer = data.slice(5);\n        if (compressed) {\n            messageBuffer = await this.decompressMessage(messageBuffer);\n        }\n        return messageBuffer;\n    }\n}\nclass IdentityHandler extends CompressionHandler {\n    async compressMessage(message) {\n        return message;\n    }\n    async writeMessage(message, compress) {\n        const output = Buffer.allocUnsafe(message.length + 5);\n        /* With \"identity\" compression, messages should always be marked as\n         * uncompressed */\n        output.writeUInt8(0, 0);\n        output.writeUInt32BE(message.length, 1);\n        message.copy(output, 5);\n        return output;\n    }\n    decompressMessage(message) {\n        return Promise.reject(new Error('Received compressed message but \"grpc-encoding\" header was identity'));\n    }\n}\nclass DeflateHandler extends CompressionHandler {\n    compressMessage(message) {\n        return new Promise((resolve, reject) => {\n            zlib.deflate(message, (err, output) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n    decompressMessage(message) {\n        return new Promise((resolve, reject) => {\n            zlib.inflate(message, (err, output) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n}\nclass GzipHandler extends CompressionHandler {\n    compressMessage(message) {\n        return new Promise((resolve, reject) => {\n            zlib.gzip(message, (err, output) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n    decompressMessage(message) {\n        return new Promise((resolve, reject) => {\n            zlib.unzip(message, (err, output) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n}\nclass UnknownHandler extends CompressionHandler {\n    constructor(compressionName) {\n        super();\n        this.compressionName = compressionName;\n    }\n    compressMessage(message) {\n        return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));\n    }\n    decompressMessage(message) {\n        // This should be unreachable\n        return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));\n    }\n}\nfunction getCompressionHandler(compressionName) {\n    switch (compressionName) {\n        case 'identity':\n            return new IdentityHandler();\n        case 'deflate':\n            return new DeflateHandler();\n        case 'gzip':\n            return new GzipHandler();\n        default:\n            return new UnknownHandler(compressionName);\n    }\n}\nclass CompressionFilter extends filter_1.BaseFilter {\n    constructor() {\n        super(...arguments);\n        this.sendCompression = new IdentityHandler();\n        this.receiveCompression = new IdentityHandler();\n    }\n    async sendMetadata(metadata) {\n        const headers = await metadata;\n        headers.set('grpc-accept-encoding', 'identity,deflate,gzip');\n        headers.set('accept-encoding', 'identity');\n        return headers;\n    }\n    receiveMetadata(metadata) {\n        const receiveEncoding = metadata.get('grpc-encoding');\n        if (receiveEncoding.length > 0) {\n            const encoding = receiveEncoding[0];\n            if (typeof encoding === 'string') {\n                this.receiveCompression = getCompressionHandler(encoding);\n            }\n        }\n        metadata.remove('grpc-encoding');\n        metadata.remove('grpc-accept-encoding');\n        return metadata;\n    }\n    async sendMessage(message) {\n        /* This filter is special. The input message is the bare message bytes,\n         * and the output is a framed and possibly compressed message. For this\n         * reason, this filter should be at the bottom of the filter stack */\n        const resolvedMessage = await message;\n        const compress = resolvedMessage.flags === undefined\n            ? false\n            : (resolvedMessage.flags & 2 /* NoCompress */) === 0;\n        return {\n            message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),\n            flags: resolvedMessage.flags,\n        };\n    }\n    async receiveMessage(message) {\n        /* This filter is also special. The input message is framed and possibly\n         * compressed, and the output message is deframed and uncompressed. So\n         * this is another reason that this filter should be at the bottom of the\n         * filter stack. */\n        return this.receiveCompression.readMessage(await message);\n    }\n}\nexports.CompressionFilter = CompressionFilter;\nclass CompressionFilterFactory {\n    constructor(channel) {\n        this.channel = channel;\n    }\n    createFilter(callStream) {\n        return new CompressionFilter();\n    }\n}\nexports.CompressionFilterFactory = CompressionFilterFactory;\n//# sourceMappingURL=compression-filter.js.map"]},"metadata":{},"sourceType":"script"}