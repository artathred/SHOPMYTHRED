{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar _asyncToGenerator = require(\"/Users/artakoroushnia/Desktop/thred-web/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Http2ServerCallStream = exports.ServerDuplexStreamImpl = exports.ServerWritableStreamImpl = exports.ServerReadableStreamImpl = exports.ServerUnaryCallImpl = void 0;\n\nconst events_1 = require(\"events\");\n\nconst http2 = require(\"http2\");\n\nconst stream_1 = require(\"stream\");\n\nconst constants_1 = require(\"./constants\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst stream_decoder_1 = require(\"./stream-decoder\");\n\nconst logging = require(\"./logging\");\n\nconst TRACER_NAME = 'server_call';\n\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nconst GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';\nconst GRPC_ENCODING_HEADER = 'grpc-encoding';\nconst GRPC_MESSAGE_HEADER = 'grpc-message';\nconst GRPC_STATUS_HEADER = 'grpc-status';\nconst GRPC_TIMEOUT_HEADER = 'grpc-timeout';\nconst DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\nconst deadlineUnitsToMs = {\n  H: 3600000,\n  M: 60000,\n  S: 1000,\n  m: 1,\n  u: 0.001,\n  n: 0.000001\n};\nconst defaultResponseHeaders = {\n  // TODO(cjihrig): Remove these encoding headers from the default response\n  // once compression is integrated.\n  [GRPC_ACCEPT_ENCODING_HEADER]: 'identity',\n  [GRPC_ENCODING_HEADER]: 'identity',\n  [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n  [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto'\n};\nconst defaultResponseOptions = {\n  waitForTrailers: true\n};\n\nclass ServerUnaryCallImpl extends events_1.EventEmitter {\n  constructor(call, metadata, request) {\n    super();\n    this.call = call;\n    this.metadata = metadata;\n    this.request = request;\n    this.cancelled = false;\n    this.call.setupSurfaceCall(this);\n  }\n\n  getPeer() {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline() {\n    return this.call.getDeadline();\n  }\n\n}\n\nexports.ServerUnaryCallImpl = ServerUnaryCallImpl;\n\nclass ServerReadableStreamImpl extends stream_1.Readable {\n  constructor(call, metadata, deserialize) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.metadata = metadata;\n    this.deserialize = deserialize;\n    this.cancelled = false;\n    this.call.setupSurfaceCall(this);\n    this.call.setupReadable(this);\n  }\n\n  _read(size) {\n    if (!this.call.consumeUnpushedMessages(this)) {\n      return;\n    }\n\n    this.call.resume();\n  }\n\n  getPeer() {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline() {\n    return this.call.getDeadline();\n  }\n\n}\n\nexports.ServerReadableStreamImpl = ServerReadableStreamImpl;\n\nclass ServerWritableStreamImpl extends stream_1.Writable {\n  constructor(call, metadata, serialize, request) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.metadata = metadata;\n    this.serialize = serialize;\n    this.request = request;\n    this.cancelled = false;\n    this.trailingMetadata = new metadata_1.Metadata();\n    this.call.setupSurfaceCall(this);\n    this.on('error', err => {\n      this.call.sendError(err);\n      this.end();\n    });\n  }\n\n  getPeer() {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline() {\n    return this.call.getDeadline();\n  }\n\n  _write(chunk, encoding, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  callback) {\n    try {\n      const response = this.call.serializeMessage(chunk);\n\n      if (!this.call.write(response)) {\n        this.call.once('drain', callback);\n        return;\n      }\n    } catch (err) {\n      err.code = constants_1.Status.INTERNAL;\n      this.emit('error', err);\n    }\n\n    callback();\n  }\n\n  _final(callback) {\n    this.call.sendStatus({\n      code: constants_1.Status.OK,\n      details: 'OK',\n      metadata: this.trailingMetadata\n    });\n    callback(null);\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  end(metadata) {\n    if (metadata) {\n      this.trailingMetadata = metadata;\n    }\n\n    super.end();\n  }\n\n}\n\nexports.ServerWritableStreamImpl = ServerWritableStreamImpl;\n\nclass ServerDuplexStreamImpl extends stream_1.Duplex {\n  constructor(call, metadata, serialize, deserialize) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.metadata = metadata;\n    this.serialize = serialize;\n    this.deserialize = deserialize;\n    this.cancelled = false;\n    this.trailingMetadata = new metadata_1.Metadata();\n    this.call.setupSurfaceCall(this);\n    this.call.setupReadable(this);\n    this.on('error', err => {\n      this.call.sendError(err);\n      this.end();\n    });\n  }\n\n  getPeer() {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline() {\n    return this.call.getDeadline();\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  end(metadata) {\n    if (metadata) {\n      this.trailingMetadata = metadata;\n    }\n\n    super.end();\n  }\n\n}\n\nexports.ServerDuplexStreamImpl = ServerDuplexStreamImpl;\nServerDuplexStreamImpl.prototype._read = ServerReadableStreamImpl.prototype._read;\nServerDuplexStreamImpl.prototype._write = ServerWritableStreamImpl.prototype._write;\nServerDuplexStreamImpl.prototype._final = ServerWritableStreamImpl.prototype._final;\nServerDuplexStreamImpl.prototype.end = ServerWritableStreamImpl.prototype.end; // Internal class that wraps the HTTP2 request.\n\nclass Http2ServerCallStream extends events_1.EventEmitter {\n  constructor(stream, handler, options) {\n    super();\n    this.stream = stream;\n    this.handler = handler;\n    this.options = options;\n    this.cancelled = false;\n    this.deadlineTimer = setTimeout(() => {}, 0);\n    this.deadline = Infinity;\n    this.wantTrailers = false;\n    this.metadataSent = false;\n    this.canPush = false;\n    this.isPushPending = false;\n    this.bufferedMessages = [];\n    this.messagesToPush = [];\n    this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n    this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n    this.stream.once('error', err => {\n      /* We need an error handler to avoid uncaught error event exceptions, but\n       * there is nothing we can reasonably do here. Any error event should\n       * have a corresponding close event, which handles emitting the cancelled\n       * event. And the stream is now in a bad state, so we can't reasonably\n       * expect to be able to send an error over it. */\n    });\n    this.stream.once('close', () => {\n      var _a;\n\n      trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + ' stream closed with rstCode ' + this.stream.rstCode);\n      this.cancelled = true;\n      this.emit('cancelled', 'cancelled');\n    });\n    this.stream.on('drain', () => {\n      this.emit('drain');\n    });\n\n    if ('grpc.max_send_message_length' in options) {\n      this.maxSendMessageSize = options['grpc.max_send_message_length'];\n    }\n\n    if ('grpc.max_receive_message_length' in options) {\n      this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];\n    } // Clear noop timer\n\n\n    clearTimeout(this.deadlineTimer);\n  }\n\n  checkCancelled() {\n    /* In some cases the stream can become destroyed before the close event\n     * fires. That creates a race condition that this check works around */\n    if (this.stream.destroyed) {\n      this.cancelled = true;\n    }\n\n    return this.cancelled;\n  }\n\n  sendMetadata(customMetadata) {\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    if (this.metadataSent) {\n      return;\n    }\n\n    this.metadataSent = true;\n    const custom = customMetadata ? customMetadata.toHttp2Headers() : null; // TODO(cjihrig): Include compression headers.\n\n    const headers = Object.assign({}, defaultResponseHeaders, custom);\n    this.stream.respond(headers, defaultResponseOptions);\n  }\n\n  receiveMetadata(headers) {\n    const metadata = metadata_1.Metadata.fromHttp2Headers(headers); // TODO(cjihrig): Receive compression metadata.\n\n    const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\n\n    if (timeoutHeader.length > 0) {\n      const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);\n\n      if (match === null) {\n        const err = new Error('Invalid deadline');\n        err.code = constants_1.Status.OUT_OF_RANGE;\n        this.sendError(err);\n        return;\n      }\n\n      const timeout = +match[1] * deadlineUnitsToMs[match[2]] | 0;\n      const now = new Date();\n      this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);\n      this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);\n      metadata.remove(GRPC_TIMEOUT_HEADER);\n    } // Remove several headers that should not be propagated to the application\n\n\n    metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\n    metadata.remove(http2.constants.HTTP2_HEADER_TE);\n    metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\n    metadata.remove('grpc-encoding');\n    metadata.remove('grpc-accept-encoding');\n    return metadata;\n  }\n\n  receiveUnaryMessage() {\n    var _this = this;\n\n    return new Promise((resolve, reject) => {\n      const stream = this.stream;\n      const chunks = [];\n      let totalLength = 0;\n      stream.on('data', data => {\n        chunks.push(data);\n        totalLength += data.byteLength;\n      });\n      stream.once('end', /*#__PURE__*/_asyncToGenerator(function* () {\n        try {\n          const requestBytes = Buffer.concat(chunks, totalLength);\n\n          if (_this.maxReceiveMessageSize !== -1 && requestBytes.length > _this.maxReceiveMessageSize) {\n            _this.sendError({\n              code: constants_1.Status.RESOURCE_EXHAUSTED,\n              details: `Received message larger than max (${requestBytes.length} vs. ${_this.maxReceiveMessageSize})`\n            });\n\n            resolve();\n          }\n\n          resolve(_this.deserializeMessage(requestBytes));\n        } catch (err) {\n          err.code = constants_1.Status.INTERNAL;\n\n          _this.sendError(err);\n\n          resolve();\n        }\n      }));\n    });\n  }\n\n  serializeMessage(value) {\n    const messageBuffer = this.handler.serialize(value); // TODO(cjihrig): Call compression aware serializeMessage().\n\n    const byteLength = messageBuffer.byteLength;\n    const output = Buffer.allocUnsafe(byteLength + 5);\n    output.writeUInt8(0, 0);\n    output.writeUInt32BE(byteLength, 1);\n    messageBuffer.copy(output, 5);\n    return output;\n  }\n\n  deserializeMessage(bytes) {\n    // TODO(cjihrig): Call compression aware deserializeMessage().\n    const receivedMessage = bytes.slice(5);\n    return this.handler.deserialize(receivedMessage);\n  }\n\n  sendUnaryMessage(err, value, metadata, flags) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this2.checkCancelled()) {\n        return;\n      }\n\n      if (!metadata) {\n        metadata = new metadata_1.Metadata();\n      }\n\n      if (err) {\n        if (!Object.prototype.hasOwnProperty.call(err, 'metadata')) {\n          err.metadata = metadata;\n        }\n\n        _this2.sendError(err);\n\n        return;\n      }\n\n      try {\n        const response = _this2.serializeMessage(value);\n\n        _this2.write(response);\n\n        _this2.sendStatus({\n          code: constants_1.Status.OK,\n          details: 'OK',\n          metadata\n        });\n      } catch (err) {\n        err.code = constants_1.Status.INTERNAL;\n\n        _this2.sendError(err);\n      }\n    })();\n  }\n\n  sendStatus(statusObj) {\n    var _a;\n\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + ' ended with status code: ' + constants_1.Status[statusObj.code] + ' details: ' + statusObj.details);\n    clearTimeout(this.deadlineTimer);\n\n    if (!this.wantTrailers) {\n      this.wantTrailers = true;\n      this.stream.once('wantTrailers', () => {\n        const trailersToSend = Object.assign({\n          [GRPC_STATUS_HEADER]: statusObj.code,\n          [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details)\n        }, statusObj.metadata.toHttp2Headers());\n        this.stream.sendTrailers(trailersToSend);\n      });\n      this.sendMetadata();\n      this.stream.end();\n    }\n  }\n\n  sendError(error) {\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    const status = {\n      code: constants_1.Status.UNKNOWN,\n      details: 'message' in error ? error.message : 'Unknown Error',\n      metadata: 'metadata' in error && error.metadata !== undefined ? error.metadata : new metadata_1.Metadata()\n    };\n\n    if ('code' in error && typeof error.code === 'number' && Number.isInteger(error.code)) {\n      status.code = error.code;\n\n      if ('details' in error && typeof error.details === 'string') {\n        status.details = error.details;\n      }\n    }\n\n    this.sendStatus(status);\n  }\n\n  write(chunk) {\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    if (this.maxSendMessageSize !== -1 && chunk.length > this.maxSendMessageSize) {\n      this.sendError({\n        code: constants_1.Status.RESOURCE_EXHAUSTED,\n        details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`\n      });\n      return;\n    }\n\n    this.sendMetadata();\n    return this.stream.write(chunk);\n  }\n\n  resume() {\n    this.stream.resume();\n  }\n\n  setupSurfaceCall(call) {\n    this.once('cancelled', reason => {\n      call.cancelled = true;\n      call.emit('cancelled', reason);\n    });\n  }\n\n  setupReadable(readable) {\n    var _this3 = this;\n\n    const decoder = new stream_decoder_1.StreamDecoder();\n    this.stream.on('data', /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (data) {\n        const messages = decoder.write(data);\n\n        for (const message of messages) {\n          if (_this3.maxReceiveMessageSize !== -1 && message.length > _this3.maxReceiveMessageSize) {\n            _this3.sendError({\n              code: constants_1.Status.RESOURCE_EXHAUSTED,\n              details: `Received message larger than max (${message.length} vs. ${_this3.maxReceiveMessageSize})`\n            });\n\n            return;\n          }\n\n          _this3.pushOrBufferMessage(readable, message);\n        }\n      });\n\n      return function (_x) {\n        return _ref2.apply(this, arguments);\n      };\n    }());\n    this.stream.once('end', () => {\n      this.pushOrBufferMessage(readable, null);\n    });\n  }\n\n  consumeUnpushedMessages(readable) {\n    this.canPush = true;\n\n    while (this.messagesToPush.length > 0) {\n      const nextMessage = this.messagesToPush.shift();\n      const canPush = readable.push(nextMessage);\n\n      if (nextMessage === null || canPush === false) {\n        this.canPush = false;\n        break;\n      }\n    }\n\n    return this.canPush;\n  }\n\n  pushOrBufferMessage(readable, messageBytes) {\n    if (this.isPushPending) {\n      this.bufferedMessages.push(messageBytes);\n    } else {\n      this.pushMessage(readable, messageBytes);\n    }\n  }\n\n  pushMessage(readable, messageBytes) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      if (messageBytes === null) {\n        if (_this4.canPush) {\n          readable.push(null);\n        } else {\n          _this4.messagesToPush.push(null);\n        }\n\n        return;\n      }\n\n      _this4.isPushPending = true;\n\n      try {\n        const deserialized = yield _this4.deserializeMessage(messageBytes);\n\n        if (_this4.canPush) {\n          if (!readable.push(deserialized)) {\n            _this4.canPush = false;\n\n            _this4.stream.pause();\n          }\n        } else {\n          _this4.messagesToPush.push(deserialized);\n        }\n      } catch (error) {\n        // Ignore any remaining messages when errors occur.\n        _this4.bufferedMessages.length = 0;\n\n        if (!('code' in error && typeof error.code === 'number' && Number.isInteger(error.code) && error.code >= constants_1.Status.OK && error.code <= constants_1.Status.UNAUTHENTICATED)) {\n          // The error code is not a valid gRPC code so its being overwritten.\n          error.code = constants_1.Status.INTERNAL;\n        }\n\n        readable.emit('error', error);\n      }\n\n      _this4.isPushPending = false;\n\n      if (_this4.bufferedMessages.length > 0) {\n        _this4.pushMessage(readable, _this4.bufferedMessages.shift());\n      }\n    })();\n  }\n\n  getPeer() {\n    const socket = this.stream.session.socket;\n\n    if (socket.remoteAddress) {\n      if (socket.remotePort) {\n        return `${socket.remoteAddress}:${socket.remotePort}`;\n      } else {\n        return socket.remoteAddress;\n      }\n    } else {\n      return 'unknown';\n    }\n  }\n\n  getDeadline() {\n    return this.deadline;\n  }\n\n}\n\nexports.Http2ServerCallStream = Http2ServerCallStream;\n\nfunction handleExpiredDeadline(call) {\n  const err = new Error('Deadline exceeded');\n  err.code = constants_1.Status.DEADLINE_EXCEEDED;\n  call.sendError(err);\n  call.cancelled = true;\n  call.emit('cancelled', 'deadline');\n} //# sourceMappingURL=server-call.js.map","map":{"version":3,"sources":["/Users/artakoroushnia/Desktop/thred-web/node_modules/@grpc/grpc-js/build/src/server-call.js"],"names":["Object","defineProperty","exports","value","Http2ServerCallStream","ServerDuplexStreamImpl","ServerWritableStreamImpl","ServerReadableStreamImpl","ServerUnaryCallImpl","events_1","require","http2","stream_1","constants_1","metadata_1","stream_decoder_1","logging","TRACER_NAME","trace","text","LogVerbosity","DEBUG","GRPC_ACCEPT_ENCODING_HEADER","GRPC_ENCODING_HEADER","GRPC_MESSAGE_HEADER","GRPC_STATUS_HEADER","GRPC_TIMEOUT_HEADER","DEADLINE_REGEX","deadlineUnitsToMs","H","M","S","m","u","n","defaultResponseHeaders","constants","HTTP2_HEADER_STATUS","HTTP_STATUS_OK","HTTP2_HEADER_CONTENT_TYPE","defaultResponseOptions","waitForTrailers","EventEmitter","constructor","call","metadata","request","cancelled","setupSurfaceCall","getPeer","sendMetadata","responseMetadata","getDeadline","Readable","deserialize","objectMode","setupReadable","_read","size","consumeUnpushedMessages","resume","Writable","serialize","trailingMetadata","Metadata","on","err","sendError","end","_write","chunk","encoding","callback","response","serializeMessage","write","once","code","Status","INTERNAL","emit","_final","sendStatus","OK","details","Duplex","prototype","stream","handler","options","deadlineTimer","setTimeout","deadline","Infinity","wantTrailers","metadataSent","canPush","isPushPending","bufferedMessages","messagesToPush","maxSendMessageSize","DEFAULT_MAX_SEND_MESSAGE_LENGTH","maxReceiveMessageSize","DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH","_a","path","rstCode","clearTimeout","checkCancelled","destroyed","customMetadata","custom","toHttp2Headers","headers","assign","respond","receiveMetadata","fromHttp2Headers","timeoutHeader","get","length","match","toString","Error","OUT_OF_RANGE","timeout","now","Date","setMilliseconds","getMilliseconds","handleExpiredDeadline","remove","HTTP2_HEADER_ACCEPT_ENCODING","HTTP2_HEADER_TE","receiveUnaryMessage","Promise","resolve","reject","chunks","totalLength","data","push","byteLength","requestBytes","Buffer","concat","RESOURCE_EXHAUSTED","deserializeMessage","messageBuffer","output","allocUnsafe","writeUInt8","writeUInt32BE","copy","bytes","receivedMessage","slice","sendUnaryMessage","flags","hasOwnProperty","statusObj","trailersToSend","encodeURI","sendTrailers","error","status","UNKNOWN","message","undefined","Number","isInteger","reason","readable","decoder","StreamDecoder","messages","pushOrBufferMessage","nextMessage","shift","messageBytes","pushMessage","deserialized","pause","UNAUTHENTICATED","socket","session","remoteAddress","remotePort","DEADLINE_EXCEEDED"],"mappings":"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","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Http2ServerCallStream = exports.ServerDuplexStreamImpl = exports.ServerWritableStreamImpl = exports.ServerReadableStreamImpl = exports.ServerUnaryCallImpl = void 0;\nconst events_1 = require(\"events\");\nconst http2 = require(\"http2\");\nconst stream_1 = require(\"stream\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst stream_decoder_1 = require(\"./stream-decoder\");\nconst logging = require(\"./logging\");\nconst TRACER_NAME = 'server_call';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';\nconst GRPC_ENCODING_HEADER = 'grpc-encoding';\nconst GRPC_MESSAGE_HEADER = 'grpc-message';\nconst GRPC_STATUS_HEADER = 'grpc-status';\nconst GRPC_TIMEOUT_HEADER = 'grpc-timeout';\nconst DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\nconst deadlineUnitsToMs = {\n    H: 3600000,\n    M: 60000,\n    S: 1000,\n    m: 1,\n    u: 0.001,\n    n: 0.000001,\n};\nconst defaultResponseHeaders = {\n    // TODO(cjihrig): Remove these encoding headers from the default response\n    // once compression is integrated.\n    [GRPC_ACCEPT_ENCODING_HEADER]: 'identity',\n    [GRPC_ENCODING_HEADER]: 'identity',\n    [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n    [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto',\n};\nconst defaultResponseOptions = {\n    waitForTrailers: true,\n};\nclass ServerUnaryCallImpl extends events_1.EventEmitter {\n    constructor(call, metadata, request) {\n        super();\n        this.call = call;\n        this.metadata = metadata;\n        this.request = request;\n        this.cancelled = false;\n        this.call.setupSurfaceCall(this);\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n}\nexports.ServerUnaryCallImpl = ServerUnaryCallImpl;\nclass ServerReadableStreamImpl extends stream_1.Readable {\n    constructor(call, metadata, deserialize) {\n        super({ objectMode: true });\n        this.call = call;\n        this.metadata = metadata;\n        this.deserialize = deserialize;\n        this.cancelled = false;\n        this.call.setupSurfaceCall(this);\n        this.call.setupReadable(this);\n    }\n    _read(size) {\n        if (!this.call.consumeUnpushedMessages(this)) {\n            return;\n        }\n        this.call.resume();\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n}\nexports.ServerReadableStreamImpl = ServerReadableStreamImpl;\nclass ServerWritableStreamImpl extends stream_1.Writable {\n    constructor(call, metadata, serialize, request) {\n        super({ objectMode: true });\n        this.call = call;\n        this.metadata = metadata;\n        this.serialize = serialize;\n        this.request = request;\n        this.cancelled = false;\n        this.trailingMetadata = new metadata_1.Metadata();\n        this.call.setupSurfaceCall(this);\n        this.on('error', (err) => {\n            this.call.sendError(err);\n            this.end();\n        });\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    _write(chunk, encoding, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callback) {\n        try {\n            const response = this.call.serializeMessage(chunk);\n            if (!this.call.write(response)) {\n                this.call.once('drain', callback);\n                return;\n            }\n        }\n        catch (err) {\n            err.code = constants_1.Status.INTERNAL;\n            this.emit('error', err);\n        }\n        callback();\n    }\n    _final(callback) {\n        this.call.sendStatus({\n            code: constants_1.Status.OK,\n            details: 'OK',\n            metadata: this.trailingMetadata,\n        });\n        callback(null);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    end(metadata) {\n        if (metadata) {\n            this.trailingMetadata = metadata;\n        }\n        super.end();\n    }\n}\nexports.ServerWritableStreamImpl = ServerWritableStreamImpl;\nclass ServerDuplexStreamImpl extends stream_1.Duplex {\n    constructor(call, metadata, serialize, deserialize) {\n        super({ objectMode: true });\n        this.call = call;\n        this.metadata = metadata;\n        this.serialize = serialize;\n        this.deserialize = deserialize;\n        this.cancelled = false;\n        this.trailingMetadata = new metadata_1.Metadata();\n        this.call.setupSurfaceCall(this);\n        this.call.setupReadable(this);\n        this.on('error', (err) => {\n            this.call.sendError(err);\n            this.end();\n        });\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    end(metadata) {\n        if (metadata) {\n            this.trailingMetadata = metadata;\n        }\n        super.end();\n    }\n}\nexports.ServerDuplexStreamImpl = ServerDuplexStreamImpl;\nServerDuplexStreamImpl.prototype._read =\n    ServerReadableStreamImpl.prototype._read;\nServerDuplexStreamImpl.prototype._write =\n    ServerWritableStreamImpl.prototype._write;\nServerDuplexStreamImpl.prototype._final =\n    ServerWritableStreamImpl.prototype._final;\nServerDuplexStreamImpl.prototype.end = ServerWritableStreamImpl.prototype.end;\n// Internal class that wraps the HTTP2 request.\nclass Http2ServerCallStream extends events_1.EventEmitter {\n    constructor(stream, handler, options) {\n        super();\n        this.stream = stream;\n        this.handler = handler;\n        this.options = options;\n        this.cancelled = false;\n        this.deadlineTimer = setTimeout(() => { }, 0);\n        this.deadline = Infinity;\n        this.wantTrailers = false;\n        this.metadataSent = false;\n        this.canPush = false;\n        this.isPushPending = false;\n        this.bufferedMessages = [];\n        this.messagesToPush = [];\n        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n        this.stream.once('error', (err) => {\n            /* We need an error handler to avoid uncaught error event exceptions, but\n             * there is nothing we can reasonably do here. Any error event should\n             * have a corresponding close event, which handles emitting the cancelled\n             * event. And the stream is now in a bad state, so we can't reasonably\n             * expect to be able to send an error over it. */\n        });\n        this.stream.once('close', () => {\n            var _a;\n            trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) +\n                ' stream closed with rstCode ' +\n                this.stream.rstCode);\n            this.cancelled = true;\n            this.emit('cancelled', 'cancelled');\n        });\n        this.stream.on('drain', () => {\n            this.emit('drain');\n        });\n        if ('grpc.max_send_message_length' in options) {\n            this.maxSendMessageSize = options['grpc.max_send_message_length'];\n        }\n        if ('grpc.max_receive_message_length' in options) {\n            this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];\n        }\n        // Clear noop timer\n        clearTimeout(this.deadlineTimer);\n    }\n    checkCancelled() {\n        /* In some cases the stream can become destroyed before the close event\n         * fires. That creates a race condition that this check works around */\n        if (this.stream.destroyed) {\n            this.cancelled = true;\n        }\n        return this.cancelled;\n    }\n    sendMetadata(customMetadata) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (this.metadataSent) {\n            return;\n        }\n        this.metadataSent = true;\n        const custom = customMetadata ? customMetadata.toHttp2Headers() : null;\n        // TODO(cjihrig): Include compression headers.\n        const headers = Object.assign({}, defaultResponseHeaders, custom);\n        this.stream.respond(headers, defaultResponseOptions);\n    }\n    receiveMetadata(headers) {\n        const metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        // TODO(cjihrig): Receive compression metadata.\n        const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\n        if (timeoutHeader.length > 0) {\n            const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);\n            if (match === null) {\n                const err = new Error('Invalid deadline');\n                err.code = constants_1.Status.OUT_OF_RANGE;\n                this.sendError(err);\n                return;\n            }\n            const timeout = (+match[1] * deadlineUnitsToMs[match[2]]) | 0;\n            const now = new Date();\n            this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);\n            this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);\n            metadata.remove(GRPC_TIMEOUT_HEADER);\n        }\n        // Remove several headers that should not be propagated to the application\n        metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\n        metadata.remove(http2.constants.HTTP2_HEADER_TE);\n        metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\n        metadata.remove('grpc-encoding');\n        metadata.remove('grpc-accept-encoding');\n        return metadata;\n    }\n    receiveUnaryMessage() {\n        return new Promise((resolve, reject) => {\n            const stream = this.stream;\n            const chunks = [];\n            let totalLength = 0;\n            stream.on('data', (data) => {\n                chunks.push(data);\n                totalLength += data.byteLength;\n            });\n            stream.once('end', async () => {\n                try {\n                    const requestBytes = Buffer.concat(chunks, totalLength);\n                    if (this.maxReceiveMessageSize !== -1 &&\n                        requestBytes.length > this.maxReceiveMessageSize) {\n                        this.sendError({\n                            code: constants_1.Status.RESOURCE_EXHAUSTED,\n                            details: `Received message larger than max (${requestBytes.length} vs. ${this.maxReceiveMessageSize})`,\n                        });\n                        resolve();\n                    }\n                    resolve(this.deserializeMessage(requestBytes));\n                }\n                catch (err) {\n                    err.code = constants_1.Status.INTERNAL;\n                    this.sendError(err);\n                    resolve();\n                }\n            });\n        });\n    }\n    serializeMessage(value) {\n        const messageBuffer = this.handler.serialize(value);\n        // TODO(cjihrig): Call compression aware serializeMessage().\n        const byteLength = messageBuffer.byteLength;\n        const output = Buffer.allocUnsafe(byteLength + 5);\n        output.writeUInt8(0, 0);\n        output.writeUInt32BE(byteLength, 1);\n        messageBuffer.copy(output, 5);\n        return output;\n    }\n    deserializeMessage(bytes) {\n        // TODO(cjihrig): Call compression aware deserializeMessage().\n        const receivedMessage = bytes.slice(5);\n        return this.handler.deserialize(receivedMessage);\n    }\n    async sendUnaryMessage(err, value, metadata, flags) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (!metadata) {\n            metadata = new metadata_1.Metadata();\n        }\n        if (err) {\n            if (!Object.prototype.hasOwnProperty.call(err, 'metadata')) {\n                err.metadata = metadata;\n            }\n            this.sendError(err);\n            return;\n        }\n        try {\n            const response = this.serializeMessage(value);\n            this.write(response);\n            this.sendStatus({ code: constants_1.Status.OK, details: 'OK', metadata });\n        }\n        catch (err) {\n            err.code = constants_1.Status.INTERNAL;\n            this.sendError(err);\n        }\n    }\n    sendStatus(statusObj) {\n        var _a;\n        if (this.checkCancelled()) {\n            return;\n        }\n        trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) +\n            ' ended with status code: ' +\n            constants_1.Status[statusObj.code] +\n            ' details: ' +\n            statusObj.details);\n        clearTimeout(this.deadlineTimer);\n        if (!this.wantTrailers) {\n            this.wantTrailers = true;\n            this.stream.once('wantTrailers', () => {\n                const trailersToSend = Object.assign({\n                    [GRPC_STATUS_HEADER]: statusObj.code,\n                    [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details),\n                }, statusObj.metadata.toHttp2Headers());\n                this.stream.sendTrailers(trailersToSend);\n            });\n            this.sendMetadata();\n            this.stream.end();\n        }\n    }\n    sendError(error) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        const status = {\n            code: constants_1.Status.UNKNOWN,\n            details: 'message' in error ? error.message : 'Unknown Error',\n            metadata: 'metadata' in error && error.metadata !== undefined\n                ? error.metadata\n                : new metadata_1.Metadata(),\n        };\n        if ('code' in error &&\n            typeof error.code === 'number' &&\n            Number.isInteger(error.code)) {\n            status.code = error.code;\n            if ('details' in error && typeof error.details === 'string') {\n                status.details = error.details;\n            }\n        }\n        this.sendStatus(status);\n    }\n    write(chunk) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (this.maxSendMessageSize !== -1 &&\n            chunk.length > this.maxSendMessageSize) {\n            this.sendError({\n                code: constants_1.Status.RESOURCE_EXHAUSTED,\n                details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`,\n            });\n            return;\n        }\n        this.sendMetadata();\n        return this.stream.write(chunk);\n    }\n    resume() {\n        this.stream.resume();\n    }\n    setupSurfaceCall(call) {\n        this.once('cancelled', (reason) => {\n            call.cancelled = true;\n            call.emit('cancelled', reason);\n        });\n    }\n    setupReadable(readable) {\n        const decoder = new stream_decoder_1.StreamDecoder();\n        this.stream.on('data', async (data) => {\n            const messages = decoder.write(data);\n            for (const message of messages) {\n                if (this.maxReceiveMessageSize !== -1 &&\n                    message.length > this.maxReceiveMessageSize) {\n                    this.sendError({\n                        code: constants_1.Status.RESOURCE_EXHAUSTED,\n                        details: `Received message larger than max (${message.length} vs. ${this.maxReceiveMessageSize})`,\n                    });\n                    return;\n                }\n                this.pushOrBufferMessage(readable, message);\n            }\n        });\n        this.stream.once('end', () => {\n            this.pushOrBufferMessage(readable, null);\n        });\n    }\n    consumeUnpushedMessages(readable) {\n        this.canPush = true;\n        while (this.messagesToPush.length > 0) {\n            const nextMessage = this.messagesToPush.shift();\n            const canPush = readable.push(nextMessage);\n            if (nextMessage === null || canPush === false) {\n                this.canPush = false;\n                break;\n            }\n        }\n        return this.canPush;\n    }\n    pushOrBufferMessage(readable, messageBytes) {\n        if (this.isPushPending) {\n            this.bufferedMessages.push(messageBytes);\n        }\n        else {\n            this.pushMessage(readable, messageBytes);\n        }\n    }\n    async pushMessage(readable, messageBytes) {\n        if (messageBytes === null) {\n            if (this.canPush) {\n                readable.push(null);\n            }\n            else {\n                this.messagesToPush.push(null);\n            }\n            return;\n        }\n        this.isPushPending = true;\n        try {\n            const deserialized = await this.deserializeMessage(messageBytes);\n            if (this.canPush) {\n                if (!readable.push(deserialized)) {\n                    this.canPush = false;\n                    this.stream.pause();\n                }\n            }\n            else {\n                this.messagesToPush.push(deserialized);\n            }\n        }\n        catch (error) {\n            // Ignore any remaining messages when errors occur.\n            this.bufferedMessages.length = 0;\n            if (!('code' in error &&\n                typeof error.code === 'number' &&\n                Number.isInteger(error.code) &&\n                error.code >= constants_1.Status.OK &&\n                error.code <= constants_1.Status.UNAUTHENTICATED)) {\n                // The error code is not a valid gRPC code so its being overwritten.\n                error.code = constants_1.Status.INTERNAL;\n            }\n            readable.emit('error', error);\n        }\n        this.isPushPending = false;\n        if (this.bufferedMessages.length > 0) {\n            this.pushMessage(readable, this.bufferedMessages.shift());\n        }\n    }\n    getPeer() {\n        const socket = this.stream.session.socket;\n        if (socket.remoteAddress) {\n            if (socket.remotePort) {\n                return `${socket.remoteAddress}:${socket.remotePort}`;\n            }\n            else {\n                return socket.remoteAddress;\n            }\n        }\n        else {\n            return 'unknown';\n        }\n    }\n    getDeadline() {\n        return this.deadline;\n    }\n}\nexports.Http2ServerCallStream = Http2ServerCallStream;\nfunction handleExpiredDeadline(call) {\n    const err = new Error('Deadline exceeded');\n    err.code = constants_1.Status.DEADLINE_EXCEEDED;\n    call.sendError(err);\n    call.cancelled = true;\n    call.emit('cancelled', 'deadline');\n}\n//# sourceMappingURL=server-call.js.map"]},"metadata":{},"sourceType":"script"}