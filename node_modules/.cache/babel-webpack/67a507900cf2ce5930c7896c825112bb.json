{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar _asyncToGenerator = require(\"/Users/artakoroushnia/Desktop/thred-web/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Server = void 0;\n\nconst http2 = require(\"http2\");\n\nconst constants_1 = require(\"./constants\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst server_call_1 = require(\"./server-call\");\n\nconst resolver_1 = require(\"./resolver\");\n\nconst logging = require(\"./logging\");\n\nconst subchannel_1 = require(\"./subchannel\");\n\nconst uri_parser_1 = require(\"./uri-parser\");\n\nconst TRACER_NAME = 'server';\n\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nfunction noop() {}\n\nfunction getUnimplementedStatusResponse(methodName) {\n  return {\n    code: constants_1.Status.UNIMPLEMENTED,\n    details: `The server does not implement the method ${methodName}`,\n    metadata: new metadata_1.Metadata()\n  };\n}\n\nfunction getDefaultHandler(handlerType, methodName) {\n  const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);\n\n  switch (handlerType) {\n    case 'unary':\n      return (call, callback) => {\n        callback(unimplementedStatusResponse, null);\n      };\n\n    case 'clientStream':\n      return (call, callback) => {\n        callback(unimplementedStatusResponse, null);\n      };\n\n    case 'serverStream':\n      return call => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n\n    case 'bidi':\n      return call => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n\n    default:\n      throw new Error(`Invalid handlerType ${handlerType}`);\n  }\n}\n\nclass Server {\n  constructor(options) {\n    this.http2ServerList = [];\n    this.handlers = new Map();\n    this.sessions = new Set();\n    this.started = false;\n    this.options = options !== null && options !== void 0 ? options : {};\n  }\n\n  addProtoService() {\n    throw new Error('Not implemented. Use addService() instead');\n  }\n\n  addService(service, implementation) {\n    if (service === null || typeof service !== 'object' || implementation === null || typeof implementation !== 'object') {\n      throw new Error('addService() requires two objects as arguments');\n    }\n\n    const serviceKeys = Object.keys(service);\n\n    if (serviceKeys.length === 0) {\n      throw new Error('Cannot add an empty service to a server');\n    }\n\n    serviceKeys.forEach(name => {\n      const attrs = service[name];\n      let methodType;\n\n      if (attrs.requestStream) {\n        if (attrs.responseStream) {\n          methodType = 'bidi';\n        } else {\n          methodType = 'clientStream';\n        }\n      } else {\n        if (attrs.responseStream) {\n          methodType = 'serverStream';\n        } else {\n          methodType = 'unary';\n        }\n      }\n\n      let implFn = implementation[name];\n      let impl;\n\n      if (implFn === undefined && typeof attrs.originalName === 'string') {\n        implFn = implementation[attrs.originalName];\n      }\n\n      if (implFn !== undefined) {\n        impl = implFn.bind(implementation);\n      } else {\n        impl = getDefaultHandler(methodType, name);\n      }\n\n      const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);\n\n      if (success === false) {\n        throw new Error(`Method handler for ${attrs.path} already provided.`);\n      }\n    });\n  }\n\n  removeService(service) {\n    if (service === null || typeof service !== 'object') {\n      throw new Error('removeService() requires object as argument');\n    }\n\n    const serviceKeys = Object.keys(service);\n    serviceKeys.forEach(name => {\n      const attrs = service[name];\n      this.unregister(attrs.path);\n    });\n  }\n\n  bind(port, creds) {\n    throw new Error('Not implemented. Use bindAsync() instead');\n  }\n\n  bindAsync(port, creds, callback) {\n    if (this.started === true) {\n      throw new Error('server is already started');\n    }\n\n    if (typeof port !== 'string') {\n      throw new TypeError('port must be a string');\n    }\n\n    if (creds === null || typeof creds !== 'object') {\n      throw new TypeError('creds must be an object');\n    }\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function');\n    }\n\n    const initialPortUri = uri_parser_1.parseUri(port);\n\n    if (initialPortUri === null) {\n      throw new Error(`Could not parse port \"${port}\"`);\n    }\n\n    const portUri = resolver_1.mapUriDefaultScheme(initialPortUri);\n\n    if (portUri === null) {\n      throw new Error(`Could not get a default scheme for port \"${port}\"`);\n    }\n\n    const serverOptions = {\n      maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER\n    };\n\n    if ('grpc-node.max_session_memory' in this.options) {\n      serverOptions.maxSessionMemory = this.options['grpc-node.max_session_memory'];\n    }\n\n    if ('grpc.max_concurrent_streams' in this.options) {\n      serverOptions.settings = {\n        maxConcurrentStreams: this.options['grpc.max_concurrent_streams']\n      };\n    }\n\n    const setupServer = () => {\n      let http2Server;\n\n      if (creds._isSecure()) {\n        const secureServerOptions = Object.assign(serverOptions, creds._getSettings());\n        http2Server = http2.createSecureServer(secureServerOptions);\n      } else {\n        http2Server = http2.createServer(serverOptions);\n      }\n\n      http2Server.setTimeout(0, noop);\n\n      this._setupHandlers(http2Server);\n\n      return http2Server;\n    };\n\n    const bindSpecificPort = (addressList, portNum, previousCount) => {\n      if (addressList.length === 0) {\n        return Promise.resolve({\n          port: portNum,\n          count: previousCount\n        });\n      }\n\n      return Promise.all(addressList.map(address => {\n        trace('Attempting to bind ' + subchannel_1.subchannelAddressToString(address));\n        let addr;\n\n        if (subchannel_1.isTcpSubchannelAddress(address)) {\n          addr = {\n            host: address.host,\n            port: portNum\n          };\n        } else {\n          addr = address;\n        }\n\n        const http2Server = setupServer();\n        return new Promise((resolve, reject) => {\n          function onError(err) {\n            resolve(err);\n          }\n\n          http2Server.once('error', onError);\n          http2Server.listen(addr, () => {\n            trace('Successfully bound ' + subchannel_1.subchannelAddressToString(address));\n            this.http2ServerList.push(http2Server);\n            const boundAddress = http2Server.address();\n\n            if (typeof boundAddress === 'string') {\n              resolve(portNum);\n            } else {\n              resolve(boundAddress.port);\n            }\n\n            http2Server.removeListener('error', onError);\n          });\n        });\n      })).then(results => {\n        let count = 0;\n\n        for (const result of results) {\n          if (typeof result === 'number') {\n            count += 1;\n\n            if (result !== portNum) {\n              throw new Error('Invalid state: multiple port numbers added from single address');\n            }\n          }\n        }\n\n        return {\n          port: portNum,\n          count: count + previousCount\n        };\n      });\n    };\n\n    const bindWildcardPort = addressList => {\n      if (addressList.length === 0) {\n        return Promise.resolve({\n          port: 0,\n          count: 0\n        });\n      }\n\n      const address = addressList[0];\n      const http2Server = setupServer();\n      return new Promise((resolve, reject) => {\n        function onError(err) {\n          resolve(bindWildcardPort(addressList.slice(1)));\n        }\n\n        http2Server.once('error', onError);\n        http2Server.listen(address, () => {\n          this.http2ServerList.push(http2Server);\n          resolve(bindSpecificPort(addressList.slice(1), http2Server.address().port, 1));\n          http2Server.removeListener('error', onError);\n        });\n      });\n    };\n\n    const resolverListener = {\n      onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError) => {\n        // We only want one resolution result. Discard all future results\n        resolverListener.onSuccessfulResolution = () => {};\n\n        if (addressList.length === 0) {\n          callback(new Error(`No addresses resolved for port ${port}`), 0);\n          return;\n        }\n\n        let bindResultPromise;\n\n        if (subchannel_1.isTcpSubchannelAddress(addressList[0])) {\n          if (addressList[0].port === 0) {\n            bindResultPromise = bindWildcardPort(addressList);\n          } else {\n            bindResultPromise = bindSpecificPort(addressList, addressList[0].port, 0);\n          }\n        } else {\n          // Use an arbitrary non-zero port for non-TCP addresses\n          bindResultPromise = bindSpecificPort(addressList, 1, 0);\n        }\n\n        bindResultPromise.then(bindResult => {\n          if (bindResult.count === 0) {\n            const errorString = `No address added out of total ${addressList.length} resolved`;\n            logging.log(constants_1.LogVerbosity.ERROR, errorString);\n            callback(new Error(errorString), 0);\n          } else {\n            if (bindResult.count < addressList.length) {\n              logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);\n            }\n\n            callback(null, bindResult.port);\n          }\n        }, error => {\n          const errorString = `No address added out of total ${addressList.length} resolved`;\n          logging.log(constants_1.LogVerbosity.ERROR, errorString);\n          callback(new Error(errorString), 0);\n        });\n      },\n      onError: error => {\n        callback(new Error(error.details), 0);\n      }\n    };\n    const resolver = resolver_1.createResolver(portUri, resolverListener, this.options);\n    resolver.updateResolution();\n  }\n\n  forceShutdown() {\n    // Close the server if it is still running.\n    for (const http2Server of this.http2ServerList) {\n      if (http2Server.listening) {\n        http2Server.close();\n      }\n    }\n\n    this.started = false; // Always destroy any available sessions. It's possible that one or more\n    // tryShutdown() calls are in progress. Don't wait on them to finish.\n\n    this.sessions.forEach(session => {\n      // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n      // recognize destroy(code) as a valid signature.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      session.destroy(http2.constants.NGHTTP2_CANCEL);\n    });\n    this.sessions.clear();\n  }\n\n  register(name, handler, serialize, deserialize, type) {\n    if (this.handlers.has(name)) {\n      return false;\n    }\n\n    this.handlers.set(name, {\n      func: handler,\n      serialize,\n      deserialize,\n      type,\n      path: name\n    });\n    return true;\n  }\n\n  unregister(name) {\n    return this.handlers.delete(name);\n  }\n\n  start() {\n    if (this.http2ServerList.length === 0 || this.http2ServerList.every(http2Server => http2Server.listening !== true)) {\n      throw new Error('server must be bound in order to start');\n    }\n\n    if (this.started === true) {\n      throw new Error('server is already started');\n    }\n\n    this.started = true;\n  }\n\n  tryShutdown(callback) {\n    let pendingChecks = 0;\n\n    function maybeCallback() {\n      pendingChecks--;\n\n      if (pendingChecks === 0) {\n        callback();\n      }\n    } // Close the server if necessary.\n\n\n    this.started = false;\n\n    for (const http2Server of this.http2ServerList) {\n      if (http2Server.listening) {\n        pendingChecks++;\n        http2Server.close(maybeCallback);\n      }\n    }\n\n    this.sessions.forEach(session => {\n      if (!session.closed) {\n        pendingChecks += 1;\n        session.close(maybeCallback);\n      }\n    });\n\n    if (pendingChecks === 0) {\n      callback();\n    }\n  }\n\n  addHttp2Port() {\n    throw new Error('Not yet implemented');\n  }\n\n  _setupHandlers(http2Server) {\n    if (http2Server === null) {\n      return;\n    }\n\n    http2Server.on('stream', (stream, headers) => {\n      const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n\n      if (typeof contentType !== 'string' || !contentType.startsWith('application/grpc')) {\n        stream.respond({\n          [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE\n        }, {\n          endStream: true\n        });\n        return;\n      }\n\n      try {\n        const path = headers[http2.constants.HTTP2_HEADER_PATH];\n        const serverAddress = http2Server.address();\n        let serverAddressString = 'null';\n\n        if (serverAddress) {\n          if (typeof serverAddress === 'string') {\n            serverAddressString = serverAddress;\n          } else {\n            serverAddressString = serverAddress.address + ':' + serverAddress.port;\n          }\n        }\n\n        trace('Received call to method ' + path + ' at address ' + serverAddressString);\n        const handler = this.handlers.get(path);\n\n        if (handler === undefined) {\n          trace('No handler registered for method ' + path + '. Sending UNIMPLEMENTED status.');\n          throw getUnimplementedStatusResponse(path);\n        }\n\n        const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);\n        const metadata = call.receiveMetadata(headers);\n\n        switch (handler.type) {\n          case 'unary':\n            handleUnary(call, handler, metadata);\n            break;\n\n          case 'clientStream':\n            handleClientStreaming(call, handler, metadata);\n            break;\n\n          case 'serverStream':\n            handleServerStreaming(call, handler, metadata);\n            break;\n\n          case 'bidi':\n            handleBidiStreaming(call, handler, metadata);\n            break;\n\n          default:\n            throw new Error(`Unknown handler type: ${handler.type}`);\n        }\n      } catch (err) {\n        const call = new server_call_1.Http2ServerCallStream(stream, null, this.options);\n\n        if (err.code === undefined) {\n          err.code = constants_1.Status.INTERNAL;\n        }\n\n        call.sendError(err);\n      }\n    });\n    http2Server.on('session', session => {\n      if (!this.started) {\n        session.destroy();\n        return;\n      }\n\n      this.sessions.add(session);\n      session.on('close', () => {\n        this.sessions.delete(session);\n      });\n    });\n  }\n\n}\n\nexports.Server = Server;\n\nfunction handleUnary(_x, _x2, _x3) {\n  return _handleUnary.apply(this, arguments);\n}\n\nfunction _handleUnary() {\n  _handleUnary = _asyncToGenerator(function* (call, handler, metadata) {\n    const request = yield call.receiveUnaryMessage();\n\n    if (request === undefined || call.cancelled) {\n      return;\n    }\n\n    const emitter = new server_call_1.ServerUnaryCallImpl(call, metadata, request);\n    handler.func(emitter, (err, value, trailer, flags) => {\n      call.sendUnaryMessage(err, value, trailer, flags);\n    });\n  });\n  return _handleUnary.apply(this, arguments);\n}\n\nfunction handleClientStreaming(call, handler, metadata) {\n  const stream = new server_call_1.ServerReadableStreamImpl(call, metadata, handler.deserialize);\n\n  function respond(err, value, trailer, flags) {\n    stream.destroy();\n    call.sendUnaryMessage(err, value, trailer, flags);\n  }\n\n  if (call.cancelled) {\n    return;\n  }\n\n  stream.on('error', respond);\n  handler.func(stream, respond);\n}\n\nfunction handleServerStreaming(_x4, _x5, _x6) {\n  return _handleServerStreaming.apply(this, arguments);\n}\n\nfunction _handleServerStreaming() {\n  _handleServerStreaming = _asyncToGenerator(function* (call, handler, metadata) {\n    const request = yield call.receiveUnaryMessage();\n\n    if (request === undefined || call.cancelled) {\n      return;\n    }\n\n    const stream = new server_call_1.ServerWritableStreamImpl(call, metadata, handler.serialize, request);\n    handler.func(stream);\n  });\n  return _handleServerStreaming.apply(this, arguments);\n}\n\nfunction handleBidiStreaming(call, handler, metadata) {\n  const stream = new server_call_1.ServerDuplexStreamImpl(call, metadata, handler.serialize, handler.deserialize);\n\n  if (call.cancelled) {\n    return;\n  }\n\n  handler.func(stream);\n} //# sourceMappingURL=server.js.map","map":{"version":3,"sources":["/Users/artakoroushnia/Desktop/thred-web/node_modules/@grpc/grpc-js/build/src/server.js"],"names":["Object","defineProperty","exports","value","Server","http2","require","constants_1","metadata_1","server_call_1","resolver_1","logging","subchannel_1","uri_parser_1","TRACER_NAME","trace","text","LogVerbosity","DEBUG","noop","getUnimplementedStatusResponse","methodName","code","Status","UNIMPLEMENTED","details","metadata","Metadata","getDefaultHandler","handlerType","unimplementedStatusResponse","call","callback","emit","Error","constructor","options","http2ServerList","handlers","Map","sessions","Set","started","addProtoService","addService","service","implementation","serviceKeys","keys","length","forEach","name","attrs","methodType","requestStream","responseStream","implFn","impl","undefined","originalName","bind","success","register","path","responseSerialize","requestDeserialize","removeService","unregister","port","creds","bindAsync","TypeError","initialPortUri","parseUri","portUri","mapUriDefaultScheme","serverOptions","maxSendHeaderBlockLength","Number","MAX_SAFE_INTEGER","maxSessionMemory","settings","maxConcurrentStreams","setupServer","http2Server","_isSecure","secureServerOptions","assign","_getSettings","createSecureServer","createServer","setTimeout","_setupHandlers","bindSpecificPort","addressList","portNum","previousCount","Promise","resolve","count","all","map","address","subchannelAddressToString","addr","isTcpSubchannelAddress","host","reject","onError","err","once","listen","push","boundAddress","removeListener","then","results","result","bindWildcardPort","slice","resolverListener","onSuccessfulResolution","serviceConfig","serviceConfigError","bindResultPromise","bindResult","errorString","log","ERROR","INFO","error","resolver","createResolver","updateResolution","forceShutdown","listening","close","session","destroy","constants","NGHTTP2_CANCEL","clear","handler","serialize","deserialize","type","has","set","func","delete","start","every","tryShutdown","pendingChecks","maybeCallback","closed","addHttp2Port","on","stream","headers","contentType","HTTP2_HEADER_CONTENT_TYPE","startsWith","respond","HTTP2_HEADER_STATUS","HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE","endStream","HTTP2_HEADER_PATH","serverAddress","serverAddressString","get","Http2ServerCallStream","receiveMetadata","handleUnary","handleClientStreaming","handleServerStreaming","handleBidiStreaming","INTERNAL","sendError","add","request","receiveUnaryMessage","cancelled","emitter","ServerUnaryCallImpl","trailer","flags","sendUnaryMessage","ServerReadableStreamImpl","ServerWritableStreamImpl","ServerDuplexStreamImpl"],"mappings":"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","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Server = void 0;\nconst http2 = require(\"http2\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst server_call_1 = require(\"./server-call\");\nconst resolver_1 = require(\"./resolver\");\nconst logging = require(\"./logging\");\nconst subchannel_1 = require(\"./subchannel\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst TRACER_NAME = 'server';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nfunction noop() { }\nfunction getUnimplementedStatusResponse(methodName) {\n    return {\n        code: constants_1.Status.UNIMPLEMENTED,\n        details: `The server does not implement the method ${methodName}`,\n        metadata: new metadata_1.Metadata(),\n    };\n}\nfunction getDefaultHandler(handlerType, methodName) {\n    const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);\n    switch (handlerType) {\n        case 'unary':\n            return (call, callback) => {\n                callback(unimplementedStatusResponse, null);\n            };\n        case 'clientStream':\n            return (call, callback) => {\n                callback(unimplementedStatusResponse, null);\n            };\n        case 'serverStream':\n            return (call) => {\n                call.emit('error', unimplementedStatusResponse);\n            };\n        case 'bidi':\n            return (call) => {\n                call.emit('error', unimplementedStatusResponse);\n            };\n        default:\n            throw new Error(`Invalid handlerType ${handlerType}`);\n    }\n}\nclass Server {\n    constructor(options) {\n        this.http2ServerList = [];\n        this.handlers = new Map();\n        this.sessions = new Set();\n        this.started = false;\n        this.options = options !== null && options !== void 0 ? options : {};\n    }\n    addProtoService() {\n        throw new Error('Not implemented. Use addService() instead');\n    }\n    addService(service, implementation) {\n        if (service === null ||\n            typeof service !== 'object' ||\n            implementation === null ||\n            typeof implementation !== 'object') {\n            throw new Error('addService() requires two objects as arguments');\n        }\n        const serviceKeys = Object.keys(service);\n        if (serviceKeys.length === 0) {\n            throw new Error('Cannot add an empty service to a server');\n        }\n        serviceKeys.forEach((name) => {\n            const attrs = service[name];\n            let methodType;\n            if (attrs.requestStream) {\n                if (attrs.responseStream) {\n                    methodType = 'bidi';\n                }\n                else {\n                    methodType = 'clientStream';\n                }\n            }\n            else {\n                if (attrs.responseStream) {\n                    methodType = 'serverStream';\n                }\n                else {\n                    methodType = 'unary';\n                }\n            }\n            let implFn = implementation[name];\n            let impl;\n            if (implFn === undefined && typeof attrs.originalName === 'string') {\n                implFn = implementation[attrs.originalName];\n            }\n            if (implFn !== undefined) {\n                impl = implFn.bind(implementation);\n            }\n            else {\n                impl = getDefaultHandler(methodType, name);\n            }\n            const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);\n            if (success === false) {\n                throw new Error(`Method handler for ${attrs.path} already provided.`);\n            }\n        });\n    }\n    removeService(service) {\n        if (service === null ||\n            typeof service !== 'object') {\n            throw new Error('removeService() requires object as argument');\n        }\n        const serviceKeys = Object.keys(service);\n        serviceKeys.forEach((name) => {\n            const attrs = service[name];\n            this.unregister(attrs.path);\n        });\n    }\n    bind(port, creds) {\n        throw new Error('Not implemented. Use bindAsync() instead');\n    }\n    bindAsync(port, creds, callback) {\n        if (this.started === true) {\n            throw new Error('server is already started');\n        }\n        if (typeof port !== 'string') {\n            throw new TypeError('port must be a string');\n        }\n        if (creds === null || typeof creds !== 'object') {\n            throw new TypeError('creds must be an object');\n        }\n        if (typeof callback !== 'function') {\n            throw new TypeError('callback must be a function');\n        }\n        const initialPortUri = uri_parser_1.parseUri(port);\n        if (initialPortUri === null) {\n            throw new Error(`Could not parse port \"${port}\"`);\n        }\n        const portUri = resolver_1.mapUriDefaultScheme(initialPortUri);\n        if (portUri === null) {\n            throw new Error(`Could not get a default scheme for port \"${port}\"`);\n        }\n        const serverOptions = {\n            maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER\n        };\n        if ('grpc-node.max_session_memory' in this.options) {\n            serverOptions.maxSessionMemory = this.options['grpc-node.max_session_memory'];\n        }\n        if ('grpc.max_concurrent_streams' in this.options) {\n            serverOptions.settings = {\n                maxConcurrentStreams: this.options['grpc.max_concurrent_streams'],\n            };\n        }\n        const setupServer = () => {\n            let http2Server;\n            if (creds._isSecure()) {\n                const secureServerOptions = Object.assign(serverOptions, creds._getSettings());\n                http2Server = http2.createSecureServer(secureServerOptions);\n            }\n            else {\n                http2Server = http2.createServer(serverOptions);\n            }\n            http2Server.setTimeout(0, noop);\n            this._setupHandlers(http2Server);\n            return http2Server;\n        };\n        const bindSpecificPort = (addressList, portNum, previousCount) => {\n            if (addressList.length === 0) {\n                return Promise.resolve({ port: portNum, count: previousCount });\n            }\n            return Promise.all(addressList.map((address) => {\n                trace('Attempting to bind ' + subchannel_1.subchannelAddressToString(address));\n                let addr;\n                if (subchannel_1.isTcpSubchannelAddress(address)) {\n                    addr = {\n                        host: address.host,\n                        port: portNum,\n                    };\n                }\n                else {\n                    addr = address;\n                }\n                const http2Server = setupServer();\n                return new Promise((resolve, reject) => {\n                    function onError(err) {\n                        resolve(err);\n                    }\n                    http2Server.once('error', onError);\n                    http2Server.listen(addr, () => {\n                        trace('Successfully bound ' + subchannel_1.subchannelAddressToString(address));\n                        this.http2ServerList.push(http2Server);\n                        const boundAddress = http2Server.address();\n                        if (typeof boundAddress === 'string') {\n                            resolve(portNum);\n                        }\n                        else {\n                            resolve(boundAddress.port);\n                        }\n                        http2Server.removeListener('error', onError);\n                    });\n                });\n            })).then((results) => {\n                let count = 0;\n                for (const result of results) {\n                    if (typeof result === 'number') {\n                        count += 1;\n                        if (result !== portNum) {\n                            throw new Error('Invalid state: multiple port numbers added from single address');\n                        }\n                    }\n                }\n                return {\n                    port: portNum,\n                    count: count + previousCount,\n                };\n            });\n        };\n        const bindWildcardPort = (addressList) => {\n            if (addressList.length === 0) {\n                return Promise.resolve({ port: 0, count: 0 });\n            }\n            const address = addressList[0];\n            const http2Server = setupServer();\n            return new Promise((resolve, reject) => {\n                function onError(err) {\n                    resolve(bindWildcardPort(addressList.slice(1)));\n                }\n                http2Server.once('error', onError);\n                http2Server.listen(address, () => {\n                    this.http2ServerList.push(http2Server);\n                    resolve(bindSpecificPort(addressList.slice(1), http2Server.address().port, 1));\n                    http2Server.removeListener('error', onError);\n                });\n            });\n        };\n        const resolverListener = {\n            onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError) => {\n                // We only want one resolution result. Discard all future results\n                resolverListener.onSuccessfulResolution = () => { };\n                if (addressList.length === 0) {\n                    callback(new Error(`No addresses resolved for port ${port}`), 0);\n                    return;\n                }\n                let bindResultPromise;\n                if (subchannel_1.isTcpSubchannelAddress(addressList[0])) {\n                    if (addressList[0].port === 0) {\n                        bindResultPromise = bindWildcardPort(addressList);\n                    }\n                    else {\n                        bindResultPromise = bindSpecificPort(addressList, addressList[0].port, 0);\n                    }\n                }\n                else {\n                    // Use an arbitrary non-zero port for non-TCP addresses\n                    bindResultPromise = bindSpecificPort(addressList, 1, 0);\n                }\n                bindResultPromise.then((bindResult) => {\n                    if (bindResult.count === 0) {\n                        const errorString = `No address added out of total ${addressList.length} resolved`;\n                        logging.log(constants_1.LogVerbosity.ERROR, errorString);\n                        callback(new Error(errorString), 0);\n                    }\n                    else {\n                        if (bindResult.count < addressList.length) {\n                            logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);\n                        }\n                        callback(null, bindResult.port);\n                    }\n                }, (error) => {\n                    const errorString = `No address added out of total ${addressList.length} resolved`;\n                    logging.log(constants_1.LogVerbosity.ERROR, errorString);\n                    callback(new Error(errorString), 0);\n                });\n            },\n            onError: (error) => {\n                callback(new Error(error.details), 0);\n            },\n        };\n        const resolver = resolver_1.createResolver(portUri, resolverListener, this.options);\n        resolver.updateResolution();\n    }\n    forceShutdown() {\n        // Close the server if it is still running.\n        for (const http2Server of this.http2ServerList) {\n            if (http2Server.listening) {\n                http2Server.close();\n            }\n        }\n        this.started = false;\n        // Always destroy any available sessions. It's possible that one or more\n        // tryShutdown() calls are in progress. Don't wait on them to finish.\n        this.sessions.forEach((session) => {\n            // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n            // recognize destroy(code) as a valid signature.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            session.destroy(http2.constants.NGHTTP2_CANCEL);\n        });\n        this.sessions.clear();\n    }\n    register(name, handler, serialize, deserialize, type) {\n        if (this.handlers.has(name)) {\n            return false;\n        }\n        this.handlers.set(name, {\n            func: handler,\n            serialize,\n            deserialize,\n            type,\n            path: name,\n        });\n        return true;\n    }\n    unregister(name) {\n        return this.handlers.delete(name);\n    }\n    start() {\n        if (this.http2ServerList.length === 0 ||\n            this.http2ServerList.every((http2Server) => http2Server.listening !== true)) {\n            throw new Error('server must be bound in order to start');\n        }\n        if (this.started === true) {\n            throw new Error('server is already started');\n        }\n        this.started = true;\n    }\n    tryShutdown(callback) {\n        let pendingChecks = 0;\n        function maybeCallback() {\n            pendingChecks--;\n            if (pendingChecks === 0) {\n                callback();\n            }\n        }\n        // Close the server if necessary.\n        this.started = false;\n        for (const http2Server of this.http2ServerList) {\n            if (http2Server.listening) {\n                pendingChecks++;\n                http2Server.close(maybeCallback);\n            }\n        }\n        this.sessions.forEach((session) => {\n            if (!session.closed) {\n                pendingChecks += 1;\n                session.close(maybeCallback);\n            }\n        });\n        if (pendingChecks === 0) {\n            callback();\n        }\n    }\n    addHttp2Port() {\n        throw new Error('Not yet implemented');\n    }\n    _setupHandlers(http2Server) {\n        if (http2Server === null) {\n            return;\n        }\n        http2Server.on('stream', (stream, headers) => {\n            const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n            if (typeof contentType !== 'string' ||\n                !contentType.startsWith('application/grpc')) {\n                stream.respond({\n                    [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE,\n                }, { endStream: true });\n                return;\n            }\n            try {\n                const path = headers[http2.constants.HTTP2_HEADER_PATH];\n                const serverAddress = http2Server.address();\n                let serverAddressString = 'null';\n                if (serverAddress) {\n                    if (typeof serverAddress === 'string') {\n                        serverAddressString = serverAddress;\n                    }\n                    else {\n                        serverAddressString =\n                            serverAddress.address + ':' + serverAddress.port;\n                    }\n                }\n                trace('Received call to method ' +\n                    path +\n                    ' at address ' +\n                    serverAddressString);\n                const handler = this.handlers.get(path);\n                if (handler === undefined) {\n                    trace('No handler registered for method ' +\n                        path +\n                        '. Sending UNIMPLEMENTED status.');\n                    throw getUnimplementedStatusResponse(path);\n                }\n                const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);\n                const metadata = call.receiveMetadata(headers);\n                switch (handler.type) {\n                    case 'unary':\n                        handleUnary(call, handler, metadata);\n                        break;\n                    case 'clientStream':\n                        handleClientStreaming(call, handler, metadata);\n                        break;\n                    case 'serverStream':\n                        handleServerStreaming(call, handler, metadata);\n                        break;\n                    case 'bidi':\n                        handleBidiStreaming(call, handler, metadata);\n                        break;\n                    default:\n                        throw new Error(`Unknown handler type: ${handler.type}`);\n                }\n            }\n            catch (err) {\n                const call = new server_call_1.Http2ServerCallStream(stream, null, this.options);\n                if (err.code === undefined) {\n                    err.code = constants_1.Status.INTERNAL;\n                }\n                call.sendError(err);\n            }\n        });\n        http2Server.on('session', (session) => {\n            if (!this.started) {\n                session.destroy();\n                return;\n            }\n            this.sessions.add(session);\n            session.on('close', () => {\n                this.sessions.delete(session);\n            });\n        });\n    }\n}\nexports.Server = Server;\nasync function handleUnary(call, handler, metadata) {\n    const request = await call.receiveUnaryMessage();\n    if (request === undefined || call.cancelled) {\n        return;\n    }\n    const emitter = new server_call_1.ServerUnaryCallImpl(call, metadata, request);\n    handler.func(emitter, (err, value, trailer, flags) => {\n        call.sendUnaryMessage(err, value, trailer, flags);\n    });\n}\nfunction handleClientStreaming(call, handler, metadata) {\n    const stream = new server_call_1.ServerReadableStreamImpl(call, metadata, handler.deserialize);\n    function respond(err, value, trailer, flags) {\n        stream.destroy();\n        call.sendUnaryMessage(err, value, trailer, flags);\n    }\n    if (call.cancelled) {\n        return;\n    }\n    stream.on('error', respond);\n    handler.func(stream, respond);\n}\nasync function handleServerStreaming(call, handler, metadata) {\n    const request = await call.receiveUnaryMessage();\n    if (request === undefined || call.cancelled) {\n        return;\n    }\n    const stream = new server_call_1.ServerWritableStreamImpl(call, metadata, handler.serialize, request);\n    handler.func(stream);\n}\nfunction handleBidiStreaming(call, handler, metadata) {\n    const stream = new server_call_1.ServerDuplexStreamImpl(call, metadata, handler.serialize, handler.deserialize);\n    if (call.cancelled) {\n        return;\n    }\n    handler.func(stream);\n}\n//# sourceMappingURL=server.js.map"]},"metadata":{},"sourceType":"script"}