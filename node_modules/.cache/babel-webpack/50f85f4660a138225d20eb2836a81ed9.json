{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar _asyncToGenerator = require(\"/Users/artakoroushnia/Desktop/thred-web/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Server = void 0;\n\nconst http2 = require(\"http2\");\n\nconst constants_1 = require(\"./constants\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst server_call_1 = require(\"./server-call\");\n\nconst resolver_1 = require(\"./resolver\");\n\nconst logging = require(\"./logging\");\n\nconst subchannel_1 = require(\"./subchannel\");\n\nconst uri_parser_1 = require(\"./uri-parser\");\n\nconst TRACER_NAME = 'server';\n\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nfunction noop() {}\n\nfunction getUnimplementedStatusResponse(methodName) {\n  return {\n    code: constants_1.Status.UNIMPLEMENTED,\n    details: `The server does not implement the method ${methodName}`,\n    metadata: new metadata_1.Metadata()\n  };\n}\n\nfunction getDefaultHandler(handlerType, methodName) {\n  const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);\n\n  switch (handlerType) {\n    case 'unary':\n      return (call, callback) => {\n        callback(unimplementedStatusResponse, null);\n      };\n\n    case 'clientStream':\n      return (call, callback) => {\n        callback(unimplementedStatusResponse, null);\n      };\n\n    case 'serverStream':\n      return call => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n\n    case 'bidi':\n      return call => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n\n    default:\n      throw new Error(`Invalid handlerType ${handlerType}`);\n  }\n}\n\nclass Server {\n  constructor(options) {\n    this.http2ServerList = [];\n    this.handlers = new Map();\n    this.sessions = new Set();\n    this.started = false;\n    this.options = options !== null && options !== void 0 ? options : {};\n  }\n\n  addProtoService() {\n    throw new Error('Not implemented. Use addService() instead');\n  }\n\n  addService(service, implementation) {\n    if (service === null || typeof service !== 'object' || implementation === null || typeof implementation !== 'object') {\n      throw new Error('addService() requires two objects as arguments');\n    }\n\n    const serviceKeys = Object.keys(service);\n\n    if (serviceKeys.length === 0) {\n      throw new Error('Cannot add an empty service to a server');\n    }\n\n    serviceKeys.forEach(name => {\n      const attrs = service[name];\n      let methodType;\n\n      if (attrs.requestStream) {\n        if (attrs.responseStream) {\n          methodType = 'bidi';\n        } else {\n          methodType = 'clientStream';\n        }\n      } else {\n        if (attrs.responseStream) {\n          methodType = 'serverStream';\n        } else {\n          methodType = 'unary';\n        }\n      }\n\n      let implFn = implementation[name];\n      let impl;\n\n      if (implFn === undefined && typeof attrs.originalName === 'string') {\n        implFn = implementation[attrs.originalName];\n      }\n\n      if (implFn !== undefined) {\n        impl = implFn.bind(implementation);\n      } else {\n        impl = getDefaultHandler(methodType, name);\n      }\n\n      const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);\n\n      if (success === false) {\n        throw new Error(`Method handler for ${attrs.path} already provided.`);\n      }\n    });\n  }\n\n  removeService(service) {\n    if (service === null || typeof service !== 'object') {\n      throw new Error('removeService() requires object as argument');\n    }\n\n    const serviceKeys = Object.keys(service);\n    serviceKeys.forEach(name => {\n      const attrs = service[name];\n      this.unregister(attrs.path);\n    });\n  }\n\n  bind(port, creds) {\n    throw new Error('Not implemented. Use bindAsync() instead');\n  }\n\n  bindAsync(port, creds, callback) {\n    if (this.started === true) {\n      throw new Error('server is already started');\n    }\n\n    if (typeof port !== 'string') {\n      throw new TypeError('port must be a string');\n    }\n\n    if (creds === null || typeof creds !== 'object') {\n      throw new TypeError('creds must be an object');\n    }\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function');\n    }\n\n    const initialPortUri = uri_parser_1.parseUri(port);\n\n    if (initialPortUri === null) {\n      throw new Error(`Could not parse port \"${port}\"`);\n    }\n\n    const portUri = resolver_1.mapUriDefaultScheme(initialPortUri);\n\n    if (portUri === null) {\n      throw new Error(`Could not get a default scheme for port \"${port}\"`);\n    }\n\n    const serverOptions = {\n      maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER\n    };\n\n    if ('grpc-node.max_session_memory' in this.options) {\n      serverOptions.maxSessionMemory = this.options['grpc-node.max_session_memory'];\n    }\n\n    if ('grpc.max_concurrent_streams' in this.options) {\n      serverOptions.settings = {\n        maxConcurrentStreams: this.options['grpc.max_concurrent_streams']\n      };\n    }\n\n    const setupServer = () => {\n      let http2Server;\n\n      if (creds._isSecure()) {\n        const secureServerOptions = Object.assign(serverOptions, creds._getSettings());\n        http2Server = http2.createSecureServer(secureServerOptions);\n      } else {\n        http2Server = http2.createServer(serverOptions);\n      }\n\n      http2Server.setTimeout(0, noop);\n\n      this._setupHandlers(http2Server);\n\n      return http2Server;\n    };\n\n    const bindSpecificPort = (addressList, portNum, previousCount) => {\n      if (addressList.length === 0) {\n        return Promise.resolve({\n          port: portNum,\n          count: previousCount\n        });\n      }\n\n      return Promise.all(addressList.map(address => {\n        trace('Attempting to bind ' + subchannel_1.subchannelAddressToString(address));\n        let addr;\n\n        if (subchannel_1.isTcpSubchannelAddress(address)) {\n          addr = {\n            host: address.host,\n            port: portNum\n          };\n        } else {\n          addr = address;\n        }\n\n        const http2Server = setupServer();\n        return new Promise((resolve, reject) => {\n          function onError(err) {\n            resolve(err);\n          }\n\n          http2Server.once('error', onError);\n          http2Server.listen(addr, () => {\n            trace('Successfully bound ' + subchannel_1.subchannelAddressToString(address));\n            this.http2ServerList.push(http2Server);\n            const boundAddress = http2Server.address();\n\n            if (typeof boundAddress === 'string') {\n              resolve(portNum);\n            } else {\n              resolve(boundAddress.port);\n            }\n\n            http2Server.removeListener('error', onError);\n          });\n        });\n      })).then(results => {\n        let count = 0;\n\n        for (const result of results) {\n          if (typeof result === 'number') {\n            count += 1;\n\n            if (result !== portNum) {\n              throw new Error('Invalid state: multiple port numbers added from single address');\n            }\n          }\n        }\n\n        return {\n          port: portNum,\n          count: count + previousCount\n        };\n      });\n    };\n\n    const bindWildcardPort = addressList => {\n      if (addressList.length === 0) {\n        return Promise.resolve({\n          port: 0,\n          count: 0\n        });\n      }\n\n      const address = addressList[0];\n      const http2Server = setupServer();\n      return new Promise((resolve, reject) => {\n        function onError(err) {\n          resolve(bindWildcardPort(addressList.slice(1)));\n        }\n\n        http2Server.once('error', onError);\n        http2Server.listen(address, () => {\n          this.http2ServerList.push(http2Server);\n          resolve(bindSpecificPort(addressList.slice(1), http2Server.address().port, 1));\n          http2Server.removeListener('error', onError);\n        });\n      });\n    };\n\n    const resolverListener = {\n      onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError) => {\n        // We only want one resolution result. Discard all future results\n        resolverListener.onSuccessfulResolution = () => {};\n\n        if (addressList.length === 0) {\n          callback(new Error(`No addresses resolved for port ${port}`), 0);\n          return;\n        }\n\n        let bindResultPromise;\n\n        if (subchannel_1.isTcpSubchannelAddress(addressList[0])) {\n          if (addressList[0].port === 0) {\n            bindResultPromise = bindWildcardPort(addressList);\n          } else {\n            bindResultPromise = bindSpecificPort(addressList, addressList[0].port, 0);\n          }\n        } else {\n          // Use an arbitrary non-zero port for non-TCP addresses\n          bindResultPromise = bindSpecificPort(addressList, 1, 0);\n        }\n\n        bindResultPromise.then(bindResult => {\n          if (bindResult.count === 0) {\n            const errorString = `No address added out of total ${addressList.length} resolved`;\n            logging.log(constants_1.LogVerbosity.ERROR, errorString);\n            callback(new Error(errorString), 0);\n          } else {\n            if (bindResult.count < addressList.length) {\n              logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);\n            }\n\n            callback(null, bindResult.port);\n          }\n        }, error => {\n          const errorString = `No address added out of total ${addressList.length} resolved`;\n          logging.log(constants_1.LogVerbosity.ERROR, errorString);\n          callback(new Error(errorString), 0);\n        });\n      },\n      onError: error => {\n        callback(new Error(error.details), 0);\n      }\n    };\n    const resolver = resolver_1.createResolver(portUri, resolverListener, this.options);\n    resolver.updateResolution();\n  }\n\n  forceShutdown() {\n    // Close the server if it is still running.\n    for (const http2Server of this.http2ServerList) {\n      if (http2Server.listening) {\n        http2Server.close();\n      }\n    }\n\n    this.started = false; // Always destroy any available sessions. It's possible that one or more\n    // tryShutdown() calls are in progress. Don't wait on them to finish.\n\n    this.sessions.forEach(session => {\n      // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n      // recognize destroy(code) as a valid signature.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      session.destroy(http2.constants.NGHTTP2_CANCEL);\n    });\n    this.sessions.clear();\n  }\n\n  register(name, handler, serialize, deserialize, type) {\n    if (this.handlers.has(name)) {\n      return false;\n    }\n\n    this.handlers.set(name, {\n      func: handler,\n      serialize,\n      deserialize,\n      type,\n      path: name\n    });\n    return true;\n  }\n\n  unregister(name) {\n    return this.handlers.delete(name);\n  }\n\n  start() {\n    if (this.http2ServerList.length === 0 || this.http2ServerList.every(http2Server => http2Server.listening !== true)) {\n      throw new Error('server must be bound in order to start');\n    }\n\n    if (this.started === true) {\n      throw new Error('server is already started');\n    }\n\n    this.started = true;\n  }\n\n  tryShutdown(callback) {\n    let pendingChecks = 0;\n\n    function maybeCallback() {\n      pendingChecks--;\n\n      if (pendingChecks === 0) {\n        callback();\n      }\n    } // Close the server if necessary.\n\n\n    this.started = false;\n\n    for (const http2Server of this.http2ServerList) {\n      if (http2Server.listening) {\n        pendingChecks++;\n        http2Server.close(maybeCallback);\n      }\n    }\n\n    this.sessions.forEach(session => {\n      if (!session.closed) {\n        pendingChecks += 1;\n        session.close(maybeCallback);\n      }\n    });\n\n    if (pendingChecks === 0) {\n      callback();\n    }\n  }\n\n  addHttp2Port() {\n    throw new Error('Not yet implemented');\n  }\n\n  _setupHandlers(http2Server) {\n    if (http2Server === null) {\n      return;\n    }\n\n    http2Server.on('stream', (stream, headers) => {\n      const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n\n      if (typeof contentType !== 'string' || !contentType.startsWith('application/grpc')) {\n        stream.respond({\n          [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE\n        }, {\n          endStream: true\n        });\n        return;\n      }\n\n      try {\n        const path = headers[http2.constants.HTTP2_HEADER_PATH];\n        const serverAddress = http2Server.address();\n        let serverAddressString = 'null';\n\n        if (serverAddress) {\n          if (typeof serverAddress === 'string') {\n            serverAddressString = serverAddress;\n          } else {\n            serverAddressString = serverAddress.address + ':' + serverAddress.port;\n          }\n        }\n\n        trace('Received call to method ' + path + ' at address ' + serverAddressString);\n        const handler = this.handlers.get(path);\n\n        if (handler === undefined) {\n          trace('No handler registered for method ' + path + '. Sending UNIMPLEMENTED status.');\n          throw getUnimplementedStatusResponse(path);\n        }\n\n        const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);\n        const metadata = call.receiveMetadata(headers);\n\n        switch (handler.type) {\n          case 'unary':\n            handleUnary(call, handler, metadata);\n            break;\n\n          case 'clientStream':\n            handleClientStreaming(call, handler, metadata);\n            break;\n\n          case 'serverStream':\n            handleServerStreaming(call, handler, metadata);\n            break;\n\n          case 'bidi':\n            handleBidiStreaming(call, handler, metadata);\n            break;\n\n          default:\n            throw new Error(`Unknown handler type: ${handler.type}`);\n        }\n      } catch (err) {\n        const call = new server_call_1.Http2ServerCallStream(stream, null, this.options);\n\n        if (err.code === undefined) {\n          err.code = constants_1.Status.INTERNAL;\n        }\n\n        call.sendError(err);\n      }\n    });\n    http2Server.on('session', session => {\n      if (!this.started) {\n        session.destroy();\n        return;\n      }\n\n      this.sessions.add(session);\n      session.on('close', () => {\n        this.sessions.delete(session);\n      });\n    });\n  }\n\n}\n\nexports.Server = Server;\n\nfunction handleUnary(_x, _x2, _x3) {\n  return _handleUnary.apply(this, arguments);\n}\n\nfunction _handleUnary() {\n  _handleUnary = _asyncToGenerator(function* (call, handler, metadata) {\n    const request = yield call.receiveUnaryMessage();\n\n    if (request === undefined || call.cancelled) {\n      return;\n    }\n\n    const emitter = new server_call_1.ServerUnaryCallImpl(call, metadata, request);\n    handler.func(emitter, (err, value, trailer, flags) => {\n      call.sendUnaryMessage(err, value, trailer, flags);\n    });\n  });\n  return _handleUnary.apply(this, arguments);\n}\n\nfunction handleClientStreaming(call, handler, metadata) {\n  const stream = new server_call_1.ServerReadableStreamImpl(call, metadata, handler.deserialize);\n\n  function respond(err, value, trailer, flags) {\n    stream.destroy();\n    call.sendUnaryMessage(err, value, trailer, flags);\n  }\n\n  if (call.cancelled) {\n    return;\n  }\n\n  stream.on('error', respond);\n  handler.func(stream, respond);\n}\n\nfunction handleServerStreaming(_x4, _x5, _x6) {\n  return _handleServerStreaming.apply(this, arguments);\n}\n\nfunction _handleServerStreaming() {\n  _handleServerStreaming = _asyncToGenerator(function* (call, handler, metadata) {\n    const request = yield call.receiveUnaryMessage();\n\n    if (request === undefined || call.cancelled) {\n      return;\n    }\n\n    const stream = new server_call_1.ServerWritableStreamImpl(call, metadata, handler.serialize, request);\n    handler.func(stream);\n  });\n  return _handleServerStreaming.apply(this, arguments);\n}\n\nfunction handleBidiStreaming(call, handler, metadata) {\n  const stream = new server_call_1.ServerDuplexStreamImpl(call, metadata, handler.serialize, handler.deserialize);\n\n  if (call.cancelled) {\n    return;\n  }\n\n  handler.func(stream);\n} //# sourceMappingURL=server.js.map","map":null,"metadata":{},"sourceType":"script"}