{"ast":null,"code":"var CombinedStream = require('combined-stream');\n\nvar util = require('util');\n\nvar path = require('path');\n\nvar http = require('http');\n\nvar https = require('https');\n\nvar parseUrl = require('url').parse;\n\nvar fs = require('fs');\n\nvar mime = require('mime-types');\n\nvar asynckit = require('asynckit');\n\nvar populate = require('./populate.js'); // Public API\n\n\nmodule.exports = FormData; // make it a Stream\n\nutil.inherits(FormData, CombinedStream);\n/**\n * Create readable \"multipart/form-data\" streams.\n * Can be used to submit forms\n * and file uploads to other web applications.\n *\n * @constructor\n * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream\n */\n\nfunction FormData(options) {\n  if (!(this instanceof FormData)) {\n    return new FormData();\n  }\n\n  this._overheadLength = 0;\n  this._valueLength = 0;\n  this._valuesToMeasure = [];\n  CombinedStream.call(this);\n  options = options || {};\n\n  for (var option in options) {\n    this[option] = options[option];\n  }\n}\n\nFormData.LINE_BREAK = '\\r\\n';\nFormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';\n\nFormData.prototype.append = function (field, value, options) {\n  options = options || {}; // allow filename as single option\n\n  if (typeof options == 'string') {\n    options = {\n      filename: options\n    };\n  }\n\n  var append = CombinedStream.prototype.append.bind(this); // all that streamy business can't handle numbers\n\n  if (typeof value == 'number') {\n    value = '' + value;\n  } // https://github.com/felixge/node-form-data/issues/38\n\n\n  if (util.isArray(value)) {\n    // Please convert your array into string\n    // the way web server expects it\n    this._error(new Error('Arrays are not supported.'));\n\n    return;\n  }\n\n  var header = this._multiPartHeader(field, value, options);\n\n  var footer = this._multiPartFooter();\n\n  append(header);\n  append(value);\n  append(footer); // pass along options.knownLength\n\n  this._trackLength(header, value, options);\n};\n\nFormData.prototype._trackLength = function (header, value, options) {\n  var valueLength = 0; // used w/ getLengthSync(), when length is known.\n  // e.g. for streaming directly from a remote server,\n  // w/ a known file a size, and not wanting to wait for\n  // incoming file to finish to get its size.\n\n  if (options.knownLength != null) {\n    valueLength += +options.knownLength;\n  } else if (Buffer.isBuffer(value)) {\n    valueLength = value.length;\n  } else if (typeof value === 'string') {\n    valueLength = Buffer.byteLength(value);\n  }\n\n  this._valueLength += valueLength; // @check why add CRLF? does this account for custom/multiple CRLFs?\n\n  this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length; // empty or either doesn't have path or not an http response\n\n  if (!value || !value.path && !(value.readable && value.hasOwnProperty('httpVersion'))) {\n    return;\n  } // no need to bother with the length\n\n\n  if (!options.knownLength) {\n    this._valuesToMeasure.push(value);\n  }\n};\n\nFormData.prototype._lengthRetriever = function (value, callback) {\n  if (value.hasOwnProperty('fd')) {\n    // take read range into a account\n    // `end` = Infinity â€“> read file till the end\n    //\n    // TODO: Looks like there is bug in Node fs.createReadStream\n    // it doesn't respect `end` options without `start` options\n    // Fix it when node fixes it.\n    // https://github.com/joyent/node/issues/7819\n    if (value.end != undefined && value.end != Infinity && value.start != undefined) {\n      // when end specified\n      // no need to calculate range\n      // inclusive, starts with 0\n      callback(null, value.end + 1 - (value.start ? value.start : 0)); // not that fast snoopy\n    } else {\n      // still need to fetch file size from fs\n      fs.stat(value.path, function (err, stat) {\n        var fileSize;\n\n        if (err) {\n          callback(err);\n          return;\n        } // update final size based on the range options\n\n\n        fileSize = stat.size - (value.start ? value.start : 0);\n        callback(null, fileSize);\n      });\n    } // or http response\n\n  } else if (value.hasOwnProperty('httpVersion')) {\n    callback(null, +value.headers['content-length']); // or request stream http://github.com/mikeal/request\n  } else if (value.hasOwnProperty('httpModule')) {\n    // wait till response come back\n    value.on('response', function (response) {\n      value.pause();\n      callback(null, +response.headers['content-length']);\n    });\n    value.resume(); // something else\n  } else {\n    callback('Unknown stream');\n  }\n};\n\nFormData.prototype._multiPartHeader = function (field, value, options) {\n  // custom header specified (as string)?\n  // it becomes responsible for boundary\n  // (e.g. to handle extra CRLFs on .NET servers)\n  if (typeof options.header == 'string') {\n    return options.header;\n  }\n\n  var contentDisposition = this._getContentDisposition(value, options);\n\n  var contentType = this._getContentType(value, options);\n\n  var contents = '';\n  var headers = {\n    // add custom disposition as third element or keep it two elements if not\n    'Content-Disposition': ['form-data', 'name=\"' + field + '\"'].concat(contentDisposition || []),\n    // if no content type. allow it to be empty array\n    'Content-Type': [].concat(contentType || [])\n  }; // allow custom headers.\n\n  if (typeof options.header == 'object') {\n    populate(headers, options.header);\n  }\n\n  var header;\n\n  for (var prop in headers) {\n    if (!headers.hasOwnProperty(prop)) continue;\n    header = headers[prop]; // skip nullish headers.\n\n    if (header == null) {\n      continue;\n    } // convert all headers to arrays.\n\n\n    if (!Array.isArray(header)) {\n      header = [header];\n    } // add non-empty headers.\n\n\n    if (header.length) {\n      contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;\n    }\n  }\n\n  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;\n};\n\nFormData.prototype._getContentDisposition = function (value, options) {\n  var filename, contentDisposition;\n\n  if (typeof options.filepath === 'string') {\n    // custom filepath for relative paths\n    filename = path.normalize(options.filepath).replace(/\\\\/g, '/');\n  } else if (options.filename || value.name || value.path) {\n    // custom filename take precedence\n    // formidable and the browser add a name property\n    // fs- and request- streams have path property\n    filename = path.basename(options.filename || value.name || value.path);\n  } else if (value.readable && value.hasOwnProperty('httpVersion')) {\n    // or try http response\n    filename = path.basename(value.client._httpMessage.path);\n  }\n\n  if (filename) {\n    contentDisposition = 'filename=\"' + filename + '\"';\n  }\n\n  return contentDisposition;\n};\n\nFormData.prototype._getContentType = function (value, options) {\n  // use custom content-type above all\n  var contentType = options.contentType; // or try `name` from formidable, browser\n\n  if (!contentType && value.name) {\n    contentType = mime.lookup(value.name);\n  } // or try `path` from fs-, request- streams\n\n\n  if (!contentType && value.path) {\n    contentType = mime.lookup(value.path);\n  } // or if it's http-reponse\n\n\n  if (!contentType && value.readable && value.hasOwnProperty('httpVersion')) {\n    contentType = value.headers['content-type'];\n  } // or guess it from the filepath or filename\n\n\n  if (!contentType && (options.filepath || options.filename)) {\n    contentType = mime.lookup(options.filepath || options.filename);\n  } // fallback to the default content type if `value` is not simple value\n\n\n  if (!contentType && typeof value == 'object') {\n    contentType = FormData.DEFAULT_CONTENT_TYPE;\n  }\n\n  return contentType;\n};\n\nFormData.prototype._multiPartFooter = function () {\n  return function (next) {\n    var footer = FormData.LINE_BREAK;\n    var lastPart = this._streams.length === 0;\n\n    if (lastPart) {\n      footer += this._lastBoundary();\n    }\n\n    next(footer);\n  }.bind(this);\n};\n\nFormData.prototype._lastBoundary = function () {\n  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;\n};\n\nFormData.prototype.getHeaders = function (userHeaders) {\n  var header;\n  var formHeaders = {\n    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()\n  };\n\n  for (header in userHeaders) {\n    if (userHeaders.hasOwnProperty(header)) {\n      formHeaders[header.toLowerCase()] = userHeaders[header];\n    }\n  }\n\n  return formHeaders;\n};\n\nFormData.prototype.getBoundary = function () {\n  if (!this._boundary) {\n    this._generateBoundary();\n  }\n\n  return this._boundary;\n};\n\nFormData.prototype._generateBoundary = function () {\n  // This generates a 50 character boundary similar to those used by Firefox.\n  // They are optimized for boyer-moore parsing.\n  var boundary = '--------------------------';\n\n  for (var i = 0; i < 24; i++) {\n    boundary += Math.floor(Math.random() * 10).toString(16);\n  }\n\n  this._boundary = boundary;\n}; // Note: getLengthSync DOESN'T calculate streams length\n// As workaround one can calculate file size manually\n// and add it as knownLength option\n\n\nFormData.prototype.getLengthSync = function () {\n  var knownLength = this._overheadLength + this._valueLength; // Don't get confused, there are 3 \"internal\" streams for each keyval pair\n  // so it basically checks if there is any value added to the form\n\n  if (this._streams.length) {\n    knownLength += this._lastBoundary().length;\n  } // https://github.com/form-data/form-data/issues/40\n\n\n  if (!this.hasKnownLength()) {\n    // Some async length retrievers are present\n    // therefore synchronous length calculation is false.\n    // Please use getLength(callback) to get proper length\n    this._error(new Error('Cannot calculate proper length in synchronous way.'));\n  }\n\n  return knownLength;\n}; // Public API to check if length of added values is known\n// https://github.com/form-data/form-data/issues/196\n// https://github.com/form-data/form-data/issues/262\n\n\nFormData.prototype.hasKnownLength = function () {\n  var hasKnownLength = true;\n\n  if (this._valuesToMeasure.length) {\n    hasKnownLength = false;\n  }\n\n  return hasKnownLength;\n};\n\nFormData.prototype.getLength = function (cb) {\n  var knownLength = this._overheadLength + this._valueLength;\n\n  if (this._streams.length) {\n    knownLength += this._lastBoundary().length;\n  }\n\n  if (!this._valuesToMeasure.length) {\n    process.nextTick(cb.bind(this, null, knownLength));\n    return;\n  }\n\n  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function (err, values) {\n    if (err) {\n      cb(err);\n      return;\n    }\n\n    values.forEach(function (length) {\n      knownLength += length;\n    });\n    cb(null, knownLength);\n  });\n};\n\nFormData.prototype.submit = function (params, cb) {\n  var request,\n      options,\n      defaults = {\n    method: 'post'\n  }; // parse provided url if it's string\n  // or treat it as options object\n\n  if (typeof params == 'string') {\n    params = parseUrl(params);\n    options = populate({\n      port: params.port,\n      path: params.pathname,\n      host: params.hostname,\n      protocol: params.protocol\n    }, defaults); // use custom params\n  } else {\n    options = populate(params, defaults); // if no port provided use default one\n\n    if (!options.port) {\n      options.port = options.protocol == 'https:' ? 443 : 80;\n    }\n  } // put that good code in getHeaders to some use\n\n\n  options.headers = this.getHeaders(params.headers); // https if specified, fallback to http in any other case\n\n  if (options.protocol == 'https:') {\n    request = https.request(options);\n  } else {\n    request = http.request(options);\n  } // get content length and fire away\n\n\n  this.getLength(function (err, length) {\n    if (err) {\n      this._error(err);\n\n      return;\n    } // add content length\n\n\n    request.setHeader('Content-Length', length);\n    this.pipe(request);\n\n    if (cb) {\n      request.on('error', cb);\n      request.on('response', cb.bind(this, null));\n    }\n  }.bind(this));\n  return request;\n};\n\nFormData.prototype._error = function (err) {\n  if (!this.error) {\n    this.error = err;\n    this.pause();\n    this.emit('error', err);\n  }\n};\n\nFormData.prototype.toString = function () {\n  return '[object FormData]';\n};","map":null,"metadata":{},"sourceType":"script"}