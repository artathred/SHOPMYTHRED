{"ast":null,"code":"\"use strict\";\n\nconst HTTP_STATUS_CODES = require(\"http\").STATUS_CODES;\n\nconst spawnSync = require(\"child_process\").spawnSync;\n\nconst URL = require(\"whatwg-url\").URL;\n\nconst whatwgEncoding = require(\"whatwg-encoding\");\n\nconst tough = require(\"tough-cookie\");\n\nconst parseContentType = require(\"content-type-parser\");\n\nconst xhrUtils = require(\"./xhr-utils\");\n\nconst DOMException = require(\"../web-idl/DOMException\");\n\nconst xhrSymbols = require(\"./xmlhttprequest-symbols\");\n\nconst addConstants = require(\"../utils\").addConstants;\n\nconst documentBaseURLSerialized = require(\"./helpers/document-base-url\").documentBaseURLSerialized;\n\nconst idlUtils = require(\"./generated/utils\");\n\nconst Document = require(\"./generated/Document\");\n\nconst Blob = require(\"./generated/Blob\");\n\nconst domToHtml = require(\"../browser/domtohtml\").domToHtml;\n\nconst syncWorkerFile = require.resolve ? require.resolve(\"./xhr-sync-worker.js\") : null;\nconst tokenRegexp = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/;\nconst headerListSeparatorRegexp = /,[ \\t]*/;\nconst fieldValueRegexp = /^[ \\t]*(?:[\\x21-\\x7E\\x80-\\xFF](?:[ \\t][\\x21-\\x7E\\x80-\\xFF])?)*[ \\t]*$/;\nconst forbiddenRequestHeaders = new Set([\"accept-charset\", \"accept-encoding\", \"access-control-request-headers\", \"access-control-request-method\", \"connection\", \"content-length\", \"cookie\", \"cookie2\", \"date\", \"dnt\", \"expect\", \"host\", \"keep-alive\", \"origin\", \"referer\", \"te\", \"trailer\", \"transfer-encoding\", \"upgrade\", \"via\"]);\nconst forbiddenResponseHeaders = new Set([\"set-cookie\", \"set-cookie2\"]);\nconst uniqueResponseHeaders = new Set([\"content-type\", \"content-length\", \"user-agent\", \"referer\", \"host\", \"authorization\", \"proxy-authorization\", \"if-modified-since\", \"if-unmodified-since\", \"from\", \"location\", \"max-forwards\"]);\nconst corsSafeResponseHeaders = new Set([\"cache-control\", \"content-language\", \"content-type\", \"expires\", \"last-modified\", \"pragma\"]);\nconst allowedRequestMethods = new Set([\"OPTIONS\", \"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\"]);\nconst forbiddenRequestMethods = new Set([\"TRACK\", \"TRACE\", \"CONNECT\"]);\nconst XMLHttpRequestResponseType = new Set([\"\", \"arraybuffer\", \"blob\", \"document\", \"json\", \"text\"]);\nconst simpleHeaders = xhrUtils.simpleHeaders;\nconst redirectStatuses = new Set([301, 302, 303, 307, 308]);\n\nmodule.exports = function createXMLHttpRequest(window) {\n  const Event = window.Event;\n  const ProgressEvent = window.ProgressEvent;\n  const FormData = window.FormData;\n  const XMLHttpRequestEventTarget = window.XMLHttpRequestEventTarget;\n  const XMLHttpRequestUpload = window.XMLHttpRequestUpload;\n\n  class XMLHttpRequest extends XMLHttpRequestEventTarget {\n    constructor() {\n      super();\n\n      if (!(this instanceof XMLHttpRequest)) {\n        throw new TypeError(\"DOM object constructor cannot be called as a function.\");\n      }\n\n      this.upload = new XMLHttpRequestUpload();\n      this.upload._ownerDocument = window.document;\n      this[xhrSymbols.flag] = {\n        synchronous: false,\n        withCredentials: false,\n        mimeType: null,\n        auth: null,\n        method: undefined,\n        responseType: \"\",\n        requestHeaders: {},\n        referrer: this._ownerDocument.URL,\n        uri: \"\",\n        timeout: 0,\n        body: undefined,\n        formData: false,\n        preflight: false,\n        requestManager: this._ownerDocument._requestManager,\n        pool: this._ownerDocument._pool,\n        agentOptions: this._ownerDocument._agentOptions,\n        strictSSL: this._ownerDocument._strictSSL,\n        proxy: this._ownerDocument._proxy,\n        cookieJar: this._ownerDocument._cookieJar,\n        encoding: this._ownerDocument._encoding,\n        origin: this._ownerDocument.origin,\n        userAgent: this._ownerDocument._defaultView.navigator.userAgent\n      };\n      this[xhrSymbols.properties] = {\n        beforeSend: false,\n        send: false,\n        timeoutStart: 0,\n        timeoutId: 0,\n        timeoutFn: null,\n        client: null,\n        responseHeaders: {},\n        filteredResponseHeaders: [],\n        responseBuffer: null,\n        responseCache: null,\n        responseTextCache: null,\n        responseXMLCache: null,\n        responseURL: \"\",\n        readyState: XMLHttpRequest.UNSENT,\n        status: 0,\n        statusText: \"\",\n        error: \"\",\n        uploadComplete: true,\n        abortError: false,\n        cookieJar: this._ownerDocument._cookieJar\n      };\n      this.onreadystatechange = null;\n    }\n\n    get readyState() {\n      return this[xhrSymbols.properties].readyState;\n    }\n\n    get status() {\n      return this[xhrSymbols.properties].status;\n    }\n\n    get statusText() {\n      return this[xhrSymbols.properties].statusText;\n    }\n\n    get responseType() {\n      return this[xhrSymbols.flag].responseType;\n    }\n\n    set responseType(responseType) {\n      const flag = this[xhrSymbols.flag];\n\n      if (this.readyState === XMLHttpRequest.LOADING || this.readyState === XMLHttpRequest.DONE) {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n\n      if (this.readyState === XMLHttpRequest.OPENED && flag.synchronous) {\n        throw new DOMException(DOMException.INVALID_ACCESS_ERR);\n      }\n\n      if (!XMLHttpRequestResponseType.has(responseType)) {\n        responseType = \"\";\n      }\n\n      flag.responseType = responseType;\n    }\n\n    get response() {\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n\n      if (properties.responseCache) {\n        return properties.responseCache;\n      }\n\n      let res = \"\";\n\n      switch (this.responseType) {\n        case \"\":\n        case \"text\":\n          {\n            res = this.responseText;\n            break;\n          }\n\n        case \"arraybuffer\":\n          {\n            if (!properties.responseBuffer) {\n              return null;\n            }\n\n            res = new Uint8Array(properties.responseBuffer).buffer;\n            break;\n          }\n\n        case \"blob\":\n          {\n            if (!properties.responseBuffer) {\n              return null;\n            }\n\n            const contentType = getContentType(this);\n            res = Blob.create([[new Uint8Array(properties.responseBuffer)], {\n              type: contentType && contentType.toString() || \"\"\n            }]);\n            break;\n          }\n\n        case \"document\":\n          {\n            res = this.responseXML;\n            break;\n          }\n\n        case \"json\":\n          {\n            if (this.readyState !== XMLHttpRequest.DONE || !properties.responseBuffer) {\n              res = null;\n            }\n\n            const contentType = getContentType(this);\n            const fallbackEncoding = whatwgEncoding.labelToName(contentType && contentType.get(\"charset\") || flag.encoding);\n            const jsonStr = whatwgEncoding.decode(properties.responseBuffer, fallbackEncoding);\n\n            try {\n              res = JSON.parse(jsonStr);\n            } catch (e) {\n              res = null;\n            }\n\n            break;\n          }\n      }\n\n      properties.responseCache = res;\n      return res;\n    }\n\n    get responseText() {\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n\n      if (this.responseType !== \"\" && this.responseType !== \"text\") {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n\n      if (this.readyState !== XMLHttpRequest.LOADING && this.readyState !== XMLHttpRequest.DONE) {\n        return \"\";\n      }\n\n      if (properties.responseTextCache) {\n        return properties.responseTextCache;\n      }\n\n      const responseBuffer = properties.responseBuffer;\n\n      if (!responseBuffer) {\n        return \"\";\n      }\n\n      const contentType = getContentType(this);\n      const fallbackEncoding = whatwgEncoding.labelToName(contentType && contentType.get(\"charset\") || flag.encoding);\n      const res = whatwgEncoding.decode(responseBuffer, fallbackEncoding);\n      properties.responseTextCache = res;\n      return res;\n    }\n\n    get responseXML() {\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n\n      if (this.responseType !== \"\" && this.responseType !== \"document\") {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n\n      if (this.readyState !== XMLHttpRequest.DONE) {\n        return null;\n      }\n\n      if (properties.responseXMLCache) {\n        return properties.responseXMLCache;\n      }\n\n      const responseBuffer = properties.responseBuffer;\n\n      if (!responseBuffer) {\n        return null;\n      }\n\n      const contentType = getContentType(this);\n      let isHTML = false;\n      let isXML = false;\n\n      if (contentType) {\n        isHTML = contentType.isHTML();\n        isXML = contentType.isXML();\n\n        if (!isXML && !isHTML) {\n          return null;\n        }\n      }\n\n      const encoding = whatwgEncoding.getBOMEncoding(responseBuffer) || whatwgEncoding.labelToName(contentType && contentType.get(\"charset\") || flag.encoding);\n      const resText = whatwgEncoding.decode(responseBuffer, encoding);\n\n      if (!resText) {\n        return null;\n      }\n\n      if (this.responseType === \"\" && isHTML) {\n        return null;\n      }\n\n      const res = Document.create([], {\n        core: window._core,\n        options: {\n          url: flag.uri,\n          lastModified: new Date(getResponseHeader(this, \"last-modified\")),\n          parsingMode: isHTML ? \"html\" : \"xml\",\n          cookieJar: {\n            setCookieSync: () => undefined,\n            getCookieStringSync: () => \"\"\n          },\n          encoding\n        }\n      });\n      const resImpl = idlUtils.implForWrapper(res);\n\n      try {\n        resImpl._htmlToDom.appendHtmlToDocument(resText, resImpl);\n      } catch (e) {\n        properties.responseXMLCache = null;\n        return null;\n      }\n\n      res.close();\n      properties.responseXMLCache = res;\n      return res;\n    }\n\n    get responseURL() {\n      return this[xhrSymbols.properties].responseURL;\n    }\n\n    get timeout() {\n      return this[xhrSymbols.flag].timeout;\n    }\n\n    set timeout(val) {\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n\n      if (flag.synchronous) {\n        throw new DOMException(DOMException.INVALID_ACCESS_ERR);\n      }\n\n      flag.timeout = val;\n      clearTimeout(properties.timeoutId);\n\n      if (val > 0 && properties.timeoutFn) {\n        properties.timeoutId = setTimeout(properties.timeoutFn, Math.max(0, val - (new Date().getTime() - properties.timeoutStart)));\n      } else {\n        properties.timeoutFn = null;\n        properties.timeoutStart = 0;\n      }\n    }\n\n    get withCredentials() {\n      return this[xhrSymbols.flag].withCredentials;\n    }\n\n    set withCredentials(val) {\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n\n      if (!(this.readyState === XMLHttpRequest.UNSENT || this.readyState === XMLHttpRequest.OPENED)) {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n\n      if (properties.send) {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n\n      flag.withCredentials = val;\n    }\n\n    abort() {\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties]; // Terminate the request\n\n      clearTimeout(properties.timeoutId);\n      properties.timeoutFn = null;\n      properties.timeoutStart = 0;\n      const client = properties.client;\n\n      if (client) {\n        client.abort();\n        properties.client = null;\n      }\n\n      if (this.readyState === XMLHttpRequest.OPENED && properties.send || this.readyState === XMLHttpRequest.HEADERS_RECEIVED || this.readyState === XMLHttpRequest.LOADING) {\n        // Run the request error steps for event abort\n        properties.readyState = XMLHttpRequest.DONE;\n        properties.send = false;\n        properties.status = 0;\n        properties.statusText = \"\";\n        properties.responseCache = properties.responseTextCache = properties.responseXMLCache = null;\n\n        if (flag.synchronous) {\n          throw new DOMException(DOMException.ABORT_ERR);\n        }\n\n        this.dispatchEvent(new Event(\"readystatechange\")); // TODO: spec says this should only be checking upload complete flag?\n\n        if (!(flag.method === \"HEAD\" || flag.method === \"GET\")) {\n          properties.uploadComplete = true; // TODO upload listener\n\n          this.upload.dispatchEvent(new ProgressEvent(\"abort\"));\n\n          if (properties.abortError) {\n            // TODO document what this is about (here and below)\n            this.upload.dispatchEvent(new ProgressEvent(\"error\"));\n          }\n\n          this.upload.dispatchEvent(new ProgressEvent(\"loadend\"));\n        }\n\n        this.dispatchEvent(new ProgressEvent(\"abort\"));\n\n        if (properties.abortError) {\n          this.dispatchEvent(new ProgressEvent(\"error\"));\n        }\n\n        this.dispatchEvent(new ProgressEvent(\"loadend\"));\n      }\n\n      if (this.readyState === XMLHttpRequest.DONE) {\n        properties.readyState = XMLHttpRequest.UNSENT;\n        properties.status = 0;\n        properties.statusText = \"\";\n        properties.responseCache = properties.responseTextCache = properties.responseXMLCache = null;\n      }\n    }\n\n    getAllResponseHeaders() {\n      const properties = this[xhrSymbols.properties];\n      const readyState = this.readyState;\n\n      if (readyState === XMLHttpRequest.UNSENT || readyState === XMLHttpRequest.OPENED) {\n        return \"\";\n      }\n\n      return Object.keys(properties.responseHeaders).filter(key => properties.filteredResponseHeaders.indexOf(key) === -1).map(key => [key, properties.responseHeaders[key]].join(\": \")).join(\"\\r\\n\");\n    }\n\n    getResponseHeader(header) {\n      const properties = this[xhrSymbols.properties];\n      const readyState = this.readyState;\n\n      if (readyState === XMLHttpRequest.UNSENT || readyState === XMLHttpRequest.OPENED) {\n        return null;\n      }\n\n      const lcHeader = toByteString(header).toLowerCase();\n\n      if (properties.filteredResponseHeaders.find(filtered => lcHeader === filtered.toLowerCase())) {\n        return null;\n      }\n\n      return getResponseHeader(this, lcHeader);\n    }\n\n    open(method, uri, asynchronous, user, password) {\n      if (!this._ownerDocument) {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n      const argumentCount = arguments.length;\n\n      if (argumentCount < 2) {\n        throw new TypeError(\"Not enought arguments\");\n      }\n\n      method = toByteString(method);\n\n      if (!tokenRegexp.test(method)) {\n        throw new DOMException(DOMException.SYNTAX_ERR);\n      }\n\n      const upperCaseMethod = method.toUpperCase();\n\n      if (forbiddenRequestMethods.has(upperCaseMethod)) {\n        throw new DOMException(DOMException.SECURITY_ERR);\n      }\n\n      const client = properties.client;\n\n      if (client && typeof client.abort === \"function\") {\n        client.abort();\n      }\n\n      if (allowedRequestMethods.has(upperCaseMethod)) {\n        method = upperCaseMethod;\n      }\n\n      if (typeof asynchronous !== \"undefined\") {\n        flag.synchronous = !asynchronous;\n      } else {\n        flag.synchronous = false;\n      }\n\n      if (flag.responseType && flag.synchronous) {\n        throw new DOMException(DOMException.INVALID_ACCESS_ERR);\n      }\n\n      if (flag.synchronous && flag.timeout) {\n        throw new DOMException(DOMException.INVALID_ACCESS_ERR);\n      }\n\n      flag.method = method;\n      let urlObj;\n\n      try {\n        urlObj = new URL(uri, documentBaseURLSerialized(this._ownerDocument));\n      } catch (e) {\n        throw new DOMException(DOMException.SYNTAX_ERR);\n      }\n\n      if (user || password && !urlObj.username) {\n        flag.auth = {\n          user,\n          pass: password\n        };\n        urlObj.username = \"\";\n        urlObj.password = \"\";\n      }\n\n      flag.uri = urlObj.href;\n      flag.requestHeaders = {};\n      flag.preflight = false;\n      properties.send = false;\n      properties.requestBuffer = null;\n      properties.requestCache = null;\n      properties.abortError = false;\n      properties.responseURL = \"\";\n      readyStateChange(this, XMLHttpRequest.OPENED);\n    }\n\n    overrideMimeType(mime) {\n      const readyState = this.readyState;\n\n      if (readyState === XMLHttpRequest.LOADING || readyState === XMLHttpRequest.DONE) {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n\n      if (!mime) {\n        throw new DOMException(DOMException.SYNTAX_ERR);\n      }\n\n      mime = String(mime);\n\n      if (!parseContentType(mime)) {\n        throw new DOMException(DOMException.SYNTAX_ERR);\n      }\n\n      this[xhrSymbols.flag].mimeType = mime;\n    }\n\n    send(body) {\n      if (!this._ownerDocument) {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n\n      if (this.readyState !== XMLHttpRequest.OPENED || properties.send) {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n\n      properties.beforeSend = true;\n\n      try {\n        if (!flag.body && body !== undefined && body !== null && body !== \"\" && !(flag.method === \"HEAD\" || flag.method === \"GET\")) {\n          let contentType = null;\n          let encoding = null;\n\n          if (body instanceof FormData) {\n            flag.formData = true;\n            const formData = [];\n\n            for (const entry of idlUtils.implForWrapper(body)._entries) {\n              let val;\n\n              if (Blob.isImpl(entry.value)) {\n                const blob = entry.value;\n                val = {\n                  name: entry.name,\n                  value: blob._buffer,\n                  options: {\n                    filename: blob.name,\n                    contentType: blob.type,\n                    knownLength: blob.size\n                  }\n                };\n              } else {\n                val = entry;\n              }\n\n              formData.push(val);\n            }\n\n            flag.body = formData; // TODO content type; what is the form boundary?\n          } else if (Blob.is(body)) {\n            const blob = idlUtils.implForWrapper(body);\n            flag.body = blob._buffer;\n\n            if (blob.type !== \"\") {\n              contentType = blob.type;\n            }\n          } else if (body instanceof ArrayBuffer) {\n            flag.body = new Buffer(new Uint8Array(body));\n          } else if (body instanceof Document.interface) {\n            if (body.childNodes.length === 0) {\n              throw new DOMException(DOMException.INVALID_STATE_ERR);\n            }\n\n            flag.body = domToHtml([body]);\n            encoding = \"UTF-8\";\n\n            const documentBodyParsingMode = idlUtils.implForWrapper(body)._parsingMode;\n\n            contentType = documentBodyParsingMode === \"html\" ? \"text/html\" : \"application/xml\";\n            contentType += \";charset=UTF-8\";\n          } else if (typeof body !== \"string\") {\n            flag.body = String(body);\n          } else {\n            flag.body = body;\n            contentType = \"text/plain;charset=UTF-8\";\n            encoding = \"UTF-8\";\n          }\n\n          const existingContentType = xhrUtils.getRequestHeader(flag.requestHeaders, \"content-type\");\n\n          if (contentType !== null && existingContentType === null) {\n            flag.requestHeaders[\"Content-Type\"] = contentType;\n          } else if (existingContentType !== null && encoding !== null) {\n            const parsed = parseContentType(existingContentType);\n\n            if (parsed) {\n              parsed.parameterList.filter(v => v.key && v.key.toLowerCase() === \"charset\" && whatwgEncoding.labelToName(v.value) !== \"UTF-8\").forEach(v => {\n                v.value = \"UTF-8\";\n              });\n              xhrUtils.updateRequestHeader(flag.requestHeaders, \"content-type\", parsed.toString());\n            }\n          }\n        }\n      } finally {\n        if (properties.beforeSend) {\n          properties.beforeSend = false;\n        } else {\n          throw new DOMException(DOMException.INVALID_STATE_ERR);\n        }\n      }\n\n      if (flag.synchronous) {\n        const flagStr = JSON.stringify(flag, function (k, v) {\n          if (this === flag && k === \"requestManager\") {\n            return null;\n          }\n\n          if (this === flag && k === \"pool\" && v) {\n            return {\n              maxSockets: v.maxSockets\n            };\n          }\n\n          return v;\n        });\n        const res = spawnSync(process.execPath, [syncWorkerFile], {\n          input: flagStr\n        });\n\n        if (res.status !== 0) {\n          throw new Error(res.stderr.toString());\n        }\n\n        if (res.error) {\n          if (typeof res.error === \"string\") {\n            res.error = new Error(res.error);\n          }\n\n          throw res.error;\n        }\n\n        const response = JSON.parse(res.stdout.toString(), (k, v) => {\n          if (k === \"responseBuffer\" && v && v.data) {\n            return new Buffer(v.data);\n          }\n\n          if (k === \"cookieJar\" && v) {\n            return tough.CookieJar.deserializeSync(v, this._ownerDocument._cookieJar.store);\n          }\n\n          return v;\n        });\n        response.properties.readyState = XMLHttpRequest.LOADING;\n        this[xhrSymbols.properties] = response.properties;\n\n        if (response.properties.error) {\n          dispatchError(this);\n          throw new DOMException(DOMException.NETWORK_ERR, response.properties.error);\n        } else {\n          const responseBuffer = this[xhrSymbols.properties].responseBuffer;\n          const contentLength = getResponseHeader(this, \"content-length\") || \"0\";\n          const bufferLength = parseInt(contentLength) || responseBuffer.length;\n          const progressObj = {\n            lengthComputable: false\n          };\n\n          if (bufferLength !== 0) {\n            progressObj.total = bufferLength;\n            progressObj.loaded = bufferLength;\n            progressObj.lengthComputable = true;\n          }\n\n          this.dispatchEvent(new ProgressEvent(\"progress\", progressObj));\n          readyStateChange(this, XMLHttpRequest.DONE);\n          this.dispatchEvent(new ProgressEvent(\"load\", progressObj));\n          this.dispatchEvent(new ProgressEvent(\"loadend\", progressObj));\n        }\n      } else {\n        properties.send = true;\n        this.dispatchEvent(new ProgressEvent(\"loadstart\"));\n        const client = xhrUtils.createClient(this);\n        properties.client = client;\n        properties.origin = flag.origin;\n        client.on(\"error\", err => {\n          client.removeAllListeners();\n          properties.error = err;\n          dispatchError(this);\n        });\n        client.on(\"response\", res => receiveResponse(this, res));\n        client.on(\"redirect\", () => {\n          if (flag.preflight) {\n            properties.error = \"Redirect after preflight forbidden\";\n            dispatchError(this);\n            client.abort();\n            return;\n          }\n\n          const response = client.response;\n          const destUrlObj = new URL(response.request.headers.Referer);\n          const urlObj = new URL(response.request.uri.href);\n\n          if (destUrlObj.origin !== urlObj.origin && destUrlObj.origin !== flag.origin) {\n            properties.origin = \"null\";\n          }\n\n          response.request.headers.Origin = properties.origin;\n\n          if (flag.origin !== destUrlObj.origin && destUrlObj.protocol !== \"data:\") {\n            if (!validCORSHeaders(this, response, flag, properties, flag.origin)) {\n              return;\n            }\n\n            if (urlObj.username || urlObj.password || response.request.uri.href.match(/^https?:\\/\\/:@/)) {\n              properties.error = \"Userinfo forbidden in cors redirect\";\n              dispatchError(this);\n              return;\n            }\n          }\n        });\n\n        if (body !== undefined && body !== null && body !== \"\" && !(flag.method === \"HEAD\" || flag.method === \"GET\")) {\n          properties.uploadComplete = false;\n          setDispatchProgressEvents(this);\n        } else {\n          properties.uploadComplete = true;\n        }\n\n        if (this.timeout > 0) {\n          properties.timeoutStart = new Date().getTime();\n\n          properties.timeoutFn = () => {\n            client.abort();\n\n            if (!(this.readyState === XMLHttpRequest.UNSENT || this.readyState === XMLHttpRequest.OPENED && !properties.send || this.readyState === XMLHttpRequest.DONE)) {\n              properties.send = false;\n              let stateChanged = false;\n\n              if (!(flag.method === \"HEAD\" || flag.method === \"GET\")) {\n                this.upload.dispatchEvent(new ProgressEvent(\"progress\"));\n                readyStateChange(this, XMLHttpRequest.DONE);\n                this.upload.dispatchEvent(new ProgressEvent(\"timeout\"));\n                this.upload.dispatchEvent(new ProgressEvent(\"loadend\"));\n                stateChanged = true;\n              }\n\n              this.dispatchEvent(new ProgressEvent(\"progress\"));\n\n              if (!stateChanged) {\n                readyStateChange(this, XMLHttpRequest.DONE);\n              }\n\n              this.dispatchEvent(new ProgressEvent(\"timeout\"));\n              this.dispatchEvent(new ProgressEvent(\"loadend\"));\n            }\n\n            properties.readyState = XMLHttpRequest.UNSENT;\n          };\n\n          properties.timeoutId = setTimeout(properties.timeoutFn, this.timeout);\n        }\n      }\n\n      flag.body = undefined;\n      flag.formData = false;\n    }\n\n    setRequestHeader(header, value) {\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n\n      if (arguments.length !== 2) {\n        throw new TypeError(\"2 arguments required for setRequestHeader\");\n      }\n\n      header = toByteString(header);\n      value = toByteString(value);\n\n      if (this.readyState !== XMLHttpRequest.OPENED || properties.send) {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n\n      value = normalizeHeaderValue(value);\n\n      if (!tokenRegexp.test(header) || !fieldValueRegexp.test(value)) {\n        throw new DOMException(DOMException.SYNTAX_ERR);\n      }\n\n      const lcHeader = header.toLowerCase();\n\n      if (forbiddenRequestHeaders.has(lcHeader) || lcHeader.startsWith(\"sec-\") || lcHeader.startsWith(\"proxy-\")) {\n        return;\n      }\n\n      const keys = Object.keys(flag.requestHeaders);\n      let n = keys.length;\n\n      while (n--) {\n        const key = keys[n];\n\n        if (key.toLowerCase() === lcHeader) {\n          flag.requestHeaders[key] += \",\" + value;\n          return;\n        }\n      }\n\n      flag.requestHeaders[lcHeader] = value;\n    }\n\n    toString() {\n      return \"[object XMLHttpRequest]\";\n    }\n\n    get _ownerDocument() {\n      return idlUtils.implForWrapper(window.document);\n    }\n\n  }\n\n  addConstants(XMLHttpRequest, {\n    UNSENT: 0,\n    OPENED: 1,\n    HEADERS_RECEIVED: 2,\n    LOADING: 3,\n    DONE: 4\n  });\n\n  function readyStateChange(xhr, readyState) {\n    const properties = xhr[xhrSymbols.properties];\n\n    if (properties.readyState === readyState) {\n      return;\n    }\n\n    properties.readyState = readyState;\n    const readyStateChangeEvent = new Event(\"readystatechange\");\n    xhr.dispatchEvent(readyStateChangeEvent);\n  }\n\n  function receiveResponse(xhr, response) {\n    const properties = xhr[xhrSymbols.properties];\n    const flag = xhr[xhrSymbols.flag];\n    const statusCode = response.statusCode;\n\n    if (flag.preflight && redirectStatuses.has(statusCode)) {\n      properties.error = \"Redirect after preflight forbidden\";\n      dispatchError(this);\n      return;\n    }\n\n    let byteOffset = 0;\n    const headers = {};\n    const filteredResponseHeaders = [];\n    const headerMap = {};\n    const rawHeaders = response.rawHeaders;\n    const n = Number(rawHeaders.length);\n\n    for (let i = 0; i < n; i += 2) {\n      const k = rawHeaders[i];\n      const kl = k.toLowerCase();\n      const v = rawHeaders[i + 1];\n\n      if (uniqueResponseHeaders.has(kl)) {\n        if (headerMap[kl] !== undefined) {\n          delete headers[headerMap[kl]];\n        }\n\n        headers[k] = v;\n      } else if (headerMap[kl] !== undefined) {\n        headers[headerMap[kl]] += \", \" + v;\n      } else {\n        headers[k] = v;\n      }\n\n      headerMap[kl] = k;\n    }\n\n    const destUrlObj = new URL(response.request.uri.href);\n\n    if (properties.origin !== destUrlObj.origin && destUrlObj.protocol !== \"data:\") {\n      if (!validCORSHeaders(xhr, response, flag, properties, properties.origin)) {\n        return;\n      }\n\n      const acehStr = response.headers[\"access-control-expose-headers\"];\n      const aceh = new Set(acehStr ? acehStr.trim().toLowerCase().split(headerListSeparatorRegexp) : []);\n\n      for (const header in headers) {\n        const lcHeader = header.toLowerCase();\n\n        if (!corsSafeResponseHeaders.has(lcHeader) && !aceh.has(lcHeader)) {\n          filteredResponseHeaders.push(header);\n        }\n      }\n    }\n\n    for (const header in headers) {\n      const lcHeader = header.toLowerCase();\n\n      if (forbiddenResponseHeaders.has(lcHeader)) {\n        filteredResponseHeaders.push(header);\n      }\n    }\n\n    properties.responseURL = destUrlObj.href;\n    properties.status = statusCode;\n    properties.statusText = response.statusMessage || HTTP_STATUS_CODES[statusCode] || \"\";\n    properties.responseHeaders = headers;\n    properties.filteredResponseHeaders = filteredResponseHeaders;\n    const contentLength = getResponseHeader(xhr, \"content-length\") || \"0\";\n    const bufferLength = parseInt(contentLength) || 0;\n    const progressObj = {\n      lengthComputable: false\n    };\n    let lastProgressReported;\n\n    if (bufferLength !== 0) {\n      progressObj.total = bufferLength;\n      progressObj.loaded = 0;\n      progressObj.lengthComputable = true;\n    }\n\n    properties.responseBuffer = new Buffer(0);\n    properties.responseCache = null;\n    properties.responseTextCache = null;\n    properties.responseXMLCache = null;\n    readyStateChange(xhr, XMLHttpRequest.HEADERS_RECEIVED); // Can't use the client since the client gets the post-ungzipping bytes (which can be greater than the\n    // Content-Length).\n\n    response.on(\"data\", chunk => {\n      byteOffset += chunk.length;\n      progressObj.loaded = byteOffset;\n    });\n    properties.client.on(\"data\", chunk => {\n      properties.responseBuffer = Buffer.concat([properties.responseBuffer, chunk]);\n      properties.responseCache = null;\n      properties.responseTextCache = null;\n      properties.responseXMLCache = null;\n\n      if (properties.readyState === XMLHttpRequest.HEADERS_RECEIVED) {\n        properties.readyState = XMLHttpRequest.LOADING;\n      }\n\n      xhr.dispatchEvent(new Event(\"readystatechange\"));\n\n      if (progressObj.total !== progressObj.loaded || properties.responseBuffer.length === byteOffset) {\n        if (lastProgressReported !== progressObj.loaded) {\n          // This is a necessary check in the gzip case where we can be getting new data from the client, as it\n          // un-gzips, but no new data has been gotten from the response, so we should not fire a progress event.\n          lastProgressReported = progressObj.loaded;\n          xhr.dispatchEvent(new ProgressEvent(\"progress\", progressObj));\n        }\n      }\n    });\n    properties.client.on(\"end\", () => {\n      clearTimeout(properties.timeoutId);\n      properties.timeoutFn = null;\n      properties.timeoutStart = 0;\n      properties.client = null;\n      xhr.dispatchEvent(new ProgressEvent(\"progress\", progressObj));\n      readyStateChange(xhr, XMLHttpRequest.DONE);\n      xhr.dispatchEvent(new ProgressEvent(\"load\", progressObj));\n      xhr.dispatchEvent(new ProgressEvent(\"loadend\", progressObj));\n    });\n  }\n\n  function setDispatchProgressEvents(xhr) {\n    const properties = xhr[xhrSymbols.properties];\n    const client = properties.client;\n    const upload = xhr.upload;\n    let total = 0;\n    let lengthComputable = false;\n    const length = client.headers && parseInt(xhrUtils.getRequestHeader(client.headers, \"content-length\"));\n\n    if (length) {\n      total = length;\n      lengthComputable = true;\n    }\n\n    const initProgress = {\n      lengthComputable,\n      total,\n      loaded: 0\n    };\n    upload.dispatchEvent(new ProgressEvent(\"loadstart\", initProgress));\n    client.on(\"request\", req => {\n      req.on(\"response\", () => {\n        properties.uploadComplete = true;\n        const progress = {\n          lengthComputable,\n          total,\n          loaded: total\n        };\n        upload.dispatchEvent(new ProgressEvent(\"progress\", progress));\n        upload.dispatchEvent(new ProgressEvent(\"load\", progress));\n        upload.dispatchEvent(new ProgressEvent(\"loadend\", progress));\n      });\n    });\n  }\n\n  function dispatchError(xhr) {\n    const properties = xhr[xhrSymbols.properties];\n    readyStateChange(xhr, XMLHttpRequest.DONE);\n\n    if (!properties.uploadComplete) {\n      xhr.upload.dispatchEvent(new ProgressEvent(\"error\"));\n      xhr.upload.dispatchEvent(new ProgressEvent(\"loadend\"));\n    }\n\n    xhr.dispatchEvent(new ProgressEvent(\"error\"));\n    xhr.dispatchEvent(new ProgressEvent(\"loadend\"));\n\n    if (xhr._ownerDocument) {\n      const error = new Error(properties.error);\n      error.type = \"XMLHttpRequest\";\n\n      xhr._ownerDocument._defaultView._virtualConsole.emit(\"jsdomError\", error);\n    }\n  }\n\n  function validCORSHeaders(xhr, response, flag, properties, origin) {\n    const acaoStr = response.headers[\"access-control-allow-origin\"];\n    const acao = acaoStr ? acaoStr.trim() : null;\n\n    if (acao !== \"*\" && acao !== origin) {\n      properties.error = \"Cross origin \" + origin + \" forbidden\";\n      dispatchError(xhr);\n      return false;\n    }\n\n    const acacStr = response.headers[\"access-control-allow-credentials\"];\n    const acac = acacStr ? acacStr.trim() : null;\n\n    if (flag.withCredentials && acac !== \"true\") {\n      properties.error = \"Credentials forbidden\";\n      dispatchError(xhr);\n      return false;\n    }\n\n    const acahStr = response.headers[\"access-control-allow-headers\"];\n    const acah = new Set(acahStr ? acahStr.trim().toLowerCase().split(headerListSeparatorRegexp) : []);\n    const forbiddenHeaders = Object.keys(flag.requestHeaders).filter(header => {\n      const lcHeader = header.toLowerCase();\n      return !simpleHeaders.has(lcHeader) && !acah.has(lcHeader);\n    });\n\n    if (forbiddenHeaders.length > 0) {\n      properties.error = \"Headers \" + forbiddenHeaders + \" forbidden\";\n      dispatchError(xhr);\n      return false;\n    }\n\n    return true;\n  }\n\n  function toByteString(value) {\n    value = String(value);\n\n    if (!/^[\\0-\\xFF]*$/.test(value)) {\n      throw new TypeError(\"invalid ByteString\");\n    }\n\n    return value;\n  }\n\n  function getContentType(xhr) {\n    const flag = xhr[xhrSymbols.flag];\n    return parseContentType(flag.mimeType || getResponseHeader(xhr, \"content-type\"));\n  }\n\n  function getResponseHeader(xhr, lcHeader) {\n    const properties = xhr[xhrSymbols.properties];\n    const keys = Object.keys(properties.responseHeaders);\n    let n = keys.length;\n\n    while (n--) {\n      const key = keys[n];\n\n      if (key.toLowerCase() === lcHeader) {\n        return properties.responseHeaders[key];\n      }\n    }\n\n    return null;\n  }\n\n  function normalizeHeaderValue(value) {\n    return value.replace(/^[\\x09\\x0A\\x0D\\x20]+/, \"\").replace(/[\\x09\\x0A\\x0D\\x20]+$/, \"\");\n  }\n\n  return XMLHttpRequest;\n};","map":null,"metadata":{},"sourceType":"script"}