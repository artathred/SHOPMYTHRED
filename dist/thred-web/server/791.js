exports.id=791,exports.ids=[791],exports.modules={74791:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{elementScroll:()=>elementScroll,elementScrollBy:()=>elementScrollBy,elementScrollByPolyfill:()=>elementScrollByPolyfill,elementScrollIntoView:()=>elementScrollIntoView,elementScrollIntoViewPolyfill:()=>elementScrollIntoViewPolyfill,elementScrollPolyfill:()=>elementScrollPolyfill,elementScrollTo:()=>elementScrollTo,elementScrollToPolyfill:()=>elementScrollToPolyfill,modifyWindow:()=>modifyWindow,polyfill:()=>polyfill,scroll:()=>scroll_scroll,scrollBy:()=>scrollBy,scrollIntoView:()=>scrollIntoView,scrollTo:()=>scrollTo,windowScroll:()=>windowScroll,windowScrollBy:()=>windowScrollBy,windowScrollByPolyfill:()=>windowScrollByPolyfill,windowScrollPolyfill:()=>windowScrollPolyfill,windowScrollTo:()=>windowScrollTo,windowScrollToPolyfill:()=>windowScrollToPolyfill});const checkBehavior=behavior=>void 0===behavior||"auto"===behavior||"instant"===behavior||"smooth"===behavior;function elementScrollXY(x,y){this.scrollLeft=x,this.scrollTop=y}const failedExecute=(method,object,reason="cannot convert to dictionary.")=>`Failed to execute '${method}' on '${object}': ${reason}`,failedExecuteInvalidEnumValue=(method,object,value)=>failedExecute(method,object,`The provided value '${value}' is not a valid enum value of type ScrollBehavior.`),backupMethod=(proto,method,fallback)=>{const backup=`__SEAMLESS.BACKUP$${method}`;return proto[backup]||!proto[method]||proto[method]?.__isPolyfill||(proto[backup]=proto[method]),proto[backup]||fallback},isObject=value=>{const type=typeof value;return null!==value&&("object"===type||"function"===type)},isScrollBehaviorSupported=()=>"scrollBehavior"in window.document.documentElement.style,markPolyfill=method=>{Object.defineProperty(method,"__isPolyfill",{value:!0})},modifyPrototypes=(prop,func)=>{markPolyfill(func),[HTMLElement.prototype,SVGElement.prototype,Element.prototype].forEach(prototype=>{backupMethod(prototype,prop),prototype[prop]=func})},scrollingElement=element=>element.ownerDocument.scrollingElement||element.ownerDocument.documentElement,ease=k=>.5*(1-Math.cos(Math.PI*k)),now=()=>window.performance?.now?.()??window.Date.now(),step=context=>{const elapsed=(now()-context.timeStamp)/(context.duration||500);if(elapsed>1)return context.method(context.targetX,context.targetY),void context.callback();const value=(context.timingFunc||ease)(elapsed),currentX=context.startX+(context.targetX-context.startX)*value,currentY=context.startY+(context.targetY-context.startY)*value;context.method(currentX,currentY),context.rafId=window.requestAnimationFrame(()=>{step(context)})},nonFinite=value=>isFinite(value)?Number(value):0,createScroll=scrollName=>(target,scrollOptions,config)=>{const[element,scrollType]=(obj=target).window===obj?[scrollingElement(target.document.documentElement),"Window"]:[target,"Element"];var obj;const options=scrollOptions??{};if(!isObject(options))throw new TypeError(failedExecute(scrollName,scrollType));if(!checkBehavior(options.behavior))throw new TypeError(failedExecuteInvalidEnumValue(scrollName,scrollType,options.behavior));"scrollBy"===scrollName&&(options.left=nonFinite(options.left)+element.scrollLeft,options.top=nonFinite(options.top)+element.scrollTop),((element,options,config)=>{if((node=element).isConnected??(node.ownerDocument&&1&node.ownerDocument.compareDocumentPosition(node)))return;var node;const startX=element.scrollLeft,startY=element.scrollTop,targetX=nonFinite(options.left??startX),targetY=nonFinite(options.top??startY);if(targetX===startX&&targetY===startY)return;const fallback=backupMethod(HTMLElement.prototype,"scroll",elementScrollXY),method=backupMethod(Object.getPrototypeOf(element),"scroll",fallback).bind(element);if("smooth"!==options.behavior)return void method(targetX,targetY);const removeEventListener=()=>{window.removeEventListener("wheel",cancelScroll),window.removeEventListener("touchmove",cancelScroll)},context={...config,timeStamp:now(),startX:startX,startY:startY,targetX:targetX,targetY:targetY,rafId:0,method:method,callback:removeEventListener},cancelScroll=()=>{window.cancelAnimationFrame(context.rafId),removeEventListener()};window.addEventListener("wheel",cancelScroll,{passive:!0,once:!0}),window.addEventListener("touchmove",cancelScroll,{passive:!0,once:!0}),step(context)})(element,options,config)},scroll_scroll=createScroll("scroll"),scrollTo=createScroll("scrollTo"),scrollBy=createScroll("scrollBy"),elementScroll=scroll_scroll,elementScrollTo=scrollTo,elementScrollBy=scrollBy,windowScroll=scroll_scroll,windowScrollTo=scrollTo,windowScrollBy=scrollBy,normalizeWritingMode=writingMode=>{switch(writingMode){case"horizontal-tb":case"lr":case"lr-tb":case"rl":case"rl-tb":return 0;case"vertical-rl":case"tb":case"tb-rl":return 1;case"vertical-lr":case"tb-lr":return 2;case"sideways-rl":return 3;case"sideways-lr":return 4}return 0},calcPhysicalAxis=(writingMode,isLTR,hPos,vPos)=>{let layout=0;switch(isLTR||(layout^=2),writingMode){case 0:layout=layout>>1|(1&layout)<<1,[hPos,vPos]=[vPos,hPos];break;case 1:case 3:layout^=1;break;case 4:layout^=2}return[layout,hPos,vPos]},isXReversed=computedStyle=>1==(1&calcPhysicalAxis(normalizeWritingMode(computedStyle.writingMode),"rtl"!==computedStyle.direction,void 0,void 0)[0]),mapNearest=(align,scrollingEdgeStart,scrollingEdgeEnd,scrollingSize,elementEdgeStart,elementEdgeEnd,elementSize)=>0!==align?align:elementEdgeStart<scrollingEdgeStart&&elementEdgeEnd>scrollingEdgeEnd||elementEdgeStart>scrollingEdgeStart&&elementEdgeEnd<scrollingEdgeEnd?null:elementEdgeStart<=scrollingEdgeStart&&elementSize<=scrollingSize||elementEdgeEnd>=scrollingEdgeEnd&&elementSize>=scrollingSize?2:elementEdgeEnd>scrollingEdgeEnd&&elementSize<scrollingSize||elementEdgeStart<scrollingEdgeStart&&elementSize>scrollingSize?3:null,canOverflow=overflow=>"visible"!==overflow&&"clip"!==overflow,isScrollable=(element,computedStyle)=>(element.clientHeight<element.scrollHeight||element.clientWidth<element.scrollWidth)&&(canOverflow(computedStyle.overflowY)||canOverflow(computedStyle.overflowX)||element===scrollingElement(element)),parentElement=element=>{const pNode=element.parentNode,pElement=element.parentElement;if(null===pElement&&null!==pNode){if(11===pNode.nodeType)return pNode.host;if(9===pNode.nodeType)return(element=>{try{return element.ownerDocument.defaultView?.frameElement||null}catch{return null}})(element)}return pElement},clamp=(value,min,max)=>value<min?min:value>max?max:value,calcAlignEdge=(align,start,end)=>{switch(align){case 1:return(start+end)/2;case 3:return end;case 2:case 0:return start}},getFrameViewport=(frame,frameRect)=>{const visualViewport=frame.ownerDocument.defaultView?.visualViewport,[x,y,width,height]=frame===scrollingElement(frame)?[0,0,visualViewport?.width??frame.clientWidth,visualViewport?.height??frame.clientHeight]:[frameRect.left,frameRect.top,frame.clientWidth,frame.clientHeight],left=x+frame.clientLeft,top=y+frame.clientTop;return[top,left+width,top+height,left]},computeScrollIntoView=(element,options)=>{const actions=[];let ownerDocument=element.ownerDocument,ownerWindow=ownerDocument.defaultView;if(!ownerWindow)return actions;const computedStyle=window.getComputedStyle(element),isLTR="rtl"!==computedStyle.direction,writingMode=normalizeWritingMode(computedStyle.writingMode||computedStyle.getPropertyValue("-webkit-writing-mode")||computedStyle.getPropertyValue("-ms-writing-mode")),[alignH,alignV]=((options,writingMode,isLTR)=>{const[layout,hPos,vPos]=calcPhysicalAxis(writingMode,isLTR,options.block||"start",options.inline||"nearest");return[hPos,vPos].map((value,index)=>{switch(value){case"center":return 1;case"nearest":return 0;default:return"start"===value==!(layout>>index&1)?2:3}})})(options,writingMode,isLTR);let[top,right,bottom,left]=((element,elementRect,computedStyle)=>{const{top:top,right:right,bottom:bottom,left:left}=elementRect,scrollProperty=(ownerDocument=element.ownerDocument,["scroll-margin","scroll-snap-margin"].filter(property=>property in ownerDocument.documentElement.style)[0]);var ownerDocument;if(!scrollProperty)return[top,right,bottom,left];const scrollMarginValue=edge=>{const value=computedStyle.getPropertyValue(`${scrollProperty}-${edge}`);return parseInt(value,10)||0};return[top-scrollMarginValue("top"),right+scrollMarginValue("right"),bottom+scrollMarginValue("bottom"),left-scrollMarginValue("left")]})(element,element.getBoundingClientRect(),computedStyle);for(let frame=parentElement(element);null!==frame;frame=parentElement(frame)){if(ownerDocument!==frame.ownerDocument){if(ownerDocument=frame.ownerDocument,ownerWindow=ownerDocument.defaultView,!ownerWindow)break;const{left:dX,top:dY}=frame.getBoundingClientRect();top+=dY,right+=dX,bottom+=dY,left+=dX}const frameStyle=ownerWindow.getComputedStyle(frame);if("fixed"===frameStyle.position)break;if(!isScrollable(frame,frameStyle))continue;const frameRect=frame.getBoundingClientRect(),[frameTop,frameRight,frameBottom,frameLeft]=getFrameViewport(frame,frameRect),eAlignH=mapNearest(alignH,frameLeft,frameRight,frame.clientWidth,left,right,right-left),eAlignV=mapNearest(alignV,frameTop,frameBottom,frame.clientHeight,top,bottom,bottom-top),diffX=null===eAlignH?0:calcAlignEdge(eAlignH,left,right)-calcAlignEdge(eAlignH,frameLeft,frameRight),diffY=null===eAlignV?0:calcAlignEdge(eAlignV,top,bottom)-calcAlignEdge(eAlignV,frameTop,frameBottom),moveX=isXReversed(frameStyle)?clamp(diffX,-frame.scrollWidth+frame.clientWidth-frame.scrollLeft,-frame.scrollLeft):clamp(diffX,-frame.scrollLeft,frame.scrollWidth-frame.clientWidth-frame.scrollLeft),moveY=clamp(diffY,-frame.scrollTop,frame.scrollHeight-frame.clientHeight-frame.scrollTop);actions.push([frame,{left:frame.scrollLeft+moveX,top:frame.scrollTop+moveY,behavior:options.behavior}]),top=Math.max(top-moveY,frameTop),right=Math.min(right-moveX,frameRight),bottom=Math.min(bottom-moveY,frameBottom),left=Math.max(left-moveX,frameLeft)}return actions},scrollIntoView=(element,scrollIntoViewOptions,config)=>{const options=scrollIntoViewOptions||{};if(!checkBehavior(options.behavior))throw new TypeError(failedExecuteInvalidEnumValue("scrollIntoView","Element",options.behavior));computeScrollIntoView(element,options).forEach(([frame,scrollToOptions])=>{elementScroll(frame,scrollToOptions,config)})},elementScrollIntoView=scrollIntoView,createPolyfill=(scrollName,patch)=>config=>{if(isScrollBehaviorSupported())return;const scrollMethod={scroll:scroll_scroll,scrollTo:scrollTo,scrollBy:scrollBy}[scrollName];patch(scrollName,function(){const args=arguments;if(1===arguments.length)return void scrollMethod(this,args[0],config);const left=args[0],top=args[1];scrollMethod(this,{left:left,top:top})})},elementScrollPolyfill=createPolyfill("scroll",modifyPrototypes),elementScrollToPolyfill=createPolyfill("scrollTo",modifyPrototypes),elementScrollByPolyfill=createPolyfill("scrollBy",modifyPrototypes),modifyWindow=(prop,func)=>{markPolyfill(func),backupMethod(window,prop),window[prop]=func},windowScrollPolyfill=createPolyfill("scroll",modifyWindow),windowScrollToPolyfill=createPolyfill("scrollTo",modifyWindow),windowScrollByPolyfill=createPolyfill("scrollBy",modifyWindow);function elementScrollIntoViewBoolean(alignToTop){elementScrollIntoView(this,{block:alignToTop??1?"start":"end",inline:"nearest"})}const elementScrollIntoViewPolyfill=config=>{if(isScrollBehaviorSupported())return;const originalFunc=backupMethod(window.HTMLElement.prototype,"scrollIntoView",elementScrollIntoViewBoolean);modifyPrototypes("scrollIntoView",function scrollIntoView(){const args=arguments,options=args[0];1===args.length&&isObject(options)?elementScrollIntoView(this,options,config):originalFunc.apply(this,args)})},polyfill=config=>{isScrollBehaviorSupported()||(elementScrollPolyfill(config),elementScrollToPolyfill(config),elementScrollByPolyfill(config),elementScrollIntoViewPolyfill(config),windowScrollPolyfill(config),windowScrollToPolyfill(config),windowScrollByPolyfill(config))}}};